<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  <icon>https://www.gravatar.com/avatar/1e664c942599f0404df35da54598ea93</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-18T05:54:53.283Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>liuyt49</name>
    <email>1039868176@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>32. Longest Valid Parentheses</title>
    <link href="http://yoursite.com/2018/11/18/32-Longest-Valid-Parentheses/"/>
    <id>http://yoursite.com/2018/11/18/32-Longest-Valid-Parentheses/</id>
    <published>2018-11-18T05:52:43.000Z</published>
    <updated>2018-11-18T05:54:53.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>题目的意思比较简单，给出一个只由左括号和右括号组成的字符串，求出有效的括号匹配最长长度    </li></ul><h4 id="方法-1-利用stack"><a href="#方法-1-利用stack" class="headerlink" title="方法 1 - 利用stack"></a>方法 1 - <code>利用stack</code></h4><ul><li>利用数据结构<code>stack</code>完成，整个过程中<code>stack</code>的第一个元素为当前已遍历的不匹配括号串的最后一个<code>&#39;)&#39;</code>的下标或者<code>-1</code>，其余在<code>stack</code>中存储的是字符<code>&#39;(&#39;</code>的下标，参见阐述的步骤即可指定。使用<code>stack</code>的<code>FILO</code>    的特性完成判断字符是否括号是否匹配以及计算有效匹配括号的长度</li><li>步骤<ul><li>首先将<code>-1</code>推进<code>stack</code>中</li><li>遍历字符串，对于字符进行不同的处理<ul><li><code>&#39;(&#39;</code>， 直接将其下标推入栈中-<code>stack.push(i)</code></li><li><code>&#39;)&#39;</code>，首先弹出栈顶元素-<code>stack.pop()</code>。接下来的步骤需要划分两种情况进行：</li></ul><ol><li>如果当前栈中已经为空，即证明当前匹配的串已经无效，因为<code>&#39;)&#39;</code>数目大于<code>&#39;(&#39;</code>的数目，无法有效匹配括号，此时不做关于最长匹配的记录，<strong>只把当前下标推入栈中</strong>（当前<code>&#39;)&#39;</code>的下标即为已遍历的不匹配括号串的最后一个<code>&#39;)&#39;</code>的下标）</li><li>如果当前栈不为空，则证明目前匹配的串依旧有效，则更新一下最长匹配长度 - <code>num = max(num, i - myStack.top())</code></li></ol></li></ul></li><li>实现代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; myStack;</span><br><span class="line">        myStack.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                myStack.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                myStack.pop();</span><br><span class="line">                <span class="keyword">if</span>(myStack.empty()) </span><br><span class="line">                    myStack.push(i);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    num = max(num, i - myStack.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法-2-动态规划"><a href="#方法-2-动态规划" class="headerlink" title="方法 2 - 动态规划"></a>方法 2 - <code>动态规划</code></h4><ul><li>思路<ul><li>括号匹配的时候，遇到<code>&#39;)&#39;</code>才可能成功匹配上。因此，使用一个数组<code>num</code>记录每个<code>)</code>最长有效匹配的长度。</li><li>当前检索到<code>&#39;)&#39;</code>有两种情况<ul><li>情况1:  <code>&quot;...()...&quot;</code><ul><li>这种至少匹配的长度是2，但是可能连着之前也是有可能满足的，例如<code>&quot;...()()...&quot;</code>这种情况，因此需要考虑连着已匹配的-<code>(i &gt;= 2 ? num[i-2] : 0)</code>    </li><li>转移方程： <code>num[i] = (i &gt;= 2 ? num[i-2] : 0) + 2;</code>    </li></ul></li><li>情况2:  <code>&quot;...))...&quot;</code>        <ul><li>这种情况的匹配与前一个<code>&#39;)&#39;</code>相关，如果前面是有效匹配的，则需要检查<code>s[i-num[i-1]-1] == &#39;(&#39;</code>(条件：<code>i &gt;= num[i-1] + 1</code>)，即需要考虑<code>&quot;...((...))...&quot;</code>的情况。同时，还需要考虑前面是否可以与有效匹配的串连接起来，例如<code>&quot;...()((...))...&quot;</code>，因此还需要考虑连着已匹配的-<code>i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0</code></li><li>转移方程：<code>num[i] = num[i-1] + 2 + (i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0)</code></li></ul></li></ul></li></ul></li><li><p>实现代码</p><pre><code class="lang-cpp">  // dp  class Solution {  public:      int longestValidParentheses(string s) {          if(!s.size())    return 0;          int maxNum = 0;          int num[s.size()] = {0};          for(int i = 1; i &lt; s.size(); ++i){              if(s[i] == &#39;)&#39; &amp;&amp; s[i-1] == &#39;(&#39;) {                  // &quot;...()...&quot;                      num[i] = (i &gt;= 2 ? num[i-2] : 0) + 2;              }              else if(s[i] == &#39;)&#39; &amp;&amp; s[i-1] == &#39;)&#39; &amp;&amp; i &gt;= num[i-1] + 1 &amp;&amp; s[i-num[i-1]-1] == &#39;(&#39;) {                  // &quot;...((...))...&quot;                   num[i] = num[i-1] + 2 + (i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0);              }              maxNum = max(maxNum, num[i]);          }          return maxNum;      }  };</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a string containing just the characters &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>72. Edit Distance</title>
    <link href="http://yoursite.com/2018/11/18/72-Edit-Distance/"/>
    <id>http://yoursite.com/2018/11/18/72-Edit-Distance/</id>
    <published>2018-11-18T05:48:30.000Z</published>
    <updated>2018-11-18T05:50:49.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two words word1 and word2, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p><p>You have the following 3 operations permitted on a word:</p><ul><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ul><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (remove &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (remove &apos;e&apos;)</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (insert &apos;u&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><ul><li>这道题是一道动态规划的题，需要将一个字符串<code>word1</code>经过<code>add</code>、<code>delete</code>、<code>replace</code>三种操作变换成另一个字符串<code>word2</code>，求最小的编辑距离.</li><li><p>解题思路：假设<code>word1=[123...n]</code>    ,<code>word2=[123...m]</code>，要求使得<code>word1</code>转换成<code>word2</code>。对于这个问题，我们将其分解为子问题求解。</p><ul><li>定义dis[i][j]<ul><li>表示<code>word1&#39; = [1..i]</code>转换成<code>word2&#39; = [1...j]</code>的编辑距离（<code>i</code>代表<code>word1</code>前<code>i</code>个字符,<code>j</code>代表<code>word2</code>前<code>j</code>个字符）</li><li>因此<code>word1</code>到<code>word2</code>的编辑距离为<code>dis[n][m]</code>        </li></ul></li><li>求解<code>word1</code>到<code>word2</code>的编辑距离，我们可以求取<code>word1</code>的前<code>i</code>个字符(<code>0 &lt; i &lt; n</code>)到<code>word2</code>的前<code>j</code>个字符(<code>0 &lt; j &lt; m</code>)的编辑距离<code>dis[i][j]</code>。当然每个<code>dis[i][j]</code>都基于之前的计算。</li><li><p>步骤</p><ul><li>初始化<ul><li>dis[i, 0] = i</li><li>dis[0, j] = j</li></ul></li><li><p><strong>递推关系</strong>—<code>核心</code>    </p><script type="math/tex; mode=display">dis[i][j] = min \begin{cases}      dis[i][j-1] + 1\\      dis[i-1][j] + 1\\      dis[i-1][j-1] + (word1[i-1] == word2[j-1] ? 0 : 1))\\      \end{cases}</script><p>  其中三个操作的表示</p><ul><li><strong>insert</strong>:     <code>dis[i, j] = dis[i][j-1] + 1</code>    </li><li><strong>delete</strong>:    <code>dis[i, j] = dis[i-1][j] + 1</code></li><li><p><strong>replace or no op</strong>：<code>dis[i, j] = dis[i-1][j-1] + (word1[i-1] == word2[j-1] ? 0 : 1)</code></p><p>对于每<code>dis[i][j]</code>，我们选取最小编辑距离    </p></li></ul></li></ul></li><li>最后得到的<code>dis[n][m]</code>就是<code>word1</code>到<code>word2</code>的编辑距离</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size();</span><br><span class="line">        <span class="keyword">int</span> n = word2.size();</span><br><span class="line">        <span class="keyword">int</span> dis[m+<span class="number">1</span>][n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">            dis[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n; ++j)</span><br><span class="line">            dis[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m or n equal 0</span></span><br><span class="line">        <span class="keyword">if</span> (!m &amp;&amp; !n)</span><br><span class="line">            <span class="keyword">return</span> max(m, n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// insert: dis[i, j] = dis[i][j-1] + 1</span></span><br><span class="line">        <span class="comment">// delete:dis[i, j] = dis[i-1][j] + 1</span></span><br><span class="line">        <span class="comment">// replace or no op：dis[i, j] = dis[i-1][j-1] + (word1[i-1] == word2[j-1] ? 0 : 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dis[i][j] = min(dis[i][j<span class="number">-1</span>] + <span class="number">1</span>,</span><br><span class="line">                    min(dis[i<span class="number">-1</span>][j] + <span class="number">1</span>, dis[i<span class="number">-1</span>][j<span class="number">-1</span>] + (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] ? <span class="number">0</span> : <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://web.stanford.edu/class/cs124/lec/med.pdf" target="_blank" rel="noopener">参考链接 - pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two words word1 and word2, find the minimum number of operations
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>55. Jump Game</title>
    <link href="http://yoursite.com/2018/11/17/55-Jump-Game/"/>
    <id>http://yoursite.com/2018/11/17/55-Jump-Game/</id>
    <published>2018-11-17T07:43:09.000Z</published>
    <updated>2018-11-17T07:44:33.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>题意比较简单，给定每一个点能向前跳跃的距离，求是否能从初始位置到末尾位置</li><li>思路：使用一个变量<code>maxDis</code>记录当前能访问到最远的节点 ，遍历数组节点时候，需要判断当前节点能否被访问到，如果能访问到，则以该节点能访问到的最远节点<code>i + nums[i]</code>与当前能访问的最远节点<code>maxDis</code>比较，使得<code>maxDis = max(maxDis, i + nums[i]</code>(<strong>核心状态转移</strong>)。如果<code>maxDis &gt;= nums.size() - 1</code>，则证明可以访问到最后一个节点。</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(maxDis &lt; len - <span class="number">1</span> &amp;&amp; maxDis &gt;= i &amp;&amp; i &lt; len) &#123;</span><br><span class="line">            maxDis = max(maxDis, i + nums[i]);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDis &gt;= len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an array of non-negative integers, you are initially positioned 
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>330. Patching Array</title>
    <link href="http://yoursite.com/2018/11/17/330-Patching-Array/"/>
    <id>http://yoursite.com/2018/11/17/330-Patching-Array/</id>
    <published>2018-11-17T07:37:21.000Z</published>
    <updated>2018-11-18T13:02:34.883Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3], n = 6</span><br><span class="line">Output: 1 </span><br><span class="line">Explanation:</span><br><span class="line">Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.</span><br><span class="line">Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].</span><br><span class="line">Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].</span><br><span class="line">So we only need 1 patch.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,5,10], n = 20</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The two patches can be [2, 4].</span><br></pre></td></tr></table></figure></p><p><strong>Example 3:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,2], n = 5</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ul><li>题意：题目指给出一个有序的正整数的数列<code>nums</code>，以及一个正整数<code>n</code>，最少需要额外添加的多少个数字才能使得<code>[1,n]</code>中每一个数字能够被数列中若干个数字的和表示，求出最少需要添加的数字数。</li><li><p>解题思路：假设当前<code>[0, t)</code>中每个数字可以由数列中的数字以及额外添加的数字的和表示，则当其选择到下一个<code>num[i]</code>的时候，分两种情况讨论</p><ul><li><code>num[i] &lt;= t</code><ul><li>此时可以将维护的区间扩展到<code>[0 , t+num[i] ]</code></li></ul></li><li><p><code>num[i] &gt; t</code> </p><ul><li>此时不能直接扩展区间，因为中间有一段数字<code>[t, num[i] - 1]</code>是无法表示的。因此此时需要加一个额外的数字，加的数字应该尽可能的大，否则将可能会增加额外需要数字的数目。<strong>当前能够加的最大数字是<code>t</code></strong>，因为如果额外添加的数字<code>newNum</code>大于<code>t</code>，则对于区间<code>[t, newNum - 1]</code>这一段的数字则无法表示，因此每次最多加<code>t</code>，区间扩展到<code>[t, t+t]</code>，同时统计添加数字<code>addNum + 1</code>.</li></ul><p>当前维护的<code>t &gt; n</code>的时候，可以直接输出结果</p></li><li>然而，问题并没有解决，出现了超时的问题。对于测试数据感觉还是比较小的，不太可能是由于时间复杂度出错。然后最后的结果是<code>2147483647</code>，接近了<code>int</code>的最大值，考虑到是区间扩展<code>t + t</code>的时候导致溢出，一直导致<code>t &lt; n</code>，出现死循环了，因此将<code>t</code>改为<code>long long</code>类型<br><img src="/2018/11/17/330-Patching-Array/1.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [0, rightSide)</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rightSide = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> addNums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rightSide &gt; n)<span class="keyword">return</span> addNums;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; rightSide &amp;&amp; rightSide &lt;= n) &#123;</span><br><span class="line">            rightSide += rightSide;</span><br><span class="line">            addNums++;</span><br><span class="line">        &#125;</span><br><span class="line">        rightSide += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rightSide &lt;= n) &#123;</span><br><span class="line">        rightSide += rightSide;</span><br><span class="line">        addNums++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNums;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/17/330-Patching-Array/2.png" alt="在这里插入图片描述"></p><ul><li>感觉写的思路还是比较混乱，然后稍微优化一下代码的结构</li><li>优化代码</li><li>谈一个新发现： 本来对于区间扩展部分都是使用<code>+=</code>操作，但是最后运行时间与未优化的没有区别，然后看了下提交的dalao们的代码，发现都是<code>a = a + b</code>这样形式的操作，不使用<code>+=</code>操作的，然后就惊奇的发现运行时间神奇的减少大半了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [0, rightSide)</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rightSide = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> addNums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rightSide &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; size &amp;&amp; rightSide &gt;= nums[i]) &#123;</span><br><span class="line">                rightSide = rightSide + nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightSide = rightSide + rightSide;</span><br><span class="line">                ++addNums; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/17/330-Patching-Array/3.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a sorted positive integer array nums and an integer n, add/patch
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 5 Go语言net/http源码解读</title>
    <link href="http://yoursite.com/2018/11/16/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-5-Go%E8%AF%AD%E8%A8%80net-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/11/16/服务计算-5-Go语言net-http源码解读/</id>
    <published>2018-11-16T05:24:26.000Z</published>
    <updated>2018-11-16T13:01:34.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景要提"><a href="#背景要提" class="headerlink" title="背景要提"></a>背景要提</h3><p><code>net/http</code>标准库可以分为客户端和服务器两个部分。以下是net/http标准库的各个组成部分的关于客户端和服务端的一个划分：</p><blockquote><p>图片来源 - 《Go Web编程》<br><img src="net-http标准库的各个组成部分.png" alt="服务计算-5-Go语言net-http源码解读"></p></blockquote><p>如何开始阅读源码，首先我们需要了解一下http包的执行流程:<br><img src="http包执行流程.png" alt="http包执行流程"></p><p>主要步骤:</p><ol><li>创建<code>Listen Socket</code>, 监听指定的端口, 等待客户端请求到来</li><li><code>Listen Socket</code>接受客户端的请求, 得到<code>Client Socket</code>, 接下来通过<code>Client Socket</code>与客户端通信</li><li>创建<code>go</code>线程服务一个连接，处理客户端的请求。 首先从<code>Client Socket</code>读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据。然后交给相应的<code>handler</code>处理请求, <code>handler</code>处理完毕准备好客户端需要的数据, 通过<code>Client Socket</code>写给客户端</li></ol><p>接下来主要通过源码分析服务端的具体实现流程。</p><h3 id="分析Http服务器的执行过程"><a href="#分析Http服务器的执行过程" class="headerlink" title="分析Http服务器的执行过程"></a>分析Http服务器的执行过程</h3><p><img src="http连接处理流程.png" alt="http连接处理流程"></p><h4 id="编写一个简单的服务器"><a href="#编写一个简单的服务器" class="headerlink" title="编写一个简单的服务器"></a>编写一个简单的服务器</h4><p>首先我们需要编写一个简单的服务器，然后逐步的对其中机制进行剖析，关于如何查看源码建议适用<code>VSCode</code>，<code>VSCode</code>安装相关包(<code>godef</code>等等)以后可以直接跳转到相关源码部分，当然也可以考虑直接去<a href="https://sourcegraph.com/github.com/golang/go/-/tree/src/net/http" target="_blank" rel="noopener">源码</a>逐步看。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/hello"</span>, sayHello)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(res, <span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h4><p>首先我们先分析<code>http.HandleFunc(&quot;/hello&quot;, sayHello)</code>，先查看一下源码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们又遇到问题了，<code>DefaultServeMux</code>是什么玩意。这时还是需要继续查看相关的源码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.RWMutex   <span class="comment">// 锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">m  <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry  <span class="comment">// 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式</span></span><br><span class="line">hosts <span class="keyword">bool</span> <span class="comment">// 是否在任意的规则中带有host信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">h        Handler <span class="comment">// 这个路由表达式对应哪个handler</span></span><br><span class="line">pattern  <span class="keyword">string</span>  <span class="comment">// 匹配字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewServeMux allocates and returns a new ServeMux.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">()</span> *<span class="title">ServeMux</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(ServeMux) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure></p><p><code>ServeMux</code>结构体：HTTP请求的多路转接器（路由），它负责将每一个接收到的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。它内部用一个map来保存所有处理器Handler。</p><p><code>DefaultServeMux</code>，其实就是一个默认路由，是<code>ServeMux</code>的一个实例，使用包级别的<code>http.Handle()</code>、<code>http.HandleFunc()</code>方法注册处理器时都是注册到该路由中。我们来看看<code>DefaultServeMux.HandleFunc(pattern, handler)</code>中的<code>HandleFunc</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后只能继续看<code>Handle</code>方法的实现<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">mux.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">&#125;</span><br><span class="line">mux.m[pattern] = muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">mux.hosts = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码还是比较直观的，就是将相关信息加入到<code>map</code>中。</p><p>了解完路由信息的注册，我们还需要知道路由信息是如何分发的。</p><h4 id="监听端口、处理请求、路由分配"><a href="#监听端口、处理请求、路由分配" class="headerlink" title="监听端口、处理请求、路由分配"></a>监听端口、处理请求、路由分配</h4><p>服务器中<code>http.ListenAndServe()</code>方法启动服务。但是其究竟是如何实现的呢，我们需要参考下源码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先生成了一个<code>Server</code>对象，然后调用了它的<code>ListenAndServe</code>方法。Server对象封装了有关提供web服务相关的所有信息，是一个比较核心的类。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Server defines parameters for running an HTTP server.</span></span><br><span class="line"><span class="comment">// The zero value for Server is a valid configuration.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr    <span class="keyword">string</span>  <span class="comment">// TCP address to listen on, ":http" if empty</span></span><br><span class="line">Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TLSConfig optionally provides a TLS configuration for use</span></span><br><span class="line"><span class="comment">// by ServeTLS and ListenAndServeTLS. Note that this value is</span></span><br><span class="line"><span class="comment">// cloned by ServeTLS and ListenAndServeTLS, so it's not</span></span><br><span class="line"><span class="comment">// possible to modify the configuration with methods like</span></span><br><span class="line"><span class="comment">// tls.Config.SetSessionTicketKeys. To use</span></span><br><span class="line"><span class="comment">// SetSessionTicketKeys, use Server.Serve with a TLS Listener</span></span><br><span class="line"><span class="comment">// instead.</span></span><br><span class="line">TLSConfig *tls.Config</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadTimeout is the maximum duration for reading the entire</span></span><br><span class="line"><span class="comment">// request, including the body.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because ReadTimeout does not let Handlers make per-request</span></span><br><span class="line"><span class="comment">// decisions on each request body's acceptable deadline or</span></span><br><span class="line"><span class="comment">// upload rate, most users will prefer to use</span></span><br><span class="line"><span class="comment">// ReadHeaderTimeout. It is valid to use them both.</span></span><br><span class="line">ReadTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadHeaderTimeout is the amount of time allowed to read</span></span><br><span class="line"><span class="comment">// request headers. The connection's read deadline is reset</span></span><br><span class="line"><span class="comment">// after reading the headers and the Handler can decide what</span></span><br><span class="line"><span class="comment">// is considered too slow for the body.</span></span><br><span class="line">ReadHeaderTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteTimeout is the maximum duration before timing out</span></span><br><span class="line"><span class="comment">// writes of the response. It is reset whenever a new</span></span><br><span class="line"><span class="comment">// request's header is read. Like ReadTimeout, it does not</span></span><br><span class="line"><span class="comment">// let Handlers make decisions on a per-request basis.</span></span><br><span class="line">WriteTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdleTimeout is the maximum amount of time to wait for the</span></span><br><span class="line"><span class="comment">// next request when keep-alives are enabled. If IdleTimeout</span></span><br><span class="line"><span class="comment">// is zero, the value of ReadTimeout is used. If both are</span></span><br><span class="line"><span class="comment">// zero, ReadHeaderTimeout is used.</span></span><br><span class="line">IdleTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxHeaderBytes controls the maximum number of bytes the</span></span><br><span class="line"><span class="comment">// server will read parsing the request header's keys and</span></span><br><span class="line"><span class="comment">// values, including the request line. It does not limit the</span></span><br><span class="line"><span class="comment">// size of the request body.</span></span><br><span class="line"><span class="comment">// If zero, DefaultMaxHeaderBytes is used.</span></span><br><span class="line">MaxHeaderBytes <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TLSNextProto optionally specifies a function to take over</span></span><br><span class="line"><span class="comment">// ownership of the provided TLS connection when an NPN/ALPN</span></span><br><span class="line"><span class="comment">// protocol upgrade has occurred. The map key is the protocol</span></span><br><span class="line"><span class="comment">// name negotiated. The Handler argument should be used to</span></span><br><span class="line"><span class="comment">// handle HTTP requests and will initialize the Request's TLS</span></span><br><span class="line"><span class="comment">// and RemoteAddr if not already set. The connection is</span></span><br><span class="line"><span class="comment">// automatically closed when the function returns.</span></span><br><span class="line"><span class="comment">// If TLSNextProto is not nil, HTTP/2 support is not enabled</span></span><br><span class="line"><span class="comment">// automatically.</span></span><br><span class="line">TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ConnState</span> <span class="title">specifies</span> <span class="title">an</span> <span class="title">optional</span> <span class="title">callback</span> <span class="title">function</span> <span class="title">that</span> <span class="title">is</span></span></span><br><span class="line"><span class="function">// <span class="title">called</span> <span class="title">when</span> <span class="title">a</span> <span class="title">client</span> <span class="title">connection</span> <span class="title">changes</span> <span class="title">state</span>. <span class="title">See</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">// <span class="title">ConnState</span> <span class="title">type</span> <span class="title">and</span> <span class="title">associated</span> <span class="title">constants</span> <span class="title">for</span> <span class="title">details</span>.</span></span><br><span class="line"><span class="function"><span class="title">ConnState</span> <span class="title">func</span><span class="params">(net.Conn, ConnState)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ErrorLog</span> <span class="title">specifies</span> <span class="title">an</span> <span class="title">optional</span> <span class="title">logger</span> <span class="title">for</span> <span class="title">errors</span> <span class="title">accepting</span></span></span><br><span class="line"><span class="function">// <span class="title">connections</span>, <span class="title">unexpected</span> <span class="title">behavior</span> <span class="title">from</span> <span class="title">handlers</span>, <span class="title">and</span></span></span><br><span class="line"><span class="function">// <span class="title">underlying</span> <span class="title">FileSystem</span> <span class="title">errors</span>.</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">nil</span>, <span class="title">logging</span> <span class="title">is</span> <span class="title">done</span> <span class="title">via</span> <span class="title">the</span> <span class="title">log</span> <span class="title">package</span>'<span class="title">s</span> <span class="title">standard</span> <span class="title">logger</span>.</span></span><br><span class="line"><span class="function"><span class="title">ErrorLog</span> *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">disableKeepAlives</span> <span class="title">int32</span>     // <span class="title">accessed</span> <span class="title">atomically</span>.</span></span><br><span class="line">inShutdown        int32     // accessed atomically (non-zero means we're in Shutdown)</span><br><span class="line">nextProtoOnce     sync.Once <span class="comment">// guards setupHTTP2_* init</span></span><br><span class="line">nextProtoErr      error     <span class="comment">// result of http2.ConfigureServer if used</span></span><br><span class="line"></span><br><span class="line">mu         sync.Mutex</span><br><span class="line">listeners  <span class="keyword">map</span>[*net.Listener]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">activeConn <span class="keyword">map</span>[*conn]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">doneChan   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">onShutdown []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>再回到刚刚说到的<code>Server</code>对象调用它自己的<code>ListenAndServe</code>方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address srv.Addr and then</span></span><br><span class="line"><span class="comment">// calls Serve to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If srv.Addr is blank, ":http" is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error. After Shutdown or Close,</span></span><br><span class="line"><span class="comment">// the returned error is ErrServerClosed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line">addr := srv.Addr</span><br><span class="line"><span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">addr = <span class="string">":http"</span></span><br><span class="line">&#125;</span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ln</code>是一个监听<code>tcp</code>指定端口的监听器，接着把监听器<code>ln</code>断言转换为<code>TCPListener</code>类型，并根据它构造一个<code>tcpKeepAliveListener</code>对象并传递给<code>server.Serve()</code>方法。接着，我们再看看这个<code>Serve</code>方法的功能<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve accepts incoming connections on the Listener l, creating a</span></span><br><span class="line"><span class="comment">// new service goroutine for each. The service goroutines read requests and</span></span><br><span class="line"><span class="comment">// then call srv.Handler to reply to them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span></span><br><span class="line"><span class="comment">// connections and they were configured with "h2" in the TLS</span></span><br><span class="line"><span class="comment">// Config.NextProtos.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Serve always returns a non-nil error and closes l.</span></span><br><span class="line"><span class="comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">fn(srv, l) <span class="comment">// call hook with unwrapped listener</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l = &amp;onceCloseListener&#123;Listener: l&#125;</span><br><span class="line"><span class="keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !srv.trackListener(&amp;l, <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> srv.trackListener(&amp;l, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tempDelay time.Duration     <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rw, e := l.Accept()</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line"><span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tempDelay *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">tempDelay = max</span><br><span class="line">&#125;</span><br><span class="line">srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">time.Sleep(tempDelay)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">tempDelay = <span class="number">0</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line"><span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这一段我们从原作者的注释就可以了解到这个函数的功能，主要是为每个请求创建一个<code>goroutines</code>进行处理。首先调用<code>tcpKeepAliveListener</code>对象的<code>Accept()</code>方法返回一个连接<code>conn</code>，并为每一个<code>conn</code>创建一个新的<code>goroutines</code>执行<code>conn.server()</code>方法</p><blockquote><p>Go为了实现高并发和高性能, 使用了goroutines来处理Conn的读写事件, 这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。这是Go高效的保证。</p></blockquote><p><code>conn.server()</code>实现的功能比较复杂，还涉及到<code>net</code>模块。<code>conn.server()</code>主要读取请求，然后根据<code>conn</code>内保存的<code>server</code>来构造一个<code>serverHandler</code>类型，并调用它的<code>ServeHTTP()</code>方法：<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>，该方法的源码如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">handler := sh.srv.Handler</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，如果没有指定路由，那么将会使用我们之前介绍的默认路由-<code>DefaultServeMux</code>，接着调用<code>handler</code>的<code>ServerHTTP</code>方法。这时我们将会遇到一个接口<code>Handler</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Handler</code>接口，所有请求的处理器、路由<code>ServeMux</code>都满足该接口。再如前文提到的。接着我们来看看<code>ServeHTTP</code>方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">&#125;</span><br><span class="line">w.WriteHeader(StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">h, _ := mux.Handler(r)</span><br><span class="line">h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>路由<code>ServeMux</code>的<code>ServeHTTP</code>方法中的<code>mux.Handler(r)</code>则会根据当前请求提供的信息来查找最匹配的<code>Handler</code>即路由，然后该路由调用自己处理请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The HandlerFunc type is an adapter to allow the use of</span></span><br><span class="line"><span class="comment">// ordinary functions as HTTP handlers. If f is a function</span></span><br><span class="line"><span class="comment">// with the appropriate signature, HandlerFunc(f) is a</span></span><br><span class="line"><span class="comment">// Handler that calls f.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>大致的流程如上分析，当然这只是一个比较粗劣的解析过程，详情还是需要不断的研读源码。关于<code>net</code>部分没有进行研究，以及对于比较精髓部分<code>conn</code>也没有详细介绍，接下来将会补上。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://sourcegraph.com/github.com/golang/go/-/tree/src/net/http" target="_blank" rel="noopener">Go源码</a></li><li><a href="https://www.cnblogs.com/zongjiang/p/6550319.html" target="_blank" rel="noopener">golang http server分析(一)</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.3.md" target="_blank" rel="noopener">Go如何使得Web工作</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景要提&quot;&gt;&lt;a href=&quot;#背景要提&quot; class=&quot;headerlink&quot; title=&quot;背景要提&quot;&gt;&lt;/a&gt;背景要提&lt;/h3&gt;&lt;p&gt;&lt;code&gt;net/http&lt;/code&gt;标准库可以分为客户端和服务器两个部分。以下是net/http标准库的各个组成部分的
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>134. Gas Station</title>
    <link href="http://yoursite.com/2018/11/15/134-Gas-Station/"/>
    <id>http://yoursite.com/2018/11/15/134-Gas-Station/</id>
    <published>2018-11-15T05:17:01.000Z</published>
    <updated>2018-11-15T05:18:27.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>There are N gas stations along a circular route, where the amount of gas at station i is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p><p><strong>Note:</strong></p><ul><li>If there exists a solution, it is guaranteed to be unique.</li><li>Both input arrays are non-empty and have the same length.</li><li>Each element in the input arrays is a non-negative integer.</li></ul><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 4. Your tank = 4 - 1 + 5 = 8</span><br><span class="line">Travel to station 0. Your tank = 8 - 2 + 1 = 7</span><br><span class="line">Travel to station 1. Your tank = 7 - 3 + 2 = 6</span><br><span class="line">Travel to station 2. Your tank = 6 - 4 + 3 = 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 0. Your tank = 4 - 3 + 2 = 3</span><br><span class="line">Travel to station 1. Your tank = 3 - 3 + 3 = 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这道题还是比较简单的，给出汽车行驶到每个点需要的油量<code>cost[i]</code>以及该点可以补充的油量<code>gas[i]</code>     ,求能否顺序走完一圈</li><li>首先整个行程的总代价<code>total</code>=<code>gas总和</code> - <code>cost总和</code>，如果<code>total</code>小于0，则整个行程不可能可以被完成，但是如果<code>total</code>大于0，则行程一定可以被完成。</li><li><code>preTank</code>记录从开始节点<code>i</code>到当前节点<code>j</code>所得代价<ul><li><code>preTank &lt; 0</code>，则说明不能顺利到达，因为<code>cost</code>比<code>gas</code>大，当然两个地点中间的任意一点也是不能顺利到达的，因为每次前进的<code>preTank</code>都需要大于等于0，此时需要把当前节点作为行程的节点，并且<code>preTank = gas[j] - cost[j]</code>。</li><li><code>preTank &gt;= 0</code>， <code>preTank += gas[j] - cost[j]</code>，继续前进。 </li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = gas.size();</span><br><span class="line">        <span class="keyword">int</span> preTank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(preTank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                preTank = gas[i] - cost[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                preTank += gas[i] - cost[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tank &gt;= <span class="number">0</span> ? start : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;There are N gas stations along a circular route, where the amount of g
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>210. Course Schedule II</title>
    <link href="http://yoursite.com/2018/11/15/210-Course-Schedule-II/"/>
    <id>http://yoursite.com/2018/11/15/210-Course-Schedule-II/</id>
    <published>2018-11-15T05:16:40.000Z</published>
    <updated>2018-11-18T12:59:32.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>There are a total of n courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of <code>prerequisite pairs</code>, return the ordering of courses you should take to finish all courses.</p><p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] .</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     </span><br><span class="line">                courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. </span><br><span class="line">                So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong>    </p><ul><li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="noopener">how a graph is represented</a>.</li><li>You may assume that there are no duplicate edges in the input prerequisites.</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这题与之前的<a href="https://liu-yt.github.io/2018/11/14/207-Course-Schedule/" target="_blank" rel="noopener">207. Course Schedule</a>题意差不多，只不过<code>Course Schedule</code>只需判断能否顺利修完课程，<code>Course Schedule ll</code>需要先判断能否修完，能修完需要返回一个选修的顺序，否则返回一个空的。</li><li>思路与上周介绍的实现相同，只是对代码进行优化。</li><li>具体步骤    <ul><li>建立邻接表，关系为后修过程，即每个课程存储需先修完该课程才能修的课程。同时得出每个课程的入度，即每个课程需要的先修课程的数目</li><li>将入度为0的课程加入队列中，同时将该课程邻接表存储的后修课程的入度减1，判断修改后的节点的度数是否为0，为0则加入队列中（注：每当节点加入到队列中，同时也加入到拓扑排序的数组中）</li><li>重复上述步骤，直到队列为空</li><li>判断数组与课程的数是否相等，相等则证明可以拓扑排序，否则证明存在未被加入的课程并且无法完成的课程（课程选修关系存在环）</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">int</span> inDegree[numCourses] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录课程需要先修课程的数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对应存储需要修完该课程才能修的课程</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : prerequisites) &#123;</span><br><span class="line">            inDegree[it.first]++;</span><br><span class="line">            myVec[it.second].push_back(it.first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                v.push_back(i);</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; myVec[tmp].size(); ++j) &#123;</span><br><span class="line">                    inDegree[myVec[tmp][j]]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[myVec[tmp][j]] == <span class="number">0</span>) &#123;</span><br><span class="line">                        v.push_back(myVec[tmp][j]);</span><br><span class="line">                        q.push(myVec[tmp][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v.size() == numCourses) </span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v.clear();</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/15/210-Course-Schedule-II/1.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;There are a total of n courses you have to take, labeled from &lt;code&gt;0&lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>785. Is Graph Bipartite?</title>
    <link href="http://yoursite.com/2018/11/14/785-Is-Graph-Bipartite/"/>
    <id>http://yoursite.com/2018/11/14/785-Is-Graph-Bipartite/</id>
    <published>2018-11-14T03:28:31.000Z</published>
    <updated>2018-11-14T03:30:31.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p><p>Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p><p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists.  Each node is an integer between <code>0</code> and <code>graph.length - 1</code>.  There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn’t contain any element twice.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>graph will have length in range [1, 100].</li><li>graph[i] will contain integers in range [0, graph.length - 1].</li><li>graph[i] will not contain i or duplicate values.</li><li>The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题给了无向图的边，判断这个图是否是一个二分图</li><li>什么是二分图？<blockquote><p>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。孤立点可以任意划分在A或B集合。</p></blockquote></li><li>解法：<ul><li>使用<code>BFS + 染色法</code></li><li><code>BFS</code>以未被染色且非孤立点的点作为<code>BFS</code>搜索的起点</li><li>使用<code>染色法</code>，只使用两种颜色，将与该点相邻（存在一条边）且未被染色的点染成与其不同的颜色，假如相邻的点已被染色且颜色与该点相同，则证明该图不是二分图。</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 染色法 + BFS</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = graph.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> colors[num] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> visited[num] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i].size() &gt; <span class="number">0</span> &amp;&amp; visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// bfs</span></span><br><span class="line">                <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> top = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> i : graph[top]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">                            visited[i] = <span class="number">1</span>;</span><br><span class="line">                            colors[i] = !colors[top];</span><br><span class="line">                            q.push(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(colors[i] == colors[top])</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an undirected &lt;code&gt;graph&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt; if an
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>207. Course Schedule</title>
    <link href="http://yoursite.com/2018/11/14/207-Course-Schedule/"/>
    <id>http://yoursite.com/2018/11/14/207-Course-Schedule/</id>
    <published>2018-11-14T03:00:13.000Z</published>
    <updated>2018-11-18T12:58:12.094Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>There are a total of n courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">            To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">            To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong></p><ol><li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="noopener">how a graph is represented</a>.</li><li>You may assume that there are no duplicate edges in the input prerequisites.</li></ol><hr><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>题意比较容易理解，就是需要选修某一门课程的时候，需要先修某一门课程，给出一组课程的先修关系，问是否能完成课程。这个问题可以抽象为有向图求是否有环路问题，课程的先修关系是一个有向边，每一门课程就是一个点。</li><li>问题抽象成有向图求是否存在环路问题，思考有向图求存在环路的方法。</li></ul><h4 id="拓扑排序实现"><a href="#拓扑排序实现" class="headerlink" title="拓扑排序实现"></a>拓扑排序实现</h4><ul><li>什么是拓扑排序？<blockquote><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。    </p></blockquote></li><li>为什么用拓扑排序？<blockquote><p>如果能够用拓扑排序完成对图中所有节点的排序的话，就说明这个图中没有环，而如果不能完成，则说明有环</p></blockquote></li><li><p>怎样进行拓扑排序？</p><blockquote><ol><li>建立图的邻接表</li><li>然后找出入度数为0的点    </li><li>删除入度数为0的点，将其指这些点的边也删除，同时将这些点加入到结果队列中</li><li>重复2，直到没有点的入度为0</li><li>判断是否仍存在未被加入的点，若存在证明有环</li></ol></blockquote></li><li><p>当然本题不需要这么完整的步骤，不需要得到排序结果什么的，只需要最后判断下是否有环，然后返回<code>true</code>或者<code>false</code> </p></li><li>时间复杂度：$O(V+E)$</li></ul><h4 id="DFS实现"><a href="#DFS实现" class="headerlink" title="DFS实现"></a>DFS实现</h4><ul><li><a href="https://blog.csdn.net/xiangyaquan/article/details/48261949" target="_blank" rel="noopener">需要对DFS有一定深入的了解，了解树边，前向边等等</a></li><li><p>需要DFS稍加变化，来解决这个问题。解决的方法如下：</p><p>  图中的一个节点，根据其<code>vertexState[i]</code>的值，有三种状态：</p><blockquote><p><strong>点的状态</strong></p><ul><li>-1 - 已被访问过，正在访问其后代节点</li><li>0 - 未被访问过</li><li>1 - 已被访问过，且其子节点亦全部访问过</li></ul></blockquote><p>  按照这样的假设，当按照DFS进行搜索时，碰到一个节点时有三种可能：</p><blockquote><p>1、如果vertexState[V]=0，这是一个新的节点，未被访问过，进行dfs搜索<br>2、如果vertexState[V]=-1，说明是在访问该节点的后代的过程中访问到该节点本身，则图中有环。<br>3、如果vertexState[V]=1，该点已经被访问过，且以该点与其后代节点构成的一个子图是一个非强连通图，则遇到这类点不可能有环存在。</p></blockquote></li><li><p>时间复杂度：$O(V)$</p></li></ul><hr><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="解法1-拓扑排序"><a href="#解法1-拓扑排序" class="headerlink" title="解法1 - 拓扑排序"></a>解法1 - 拓扑排序</h4><ul><li><p>拓扑排序思路</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numCourses &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> n = numCourses;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : prerequisites)</span><br><span class="line">            myVec[it.first].insert(it.second);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(myVec[i].size() == <span class="number">0</span>)</span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            n -= size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numCourses; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == tmp)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(myVec[j].find(tmp) != myVec[j].end()) &#123;</span><br><span class="line">                        myVec[j].erase(myVec[j].find(tmp));</span><br><span class="line">                        <span class="keyword">if</span> (myVec[j].size() == <span class="number">0</span>) </span><br><span class="line">                            q.push(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  <img src="/2018/11/14/207-Course-Schedule/1.png" alt="在这里插入图片描述"></p></li><li><p>拓扑排序优化 — <a href="https://liu-yt.github.io/2018/11/15/210-Course-Schedule-II/" target="_blank" rel="noopener">Course Schedule ll</a>中思路</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 1 优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inDegree[numCourses] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录课程需要先修课程的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对应存储需要修完该课程才能修的课程</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : prerequisites) &#123;</span><br><span class="line">            inDegree[it.first]++;</span><br><span class="line">            myVec[it.second].insert(it.first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            numCourses -= size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="comment">// 此处的引用很精髓！！！！</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : myVec[tmp]) &#123;</span><br><span class="line">                    inDegree[j]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.push(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>遍历节点度数时候使用引用传递</p><p>  <img src="/2018/11/14/207-Course-Schedule/2.png" alt="在这里插入图片描述"></p></li><li><p>遍历节点度数时候使用值传递</p><p>  <img src="/2018/11/14/207-Course-Schedule/3.png" alt="在这里插入图片描述"></p></li><li><p><strong>引用传递</strong>：在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。<strong>值传递</strong>：形参是实参的拷贝，改变形参的值并不会影响外部实参的值，形参有自己独立的存储空间，每次都需要在栈中申请内存空间并且拷贝实参。因此，引用传递比值传递需要的操作时间小多了。</p></li></ul></li></ul><h4 id="解法2-DFS"><a href="#解法2-DFS" class="headerlink" title="解法2 - DFS"></a>解法2 - DFS</h4><ul><li><p>优化的DFS实现</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : prerequisites)</span><br><span class="line">            myVec[it.second].insert(it.first);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *点的状态</span></span><br><span class="line"><span class="comment">        * -1 - 已被访问过，正在访问其后代节点</span></span><br><span class="line"><span class="comment">        * 0 - 未被访问过</span></span><br><span class="line"><span class="comment">        * 1 - 已被访问过，且其子节点亦全部访问过</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> vertexState[numCourses] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i, myVec, vertexState))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; myVec, <span class="keyword">int</span> *vertexState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vertexState[node] == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        vertexState[node] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : myVec[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vertexState[i] == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i, myVec, vertexState))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vertexState[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  <img src="/2018/11/14/207-Course-Schedule/4.png" alt="在这里插入图片描述"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;There are a total of n courses you have to take, labeled from &lt;code&gt;0&lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>332. Reconstruct Itinerary</title>
    <link href="http://yoursite.com/2018/11/13/332-Reconstruct-Itinerary/"/>
    <id>http://yoursite.com/2018/11/13/332-Reconstruct-Itinerary/</id>
    <published>2018-11-13T11:39:46.000Z</published>
    <updated>2018-11-13T11:54:03.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p><p><strong>Note:</strong></p><ol><li><p>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].</p></li><li><p>All airports are represented by three capital letters (IATA code).</p></li></ol><ol><li>You may assume all tickets form at least one valid itinerary.</li></ol><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].But it is larger in lexical order.</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题是关于图的边进行遍历，每张机票都是图的一条有向边，需要找出经过每条边的路径，并且必定有解本题，则对于某个节点（非起点）其只于一个节点相邻且只存在一条边，则这个节点必定是最后访问的，否则不可能遍历完所有边，并且这种点最多一个（不包含起点）。 </li></ul><h4 id="解法-1-—-DFS-递归"><a href="#解法-1-—-DFS-递归" class="headerlink" title="解法 1 —    DFS + 递归"></a>解法 1 —    <code>DFS + 递归</code></h4><ul><li>解决步骤<ul><li>将图建立起来，建立邻接表，使用<code>map&lt;string, multiset&lt;string&gt;</code> 来存储邻接表。使用multiset可以自动排序。（<code>set的默认排序由小到大，multiset默认排序是由大到小</code>）</li><li>从节点<code>JKF</code>开始DFS遍历，只要当前的映射集合<code>multiset</code>里面还有节点，则取出这个节点，递归遍历这个节点，同时需要将这个节点从<code>multiset</code>中删除掉，当映射集合<code>multiset</code>为空的时候，则将节点加入到结果中</li><li>因为当前存储结果是回溯得到的，需要将结果的存储顺序反转输出    </li></ul></li><li>实现代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; tickets) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; &gt; myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tickets)</span><br><span class="line">            myMap[it.first].insert(it.second);</span><br><span class="line"></span><br><span class="line">        dfs(<span class="string">"JFK"</span>, v, myMap);</span><br><span class="line">        reverse(v.begin(), v.end());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(myMap[start].size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> next = *myMap[start].begin();</span><br><span class="line">            myMap[start].erase(myMap[start].begin());</span><br><span class="line">            dfs(next, v, myMap);</span><br><span class="line">        &#125;</span><br><span class="line">        v.push_back(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解法-2-—-DFS-迭代"><a href="#解法-2-—-DFS-迭代" class="headerlink" title="解法 2 — DFS + 迭代"></a>解法 2 — <code>DFS + 迭代</code></h4><ul><li>思路与解法一相同，利用数据结构<code>stack</code>进行迭代。</li><li>实现代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; tickets) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; &gt; myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tickets)</span><br><span class="line">            myMap[it.first].insert(it.second);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; myStack;</span><br><span class="line">        myStack.push(<span class="string">"JFK"</span>);</span><br><span class="line">        <span class="keyword">while</span>(!myStack.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> node = myStack.top();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!myMap[node].size()) &#123;</span><br><span class="line">                myStack.pop();</span><br><span class="line">                v.push_back(node);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                myStack.push(*myMap[node].begin());</span><br><span class="line">                myMap[node].erase(myMap[node].begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(v.begin(), v.end());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a list of airline tickets represented by pairs of departure and 
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>310. Minimum Height Trees</title>
    <link href="http://yoursite.com/2018/11/13/310-Minimum-Height-Trees/"/>
    <id>http://yoursite.com/2018/11/13/310-Minimum-Height-Trees/</id>
    <published>2018-11-13T11:37:52.000Z</published>
    <updated>2018-11-18T12:56:50.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p></li><li><p><strong>Format</strong></p><ol><li><p>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number n and a list of undirected <code>edges</code> (each edge is a pair of labels).</p></li><li><p>You can assume that no duplicate <code>edges</code> will appear in edges. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p></li></ol></li><li><p>Example 1 :</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]</span><br><span class="line"></span><br><span class="line">        0</span><br><span class="line">        |</span><br><span class="line">        1</span><br><span class="line">       / \</span><br><span class="line">      2   3 </span><br><span class="line"></span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></li><li><p>Example 2 :</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span><br><span class="line"></span><br><span class="line">     0  1  2</span><br><span class="line">      \ | /</span><br><span class="line">        3</span><br><span class="line">        |</span><br><span class="line">        4</span><br><span class="line">        |</span><br><span class="line">        5 </span><br><span class="line"></span><br><span class="line">Output: [3, 4]</span><br></pre></td></tr></table></figure></li><li><p><strong>Note:</strong></p><ul><li>According to <a href="https://en.wikipedia.org/wiki/Tree_%28graph_theory%29" target="_blank" rel="noopener">the definition of tree on Wikipedia</a>: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</li><li>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</li></ul></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="解法1-暴力破解-超时，Failed"><a href="#解法1-暴力破解-超时，Failed" class="headerlink" title="解法1 - 暴力破解(超时，Failed)"></a>解法1 - <strong>暴力破解</strong>(<code>超时</code>，<code>Failed</code>)</h4><ul><li>步骤<ul><li>以每个节点都为根，对每个节点使用BFS遍历得到以该节点为根时树的高度</li><li>比较各个节点时树的高度，得到<code>Minimum Height Trees</code>的根节点</li></ul></li><li><p>代码</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> edgesArray[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> height[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            height[i] = getHeight(n, i, edges);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最小高度树的根节点</span></span><br><span class="line">        <span class="keyword">int</span> min = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; min) &#123;</span><br><span class="line">            min = height[i];</span><br><span class="line">            v.clear();</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(height[i] == min) &#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> visited[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        visited[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = edges.begin(); iter != edges.end(); iter++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*iter).first == tmp || (*iter).second == tmp) &#123;</span><br><span class="line">            <span class="keyword">int</span> newNode = (*iter).first + (*iter).second - tmp;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[newNode]) &#123;</span><br><span class="line">                            depth[newNode] = depth[tmp] + <span class="number">1</span>;</span><br><span class="line">                            q.push(newNode);</span><br><span class="line">                            visited[newNode] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[i] &gt; max)</span><br><span class="line">                max = depth[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>复杂度 — $O(V^2E)$ (<code>V</code>表示节点数量，<code>E</code>表示边的数量)</p></li><li>结果果然超时了<br>  <img src="/2018/11/13/310-Minimum-Height-Trees/1.png" alt="在这里插入图片描述"></li><li><p>改进与优化</p><ul><li>可以利用map数据结构，来存储每个节点对应其连接的节点所组成的一个映射<code>map&lt;int, vector&lt;int&gt; &gt;</code>，或者一个二维数组</li><li>复杂度 — $O(VE)$ (<code>V</code>表示节点数量，<code>E</code>表示边的数量)</li><li><p>优化的代码            </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; myMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> height[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = edges.begin(); iter != edges.end(); iter++) &#123;</span><br><span class="line">            myMap[(*iter).first].push_back((*iter).second);</span><br><span class="line">            myMap[(*iter).second].push_back((*iter).first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            height[i] = getHeight(n, i, myMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最小高度树的根节点</span></span><br><span class="line">        <span class="keyword">int</span> min = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; min) &#123;</span><br><span class="line">                    min = height[i];</span><br><span class="line">            v.clear();</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(height[i] == min) &#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> visited[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        visited[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter = myMap[tmp].begin(); iter != myMap[tmp].end(); iter++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[(*iter)]) &#123;</span><br><span class="line">                    depth[(*iter)] = depth[tmp] + <span class="number">1</span>;</span><br><span class="line">                    q.push((*iter));</span><br><span class="line">                    visited[(*iter)] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[i] &gt; max)</span><br><span class="line">                max = depth[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>但是依旧超时<br><img src="/2018/11/13/310-Minimum-Height-Trees/2.png" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="思考提示：How-many-MHTs-can-a-graph-have-at-most"><a href="#思考提示：How-many-MHTs-can-a-graph-have-at-most" class="headerlink" title="思考提示：How many MHTs can a graph have at most?"></a>思考提示：<strong>How many MHTs can a graph have at most?</strong></h4><ul><li>每个树最多有两个MHTs。假如有三个或多个可以作为MHTs的根节点，根据树的定义，每两个节点都可以找到一条路径连接起来，树是一个强连通的图，不存在简单环，则至少一个一个或多个比其余节点高，则大于三个MHTs不成立。</li></ul><h4 id="解法2-—-类剥洋葱求解-AC"><a href="#解法2-—-类剥洋葱求解-AC" class="headerlink" title="解法2 — 类剥洋葱求解(AC)"></a>解法2 — <strong>类剥洋葱求解</strong>(<code>AC</code>)</h4><ul><li>本方法学习自其他优秀解法</li><li>步骤<ol><li>建立一个映射表，记录每一个点与其直接相连的点</li><li>将树的叶节点（度为1的节点）加入一个队列中</li><li>假如当前队列中存储的节点数<strong>小于等于2</strong>，则退出循环。否则遍历队列中的每个节点。对每个节点，将其弹出队列，同时将与其相连节点的集合中将该节点删去，如果删完该节点后此节点也变成一个叶节点（度数为1），那么将这个节点加入队列中。</li></ol></li><li>时间复杂度 — $O(n)$</li><li>实现代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge : edges) &#123;</span><br><span class="line">            myVec[edge.first].insert(edge.second);</span><br><span class="line">            myVec[edge.second].insert(edge.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(myVec[i].size() == <span class="number">1</span>)</span><br><span class="line">                q.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            n -= size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it : myVec[tmp]) &#123;</span><br><span class="line">                    myVec[it].erase(tmp);</span><br><span class="line">                    <span class="keyword">if</span> (myVec[it].size() == <span class="number">1</span>) q.push(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            ans.push_back(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For a undirected graph with tree characteristics, we can choo
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>64. Minimum Path Sum</title>
    <link href="http://yoursite.com/2018/11/12/64-Minimum-Path-Sum/"/>
    <id>http://yoursite.com/2018/11/12/64-Minimum-Path-Sum/</id>
    <published>2018-11-12T02:06:58.000Z</published>
    <updated>2018-11-12T02:15:55.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p></li><li><p><strong>Note:</strong> You can only move either down or right at any point in time.</p></li><li><p><strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">    [1,3,1],</span><br><span class="line">    [1,5,1],</span><br><span class="line">    [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题比较简单，题意是寻找m x n格中左上角到右下角路径的最小距离，并且没有负权值</li><li><code>dp[i][j]:起点到点 [i,j]的最小距离</code></li><li>因为没有负路径和寻路方向只能向下或者向右，因此对于每个点(除起点)，其<code>dp[i][j]</code>的表示为    <code>dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]</code></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Given a m x n grid filled with non-negative numbers, find a p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>50. Pow(x, n)</title>
    <link href="http://yoursite.com/2018/11/12/50-Pow-x-n/"/>
    <id>http://yoursite.com/2018/11/12/50-Pow-x-n/</id>
    <published>2018-11-12T02:06:40.000Z</published>
    <updated>2018-11-12T02:17:15.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Implement pow(x, n), which calculates x raised to the power n (xn).</p><ul><li><p>Example 1:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure></li><li><p>Example 2:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure></li><li><p>Example 3:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure></li></ul><p><strong>Note:</strong></p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n is a 32-bit signed integer, within the range [$−2^{31}$, $2^{31}$ − 1]     </li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="解法-1-—-暴力破解（Failed）"><a href="#解法-1-—-暴力破解（Failed）" class="headerlink" title="解法 1 — 暴力破解（Failed）"></a>解法 1 — <strong>暴力破解</strong>（<code>Failed</code>）</h4><ul><li>将n的值分为<code>n&gt;0</code>,<code>n&lt;0</code>,<code>n=0</code>三种情况</li><li>递归算出结果</li><li><p>实现代码        </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一 暴力破解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(n); ++i) &#123;</span><br><span class="line">            result *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? result : <span class="number">1</span> / result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>这种做法测试后果然不能<code>AC</code>，错误分析</p><ul><li><p>时间$O(n)$，当n很大时，超时</p></li><li><p>未考虑边界条件<code>n =INT_MIN</code>，这个时候<code>-n</code>赋不进<code>n</code></p></li></ul></li></ul><h4 id="解法-2-—-分治（AC）"><a href="#解法-2-—-分治（AC）" class="headerlink" title="解法 2 — 分治（AC）"></a>解法 2 — <strong>分治</strong>（<code>AC</code>）</h4><ul><li><p>超时问题解决</p><ul><li>将$x^n$分解为$x^{n/2} <em> x^{n/2} </em>  x^{n\%2}$递归求解</li><li>时间复杂度$O(logn)$</li></ul></li><li><p>边界越界问题解决</p><ul><li>n = $-2^{31}$时，通过简单的<code>-n</code>来求其相反数将导致溢出，最大正整数为$2^{31}-1$</li><li>对于<code>n&lt;0</code>的情况，令$n’ = -(n+1)$ 。求$x^n$等价于求 $1 / (x^{n’}*x)$</li></ul></li><li>实现代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法二 分治 + 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 越处理--粗糙版</span></span><br><span class="line">            <span class="comment">// x = 1.0 / x;</span></span><br><span class="line">            <span class="comment">// if(n == INT_MIN)</span></span><br><span class="line">            <span class="comment">// return x * myPow(x, -1* (n+1));</span></span><br><span class="line">            <span class="comment">// else</span></span><br><span class="line">            <span class="comment">// return myPow(x, -1 * n);</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 越界处理--精简版 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / (x * myPow(x, <span class="number">-1</span> * (n+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> tmp = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span>  == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> tmp * tmp;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> tmp * tmp * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Implement pow(x, n), which calculates x raised to the power n (xn).&lt;/p
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>22. Generate Parentheses</title>
    <link href="http://yoursite.com/2018/11/11/22-Generate-Parentheses/"/>
    <id>http://yoursite.com/2018/11/11/22-Generate-Parentheses/</id>
    <published>2018-11-11T07:24:31.000Z</published>
    <updated>2018-11-18T12:50:36.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br>For example, given n = 3, a solution set is:      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;((()))&quot;,</span><br><span class="line">    &quot;(()())&quot;,</span><br><span class="line">    &quot;(())()&quot;,</span><br><span class="line">    &quot;()(())&quot;,</span><br><span class="line">    &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题是利用溯源算法去解决的，穷举出每一种可能性，把所有成功的解都返回解空间。<ul><li>本题利用递归和DFS进行解决，其中重点是找到递归的传递关系，在理解递归的时候只需将其理解成一个黑盒子，考虑其中的效果</li><li>递归的思路<ul><li>回归条件  ：<code>当左右括号加起来等于2n的时候</code></li><li>选择条件1：<code>当左括号的数量小于n的时候</code></li><li>递归关系1：<code>左括号的数量加1</code></li><li>选择条件2：<code>当右括号的数量小于左括号的数量的时候</code> </li><li>递归关系2：<code>右括号的数量加1</code></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        dfs(str, <span class="number">0</span>, <span class="number">0</span>, n, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> buildStr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left + right == <span class="number">2</span> * n) &#123;</span><br><span class="line">            v.push_back(<span class="built_in">string</span>(buildStr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n) &#123;</span><br><span class="line">            dfs(buildStr + <span class="string">"("</span>, left + <span class="number">1</span>, right, n, v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &lt; left) &#123;</span><br><span class="line">            dfs(buildStr + <span class="string">")"</span>, left, right + <span class="number">1</span>, n, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given n pairs of parentheses, write a function to generate all c
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>5. Longest Palindromic Substring</title>
    <link href="http://yoursite.com/2018/11/11/5-Longest-Palindromic-Substring/"/>
    <id>http://yoursite.com/2018/11/11/5-Longest-Palindromic-Substring/</id>
    <published>2018-11-11T07:00:51.000Z</published>
    <updated>2018-11-11T07:30:39.519Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</li><li><strong>Example</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>这道题要求我们找出一个字符串里面的最长回文串，而什么是回文串呢，回文串就是正反读都是一样的字符串。对于这个问题，解决方法就是找一个字符，以其为中心，向两边扩展寻找出最长的回文串，该算法的时间复杂度为$O(n)$,当然还需要注意一点的就是回文串的长度可奇可偶，如长度为奇数的回文串”aba”以及长度为偶数的回文串”baab”，因此在以某个字符为中心的向两边扩展的需要额外的考虑。</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i+<span class="number">1</span>]) </span><br><span class="line">                searchLongestPalindrome(i, i+<span class="number">1</span>, id, len, s);</span><br><span class="line">            searchLongestPalindrome(i, i, id, len, s);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> s.substr(id, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">searchLongestPalindrome</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> &amp;id, <span class="keyword">int</span> &amp;len, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = right - left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt;= len) &#123;</span><br><span class="line">            id = left + <span class="number">1</span>;</span><br><span class="line">            len = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h3><ul><li>对于解决回文子串问题，有一种更加高效的算法，<code>拉车算法(Manacher‘s Algorithm)</code>是用来查找一个字符串的最长回文子串的线性方法，其时间复杂度仅为$O(n)$<ul><li>此方法是学习其他博客的解法<ul><li><a href="https://blog.csdn.net/Form_/article/details/79766986" target="_blank" rel="noopener">参考博客1</a></li><li><a href="http://www.cnblogs.com/grandyang/p/4475985.html" target="_blank" rel="noopener">参考博客2</a></li></ul></li><li>更优解法实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 解法二 Manacher Algorithm 马拉车算法 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) </span><br><span class="line">            str = str + s[i] + <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">-1</span>;    <span class="comment">// 最长回文子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxId = <span class="number">-1</span>;    <span class="comment">// 最长回文子串中心点的位置</span></span><br><span class="line">        <span class="keyword">int</span> p[str.size()] = &#123;&#125;; <span class="comment">// 记录当前为起点回文串的长度</span></span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>, mx = <span class="number">0</span>; <span class="comment">// id为已知的最大回文子串中心的位置，mx是已知最大回文串的右边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; mx)</span><br><span class="line">                p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                p[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(str[i - p[i]] == str[i + p[i]])</span><br><span class="line">                p[i]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx)这句代码，从而提高效率</span></span><br><span class="line">            <span class="keyword">if</span>(mx &lt; i + p[i]) &#123;</span><br><span class="line">                id = i;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p[i] - <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i] <span class="number">-1</span>;</span><br><span class="line">                maxId = i;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = (maxId - maxLen - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 将最长回文子串起始位置转换回原串</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given a string s, find the longest palindromic substring in s. Y
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>41. First Missing Positive</title>
    <link href="http://yoursite.com/2018/11/10/41-First-Missing-Positive/"/>
    <id>http://yoursite.com/2018/11/10/41-First-Missing-Positive/</id>
    <published>2018-11-10T01:54:02.000Z</published>
    <updated>2018-11-10T01:58:59.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given an unsorted integer array, find the smallest missing positive integer.</li><li><p><strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></li><li><p><strong>Note:</strong> Your algorithm should run in O(n) time and uses constant extra space.</p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题的题意比较容易理解，即寻找一个无序的数组里面找到一个最小缺失的正整数</li><li>第一想法是将无序数组进行排序，然后遍历一遍排好序的数组即可找出最小缺失的正整数，但是排序算法最优解的时间复杂度都为O(nlogn)，显然不能满足题目的时间复杂度要求</li><li>其次的主要想法就是利用数组的下标，因为下标是从0开始的，不断累增的数列，并且除0外都是正整数<ul><li>遍历数组，将当前元素交换到其减一后作为下标的位置，即<code>nums[i]</code>与<code>nums[nums[i] - 1]</code>进行交换，即将<code>1</code>放到数组<code>0</code>号位，将<code>2</code>放到数组<code>1</code>号位，依此类推。这个步骤比较关键，其中小坑也比较多，有些是提交了才发现的<ul><li>交换条件的选择，可能被交换的元素必须要满足<code>&gt; 0</code>&amp;&amp;<code>&lt; array.size</code>&amp;&amp;<code>nums[i] != nums[nums[i] - 1]</code>,其中最后一个条件是避免两个位置不断的执行交换，例如输入[1,1]的情况，造成死循环</li><li>循环变量的控制，当需要交换的时候需要将循环变量-1，或者说不发生交换的时候，循环变量+1</li></ul></li><li>再次遍历数组，将第一个下标 与对应位置元素 - 1不等的下标返回，若都相等，则返回<code>数组的size</code> + 1</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minPos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将满足条件的的元素进行交换，将元素放到数组下标等于该元素的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; size &amp;&amp; nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，寻找下标与对应位置不等的下标，此下标即为最小整数，否则则为size+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) </span><br><span class="line">            <span class="keyword">if</span>(i != nums[i] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given an unsorted integer array, find the smallest missing posit
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>8. String to Integer (atoi)</title>
    <link href="http://yoursite.com/2018/11/10/8-String-to-Integer-atoi/"/>
    <id>http://yoursite.com/2018/11/10/8-String-to-Integer-atoi/</id>
    <published>2018-11-10T01:49:29.000Z</published>
    <updated>2018-11-10T01:52:14.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p><strong>Note:</strong></p><ul><li>Only the space character<code>&#39; &#39;</code> is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [$−2^{31}$,  $2^{31}$ − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.</li></ul><p><strong>Example:</strong></p><blockquote><p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p><p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer.Thefore INT_MIN (−2^31) is returned.</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题就是相当于重写atoi这个函数，将字符串转化成整数</li><li>本题需要注意的点<ul><li>将字符串前面的空白去掉</li><li>数字的正负</li><li>数字溢出</li><li>输入无效</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">// 返回的数字</span></span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>; <span class="comment">// 返回数字的符号</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str[i] == <span class="string">' '</span>) &#123; ++i; &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; str.length &amp;&amp; (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)) &#123;</span><br><span class="line">        sign = str[i] == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span> &amp;&amp; i &lt; str.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; INT_MAX / <span class="number">10</span> || (ans == INT_MAX / <span class="number">10</span>  &amp;&amp; str[i] &gt; <span class="string">'7'</span>))</span><br><span class="line">            <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">        ans = ans * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;
&lt;p&gt;The funct
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <link href="http://yoursite.com/2018/11/09/3-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://yoursite.com/2018/11/09/3-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2018-11-09T07:13:22.000Z</published>
    <updated>2018-11-09T07:15:19.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given a string, find the length of the longest substring without repeating characters.</li><li>Example   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题目的是得到字符串里面没有重复字符的最长子串的长度，一开始首先想到的就是两个嵌套的循环，通过暴力破解，寻找每个字符开头的最大字串，时间复杂度比较高，为O(n^2)。</li><li>通过与别人讨论得到一定的启发，从头开始遍历字符，类似滑窗思想来解决本题<ul><li>利用一个数组来判断字符是否已经在子串中，其中字符的ASCII值作为数组的下标，其在字符串中的下标则存储在数组相应下标指向的位置</li><li>假设当遇到一个字符‘a’已经出现当前子串中，则从该子串中的’a’的前一个字符继续当前子串的扩展，新的子串的初始长度为<code>i[第二个&#39;a&#39;的下标]-重复字符的下标[第一个&#39;a&#39;的下标]</code></li><li>时间复杂度 O(n)</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;  <span class="comment">// 记录最长字串的长度</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;        <span class="comment">// 遍历字符串时候记录当前字串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[s[i]] == <span class="number">-1</span>) </span><br><span class="line">            ++tmp;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">128</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[s[i]])</span><br><span class="line">                    <span class="built_in">array</span>[j] = <span class="number">-1</span>;</span><br><span class="line">            tmp = i - <span class="built_in">array</span>[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        maxLength = maxLength &gt; tmp ? maxLength : tmp;</span><br><span class="line">        <span class="built_in">array</span>[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given a string, find the length of the longest substring without
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>67. Add Binary</title>
    <link href="http://yoursite.com/2018/11/09/67-Add-Binary/"/>
    <id>http://yoursite.com/2018/11/09/67-Add-Binary/</id>
    <published>2018-11-09T07:07:30.000Z</published>
    <updated>2018-11-09T07:10:35.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given two binary strings, return their sum (also a binary string).</li><li>The input strings are both non-empty and contains only characters 1 or 0.</li></ul><blockquote><p>example<br>Input: a = “11”, b = “1”<br>Output: “100”</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>二进制的高精度加法，对字符对应数字从低位逐位的相加，同时加上低位相加得到的进位，不断计算得到新的进位以及相加的结果，最后得到结果。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制高精度加法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>; <span class="comment">// 答案字符串</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            ans += (a[i] - <span class="string">'0'</span> + b[j] - <span class="string">'0'</span> + carry) % <span class="number">2</span> + <span class="string">'0'</span>;</span><br><span class="line">            carry = a[i] - <span class="string">'0'</span> + b[j] - <span class="string">'0'</span> + carry &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a.length() &gt;= b.length()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                ans += (a[i] - <span class="string">'0'</span> + carry) % <span class="number">2</span> + <span class="string">'0'</span>;</span><br><span class="line">                carry = a[i] - <span class="string">'0'</span> + carry &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                ans += (b[j] - <span class="string">'0'</span> + carry) % <span class="number">2</span> + <span class="string">'0'</span>;</span><br><span class="line">                carry = b[j] - <span class="string">'0'</span> + carry &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            ans += carry + <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">        reverse(ans.begin(), ans.end()); </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given two binary strings, return their sum (also a binary string
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>1. Two Sum</title>
    <link href="http://yoursite.com/2018/11/09/1-Two-Sum/"/>
    <id>http://yoursite.com/2018/11/09/1-Two-Sum/</id>
    <published>2018-11-09T06:43:50.000Z</published>
    <updated>2018-11-09T07:05:29.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><blockquote><p>Example:<br>    Given nums = [2, 7, 11, 15], target = 9,<br>   Because nums[0] + nums[1] = 2 + 7 = 9,     return [0, 1].</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>暴力破解，遍历每个元素x并查找是否有另一个值等于target - x。</li><li>时间复杂度为 $O(n^2)$</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target - nums[i] == nums[j]) &#123;</span><br><span class="line">                    ans.push_back(i);</span><br><span class="line">                    ans.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h3><ul><li>这个是看了答案发现的，利用map的查找，节省时间。</li><li>时间复杂度为 $O(nlogn)$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.count(target - nums[i])) &#123;</span><br><span class="line">                ans.push_back(myMap.find(target - nums[i])-&gt;second);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                myMap.insert(make_pair(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such tha
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
