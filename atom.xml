<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  <icon>https://www.gravatar.com/avatar/1e664c942599f0404df35da54598ea93</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-07T07:03:57.492Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>liuyt49</name>
    <email>1039868176@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能区块链拓展方法</title>
    <link href="http://yoursite.com/2019/01/07/%E9%AB%98%E6%80%A7%E8%83%BD%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/01/07/高性能区块链拓展方法/</id>
    <published>2019-01-07T06:59:26.000Z</published>
    <updated>2019-01-07T07:03:57.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结当前区块链研究中用于提高区块链系统性能和可扩展性的方法。并详细说明侧链技术，以及通过以太坊构建侧链的方法</p></blockquote><p>如今，性能过低是当前区块链技术面临的主要挑战之一。区块链的性能指标主要包括交易吞吐量和延时。比特币理论上每秒最多只能处理七笔交易，每十分钟出一个区块，相当于交易吞吐量为7，交易延时为10分钟，实际上，等待最终确认需要6个左右的区块，也就是说实际交易延时是1个小时。以太坊稍有提高，但也远远不能满足应用需求。从区块链技术来看，目前影响区块链性能因素主要包括广播通信、信息加解密、共识机制、交易验证机制等几个环节。目前提高区块链性能与扩展性已经提出几种方法，主要包括<strong>分片（Sharding）、离链计算（Off-chain computing）及侧链（Slidechain）、有向无环结构（DAG）</strong>等等，这些方式主要是通过将部分链上任务转到链下或其他链进行处理，或者将整个交易分为几个部分并分别处理，另一种思路是<strong>调整共识机制</strong>，采用新的可扩展的共识协议，从PoW到PoS再到DPoS和各种BFT类算法，共识机制不断创新，区块链平台性能也得到大幅提升，或者<strong>系统优化</strong>，通过优化系统 架构、代码结构、 数据存储效率、 网络发送效率等， 提高区块链性能。</p><ul><li><p>分片（Sharding）。分片技术是一种基于数据库分片传统概念的扩容技术，它将数据库分割成多个碎片并将这些碎片放置在不同的服务器上。在公共区块链的情境中，网络上的交易将被分成不同的碎片，其由网络上的不同节点组成。因此，每个节点只需处理一小部分传入的交易，并且通过与网络上的其他节点并行处理就能完成大量的验证工作。将网络分割为碎片会使得更多的交易同时被处理和验证。因此，随着网络的增长，区块链处理越来越多的交易将成为可能。这种属性也称为水平扩容。</p></li><li><p>有向无环结构（DAG）。DAG区块链技术没有区块概念，不是把所有数据打包成区块，再用区块链接区块，而是每个用户都可以提交一个数据单元，这个数据单元里可以有很多东西，比如交易、消息等等。数据单元间通过引用关系链接起来，从而形成具有半序关系的DAG（有向无环图）。DAG的特点是把数据单元的写入操作异步化，大量的钱包客户端可以自主异步地把交易数据写入DAG，从而可以支持极大的并发量和极高的速度。</p></li><li><p><strong>离链计算/侧链</strong>。在主链之下进行交易，中间交 易不进入主链确认，待最后一 笔交易完成后回归到主链。</p><ul><li><p><strong>什么是侧链？</strong></p><p>侧链本质上是一种<strong>跨区块链解决方案</strong>。通过这种解决方案，可以实现数字资产从第一个区块链到第二个区块链的转移，又可以在稍后的时间点从第二个区块链安全返回到第一个区块链。其中第一个区块链通常被称为主区块链或者主链，每二个区块链则被称为侧链。最初，主链通常指的是比特币区块链，而现在主链可以是任何区块链。侧链协议被设想为一种允许数字资产在主链与侧链之间进行转移的方式，其实现的技术基础是<strong>双向锚定（Two-way Peg）</strong>，通过双向锚定技术，可以实现暂时的将数字资产在主链中锁定，同时将等价的数字资产在侧链中释放，同样当等价的数字资产在侧链中被锁定的时候，主链的数字资产也可以被释放。双向锚定实现的最大难点是协议改造需兼容现有主链，也就是不能对现有主链的工作造成影响，其具体实现方式可以分为以下几类：单一托管模式、联盟模式、SPV模式、驱动链模式、混合模式。</p></li></ul></li></ul><h2 id="以太坊构建侧链的方法"><a href="#以太坊构建侧链的方法" class="headerlink" title="以太坊构建侧链的方法"></a>以太坊构建侧链的方法</h2><p>在以太坊上构建侧链，我们可以使用到Plasma。Plasma是一种处理链下交易的技术，需要依赖以太坊底层技术去对其安全性进行保障，它可以允许在以太坊主链上创建“子链”，同时这些“子链”也可以创建它们自己的“子链”。</p><p>任何人都可以在以太坊主链上创建个人化的 Plasma 智能合约，Plasma智能合约运行在根链（以太坊主网）之上，形成一个可靠的侧链链接网络连接到一个分层和树状结构的根链，强制执行区块链历史和 MapReducible 计算进入一系列的 merkle 证明。同时Plasma 链的一个关键属性是所谓的退出机制，它允许用户放弃子链，一旦出现任何问题时可以将资金提取到根链。所有在 Plasma 链上的交易完成都是依靠加密签章，不需要经过主链的共识，经过一段时间后才批次性的广播并写入主链中。因此大量在 Plasma 上的所有交易最后只会浓缩成少数比交易打包进主链中，大幅度降低区块链膨胀问题。</p><p>更加通俗的说明一下Plasma运作：</p><ul><li>首先，我们需要在以太坊主链创建一套智能合约，作为服务于我们Plasma子链的Root。Plasma Root包含了子链的基本状态交易规则，记录了子链状态的哈希值，并且让用户在以太坊主链和子链之间转移资产。</li><li>然后，在将子链根植于主链上之后，子链就被创造出来了。这个子链拥有自己的共识算法，且独立于以太坊主链。然后，我们就可以依据自己的需求来使用了。</li></ul><p>当然现在也有更加好的平台和工具，例如Loom Network，其被称为以太坊上的EOS，其核心产品是一款SDK - Loom SDK。Loom SDK会生成一个称为DApp链的产物（DApp链使用基于Plasma的中继来与以太坊之间来回转移资产），它是一个用以太坊作为基础层的第二层区块链，同时SDK允许开发者选择他们自己的共识算法和规则集。</p><p>参考文献</p><ul><li><a href="https://plasma.io/plasma.pdf" target="_blank" rel="noopener">Plasma: Scalable Autonomous Smart Contracts</a></li><li><a href="https://medium.com/@argongroup/ethereum-plasma-explained-608720d3c60e" target="_blank" rel="noopener">Explained: Ethereum Plasma</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;总结当前区块链研究中用于提高区块链系统性能和可扩展性的方法。并详细说明侧链技术，以及通过以太坊构建侧链的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如今，性能过低是当前区块链技术面临的主要挑战之一。区块链的性能指标主要包括交易吞吐量和延时。比特
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/"/>
    <id>http://yoursite.com/2019/01/04/区块链发展与现状/</id>
    <published>2019-01-04T14:21:31.500Z</published>
    <updated>2019-01-07T07:00:30.296Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 区块链发展与现状<br>date: 2019-01-04 22:21:31<br>tags: 区块链</p><h2 id="categories-区块链"><a href="#categories-区块链" class="headerlink" title="categories: 区块链"></a>categories: 区块链</h2><p>​本次主要阅读了三篇论文，所探讨的主题与当前区块链的安全性以及区块链市场相关。论文<sup><a href="#fn_1" id="reffn_1">1</a></sup>主要以Mt.Gox交易所的交易网络作为样本分析加密货币市场中的市场操纵以及操纵模式，其将交易历史通过一系列的分析以及构造成需要的图，将所有账号分成三类：高账户（EHA）、低账户（ELA）、一般账户（NMA），数据分析发现不正常的账户交易和比特币的价格有关联，此外异常账户存在许多奇怪的事务模式（如自循环、双向、三角形等），这些模式证明了交易市场中存在大量的市场操纵行为。论文<sup><a href="#fn_2" id="reffn_2">2</a></sup>主要通过数据处理和机器学习方法来检测庞氏骗局，其主要基于分析用户交易信息得到用户特征以及反解智能合约的字节码得到操作码，该方法对于检测不提供源代码的智能合约（用户无法之间了解真正的合约内容）是否为庞氏骗局有较大的意义。论文<sup><a href="#fn_3" id="reffn_3">3</a></sup>主要利用图分析技术对区块链中的用户特征进行分类，并用交叉图技术研究以太坊安全问题。</p><p>​区块链可以说是当今最热门的研究方向之一，很多区块链项目也已经落地。但是目前区块链市场方面还是比较混乱的，区块链因为其匿名性以及去中心化吸引大量关注，但是也因为其特性而导致其更加的难以管控与更多安全性问题。目前区块链市场情况比较复杂，很多人只是利用区块链项目圈钱，割完“韭菜”就跑路，也有部分人通过ICO(首次代币发行)进行非法集资，同时存在许多欺诈行为，受害者被骗以后也难以追究到具体的责任（匿名性），更别说挽回损失，更多的只能在各大论坛上发自己被骗了发发牢骚。同时，对于Mt.Gox交易所泄露的交易信息分析中也发现了大量操纵行为，侧面说明区块链市场操纵盛行。操纵市场行为，原本是指个人或机构背离市场自由竞争和供求关系原则，人为地操纵证券价格，以引诱他人参与证券交易，为自己牟取私利的行为，在区块链市场里面主要是部分人通过某些操纵手段（例如：不正常的事务）来引起加密数字货币的价格浮动，从而从中谋取私利。目前证券市场方面由于国家的严加管控已经难以发生市场操纵的行为，而对于区块链这个去中心化的领域而言，如果不能合理的解决市场操纵的问题，则将会称为少部分人的游戏，将造成巨大的不良影响，也将限制区块链的发展与应用。</p><p>​对于区块链领域，目前国家也出台了相关的文件，对一些违法行为进行了监管与约束，例如严禁通过ICO来进行非法融资，同时也发布相应的科普文章《区块链能做什么、不能做什么？》来避免群众过于盲目而被诈骗，当然国家也大力支持区块链技术的发展。但是区块链方面还是有许多的安全性问题尚未解决，区块链因为其匿名性以及去中心化的特性，让用户更加的自由，但是这也带来一系列的问题。如何保留着区块链的特性的前提下让其亦能够健康的发展是一个难题，不过相信随着研究的更加深入，对于区块链骗局与欺诈将会有更多有效的方法来检测与约束，同时对于市场操纵现象也会有相应合理的管控，使得区块链技术得以更加健康的发展。</p><p>参考文献：<br><sup><a href="#fn_1" id="reffn_1">1</a></sup>: Market Manipulation of Bitcoin: Evidence from Mining the Mt. Gox Transaction Network<br><sup><a href="#fn_2" id="reffn_2">2</a></sup>: Detecting Ponzi Schemes on Ethereum: Towards Healthier BlockchainTechnology<br><sup><a href="#fn_3" id="reffn_3">3</a></sup>: Understanding Ethereum via Graph Analysis</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 区块链发展与现状&lt;br&gt;date: 2019-01-04 22:21:31&lt;br&gt;tags: 区块链&lt;/p&gt;
&lt;h2 id=&quot;categories-区块链&quot;&gt;&lt;a href=&quot;#categories-区块链&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DApp开发遇到问题以及解决</title>
    <link href="http://yoursite.com/2018/12/24/DApp%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/12/24/DApp开发遇到问题以及解决/</id>
    <published>2018-12-24T11:19:30.000Z</published>
    <updated>2018-12-26T04:40:19.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次博客简单记录下开发DApp过程中遇到的一些问题，以及相应的解决方案，因此写的也是很随意，仅供参考</p><blockquote><p><a href="https://github.com/Liu-YT/public-comment" target="_blank" rel="noopener">项目地址</a></p></blockquote><h1 id="Vue如何使用Web3"><a href="#Vue如何使用Web3" class="headerlink" title="Vue如何使用Web3"></a>Vue如何使用Web3</h1><ul><li><p>安装<code>Web3</code>的依赖</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3@^0.20.0 --save</span><br></pre></td></tr></table></figure></li><li><p>项目里创建全局<code>web3</code>对象</p><ul><li><p>写一个插件，例如命名为<code>Web3.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Web3 <span class="keyword">from</span> <span class="string">"web3"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    install: <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> web3 = <span class="built_in">window</span>.web3</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            web3 = <span class="keyword">new</span> Web3(web3.currentProvider)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:8545'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        Vue.prototype.$web3 = web3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>main.js</code>里启用该插件，以后就可以这样使用<code>this.$web3</code>这个全局对象了</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Web3)</span><br></pre></td></tr></table></figure></li><li><p>例子</p><ul><li>获得第一个区块的信息  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得第一个区块的信息</span></span><br><span class="line"><span class="keyword">this</span>.$web3.eth.getBlock(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在控制台输出相应信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$web3.eth.getBlock(<span class="number">0</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>参考链接 - <a href="https://segmentfault.com/a/1190000014497742" target="_blank" rel="noopener">基于Vue、web3的以太坊项目开发及交易内幕初探</a></p></li></ul><h1 id="创建账号失败问题"><a href="#创建账号失败问题" class="headerlink" title="创建账号失败问题"></a>创建账号失败问题</h1><blockquote><p>此处Web3.js 1.0与0.2的API混用了，没有搞清楚不同版本的区别</p></blockquote><ul><li><p>创建用户写法</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">this</span>.$web3.eth.personal.newAccount(<span class="string">'sysu'</span>,(err, accounts) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(accounts, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>报错</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &apos;newAccount&apos; of undefined at &lt;anonymous&gt;:1:19</span><br></pre></td></tr></table></figure><p>  控制台再次尝试同样结果，内心崩溃<br>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccountError1.png" alt="newAccount"></p></li><li><p>搜寻许久，发现<code>web3</code>下面使用创建用户的模式应该为</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$web3.personal.newAccount(<span class="string">'sysu'</span>, (err, addr) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  即<code>personal</code>不是在<code>eth</code>命名空间下，与在<code>geth</code>中的控制台使用有所区别</p></li><li><p>问题仍然没有解决，还是报错了</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The method personal_newAccount does not exist/is not available] undefine</span><br></pre></td></tr></table></figure><p>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccountError2.png" alt="newAccount"></p></li><li><p>继续查找解决方案</p><blockquote><p>Are you running with code from the Geth console or from an external JavaScript environment? If you connect an external environment to Geth via the HTTP-RPC interface, by default the personal namespace is not available due to security considerations.</p></blockquote><p>发现问题所在，默认情况下，<code>personal</code>由于安全考虑，命名空间不可用</p></li><li><p>解决方案</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Run your node with --rpc and --rpcapi personal,web3 flags.</span><br><span class="line">i.e. geth --dev --rpcapi personal,web3,eth --rpc</span><br><span class="line">You may need to add --rpccorsdomain &quot;&lt;your-domain&gt;&quot;, in case you are using web3 in the web.</span><br><span class="line">geth --dev --rpcapi personal,web3,eth --rpccorsdomain &quot;your-domain&quot;</span><br></pre></td></tr></table></figure><p>  参照dalao的提示，使用<code>geth</code>启动私有链的时候需要加入<code>--rpcapi personal,web3,eth</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr YOUR_IP -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure><p>  然后再次测试<br>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccount.png" alt="newAccount"></p></li><li>参考链接 - <a href="https://github.com/ethereum/go-ethereum/issues/2723#event-698940135" target="_blank" rel="noopener">personal_newAccount does not exist/is not available</a></li></ul><h1 id="Web3-js-0-2XX版本-与-Web3-js-1-0版本"><a href="#Web3-js-0-2XX版本-与-Web3-js-1-0版本" class="headerlink" title="Web3.js 0.2XX版本 与 Web3.js 1.0版本"></a>Web3.js 0.2XX版本 与 Web3.js 1.0版本</h1><ul><li><a href="https://web3.learnblockchain.cn/0.2x.x/" target="_blank" rel="noopener">Web3.js 0.2x.x API 中文版手册</a></li><li><a href="http://cw.hubwiz.com/card/c/web3.js-1.0/1/1/1/" target="_blank" rel="noopener">Web3.js 1.0 中文手册</a> </li><li>二者关于<code>API</code>的使用有较多的区别，不能混用。个人后面发现<code>Web3.js 1.0</code>更加好用，然后就果断上车了</li></ul><h1 id="Remix连接私有链出现的问题"><a href="#Remix连接私有链出现的问题" class="headerlink" title="Remix连接私有链出现的问题"></a>Remix连接私有链出现的问题</h1><h2 id="问题1-Not-possible-to-connect-to-the-Web3-provider"><a href="#问题1-Not-possible-to-connect-to-the-Web3-provider" class="headerlink" title="问题1: Not possible to connect to the Web3 provider"></a>问题1: Not possible to connect to the Web3 provider</h2><p>Not possible to connect to the Web3 provider. Make sure the provider is running and a connection is open (via IPC or RPC).<br>    <img src="/2018/12/24/DApp开发遇到问题以及解决/remixE0.png" alt="remix"><br>错误原因： 在使用<code>geth</code>启动私有链结点的时候没有<code>--rpc</code><br>解决:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth,net --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr 127.0.0.1 -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure></p><pre><code>加入以后可以正常连接了</code></pre><h2 id="问题2-成功连接后显示can-39-t-detect-network"><a href="#问题2-成功连接后显示can-39-t-detect-network" class="headerlink" title="问题2: 成功连接后显示can&#39;t detect network"></a>问题2: 成功连接后显示<code>can&#39;t detect network</code></h2><p><img src="/2018/12/24/DApp开发遇到问题以及解决/remixE1.png" alt="remix"><br>错误原因： 在使用<code>geth</code>启动私有链结点的时候没有zding开启<code>net</code><br>解决:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth,net --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr 127.0.0.1 -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本次博客简单记录下开发DApp过程中遇到的一些问题，以及相应的解决方案，因此写的也是很随意，仅供参考&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Capacitated Facility Location Problem</title>
    <link href="http://yoursite.com/2018/12/22/Capacitated-Facility-Location-Problem/"/>
    <id>http://yoursite.com/2018/12/22/Capacitated-Facility-Location-Problem/</id>
    <published>2018-12-22T13:24:46.000Z</published>
    <updated>2018-12-22T17:53:49.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/Liu-YT/CFL-Problem" target="_blank" rel="noopener">项目地址</a></p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Suppose there are n facilities and m customers. We wish to choose: </p><ul><li>which of the n facilities to open </li><li>the assignment of customers to facilities </li></ul><p>The objective is to minimize the sum of the opening cost and the assignment cost. </p><p><strong>The total demand assigned to a facility must not exceed its capacity.</strong> </p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>该问题阐述的比较明确，目前有<code>n</code>个设备，每个设备开启需要一个固定的费用，然后又有<code>m</code>个顾客，每个顾客有一定的需求，但是每个设备能够提供的资源是有限的，并且每个顾客使用相应的设备的时候还需要提供一笔附加的费用，此处还有一个前提条件是一个顾客所有需求只能被一个设备处理。目前的问题是，如何给顾客分配设备，使得最后总费用最小。</p><p>这是一个<code>NP-hard</code>的问题，给出一种分配方式，我们可以比较容易的确定其是否可行，但是如果想要找到一个最理想的分配方案，则是非常的难的，我们只能尽可能的找到一个比较理想的解。最近在用<code>模拟退火(SA)</code>与<code>遗传算法(GA)</code>解决另一个比较经典的问题-<code>TSP</code>问题，所以本次也就优先想到使用这两种算法来搜索得到一个比较理想的解，但是这些<strong>最终解都是当前解里面最优的，为相应算法中的最优解，并非全局最优</strong> 。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><blockquote><p>关于<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/355508?fr=aladdin" target="_blank" rel="noopener">模拟退火算法</a>以及<a href="https://baike.baidu.com/item/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/838140?fr=aladdin" target="_blank" rel="noopener">遗传算法</a>的具体流程就不再详细，都是比较经典的算法，接下来主要讲讲与问题相关联的核心部分思路与实现</p></blockquote><h2 id="模拟退火-SA"><a href="#模拟退火-SA" class="headerlink" title="模拟退火 (SA)"></a>模拟退火 (SA)</h2><blockquote><p>模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。</p></blockquote><p>在本次算法设计中，比较关键的点在于搜索中<strong>领域操作</strong>的设计上，领域操作影响着最终结果的好坏，通过邻域动作。产生初始解的邻居解，然后根据某种策略选择邻居解。一直重复以上过程，直到达到终止条件。对于本次场景而言，对于产生的解，只要是新解所需要的费用小于目前的费用，则直接选择该接。而对于一些比当前的解要差的解，以一定的概率接受，采纳的概率为:</p><script type="math/tex; mode=display">P_k = e^{(-\Delta E_k) / T}</script><p>本次模拟退火算法设计中，所设计的领域操作位<strong>在用户序列中随机选择两个位置，对于在此之间的用户为其重新随机选择一次所选择的设备，如果随机到的设备所能提供的容量不满足，则再次随机选择设备，直到选择到合适的为止</strong>，该领域操作尽可能的涉及到了各种可能的分配方案，尽可能的扰动当前结果以及概率接受差解，使其可能跳出局部最优解，已得到比较理想的解。</p><p><a href="https://github.com/Liu-YT/CFL-Problem/blob/master/src/SA.hpp" target="_blank" rel="noopener">模拟退火算法主要核心代码</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟退火</span></span><br><span class="line"><span class="keyword">while</span>(T &gt; <span class="number">0.01</span>) &#123;</span><br><span class="line">    <span class="comment">/* 扰动获得寻找较优解，并且可能接收差解 */</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; SEARCHTIMES) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = rand() % (p-&gt;numOfCus);</span><br><span class="line">        <span class="keyword">int</span> second = rand() % (p-&gt;numOfCus - first) + first;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newCusToFac = cusToFac;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newFreeCapacity = freeCapacity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = first; j &lt;= second; ++j)</span><br><span class="line">            newFreeCapacity[newCusToFac[j]] += p-&gt;cusDemand[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机分配一个新的工厂</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = first; j &lt;= second; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;cusDemand[j] &gt; newFreeCapacity[newFac])</span><br><span class="line">                newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            newCusToFac[j] = newFac;</span><br><span class="line">            newFreeCapacity[newFac] -= p-&gt;cusDemand[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cost = calCost(p, newCusToFac, newFreeCapacity);</span><br><span class="line">        <span class="keyword">double</span> probability = (rand() % <span class="number">100</span>) * <span class="number">1.0</span> / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前解，一定概率接受</span></span><br><span class="line">        <span class="keyword">if</span> (cost &lt;= totalCost || probability &lt; <span class="built_in">exp</span>(-<span class="built_in">abs</span>(cost-totalCost) / T)) &#123;</span><br><span class="line">            cusToFac = newCusToFac;</span><br><span class="line">            freeCapacity = newFreeCapacity;</span><br><span class="line">            totalCost = cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 降温</span></span><br><span class="line">    T *= alpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>SEARCHTIMES</code>，局部搜索的次数设置也比较关键，搜索次数也影响着结果的好坏，如果次数太少则可能造成遗漏比较多，而次数设置的比较大的话，对于数据量比较小的情况将造成算力浪费。因此考虑到可能出现的随机情况$C^2_n$，因此对于不同问题，动态设置局部搜索的次数为<code>SEARCHTIMES = n * (n-1) / 2</code>，但是其实还是很耗时，但是效果还可以。</p><h2 id="遗传算法-GA"><a href="#遗传算法-GA" class="headerlink" title="遗传算法 (GA)"></a>遗传算法 (GA)</h2><blockquote><p>关于遗传算法解决，其实个人认为普通的遗传算法效率并不高，并且如果没有针对问题有一定的设计的话，很难达到比较好的状态。</p></blockquote><p>首先需要大概的了解遗传算法的主要流程<br><img src="/2018/12/22/Capacitated-Facility-Location-Problem/GA.png" alt="GA"></p><p><code>Code</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化种群</span></span><br><span class="line">initPopulation(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟遗传</span></span><br><span class="line"><span class="keyword">int</span> curGen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(curGen &lt; MAXGEN) &#123;</span><br><span class="line">    <span class="comment">// 选择</span></span><br><span class="line">    select(p);</span><br><span class="line">    <span class="comment">// 交叉</span></span><br><span class="line">    crosscover(p);</span><br><span class="line">    <span class="comment">// 变异</span></span><br><span class="line">    mutate(p);</span><br><span class="line">    ++curGen; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>适应度评估</strong>，其适应度等于该方案费用<code>cost</code>的倒数，即<code>1 / cost</code></p><hr><p>关于<strong>选择</strong>，使用比较通用的<a href="https://www.cnblogs.com/legend1130/archive/2016/03/29/5333087.html" target="_blank" rel="noopener">轮盘赌</a>，同时选择其他的选择策略的效果也是不错的</p><hr><p>关于<strong>种群初始化</strong>，其实默认是比较容易的，即随机生成种群即可，但是实验起来发现随机生成初始种群，其收敛效果很差并且效率很低。因此<strong>在初始化种群的时候加入部分贪心生成的个体</strong>，加快种群成熟速度，也保证了种群中个体的多样性。关于贪心生成个体的思路也比较简单，打乱顾客挑选设备的顺序，每次未顾客挑选当前所需要费用最小的设备。但是关于贪心生成的较优个体的占额也需要注意，如果占的比列比较大，可能会导致过早收敛，出现早熟现象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化种群</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPopulation</span><span class="params">(problem* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为提高效率，初始时候通过贪心加入一部分较优个体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        individual* ind = <span class="keyword">new</span> individual(p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> fac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;cusDemand[j] &gt; ind-&gt;freeCapacity[fac])</span><br><span class="line">                fac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            ind-&gt;freeCapacity[fac] -= p-&gt;cusDemand[j];</span><br><span class="line">            ind-&gt;cusToFac[j] = fac;</span><br><span class="line">        &#125; </span><br><span class="line">        evalute(p, ind);</span><br><span class="line">        population.push_back(ind);      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贪心生成解</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;numOfCus; ++i) temp.push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        individual *ind = <span class="keyword">new</span> individual(p);</span><br><span class="line">        random_shuffle(temp.begin(), temp.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mixCost = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p-&gt;numOfFac; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;cusDemand[temp[j]] &lt;= ind-&gt;freeCapacity[k] &amp;&amp; mixCost &gt;= p-&gt;useCost[temp[j]][k]) &#123;</span><br><span class="line">                    mixCost = p-&gt;useCost[temp[j]][k];</span><br><span class="line">                    ind-&gt;freeCapacity[k] -= p-&gt;cusDemand[temp[j]];</span><br><span class="line">                    ind-&gt;cusToFac[temp[j]] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        evalute(p, ind);</span><br><span class="line">        population.push_back(ind);</span><br><span class="line">    &#125;</span><br><span class="line">    random_shuffle(population.begin(), population.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>交叉操作</strong>，第<code>n</code>条染色体与第<code>n+1</code>条染色体有一定的概率进行交叉<code>(n = 0, 2, 4, ..., 2n)</code>。这部分使用<strong>两点交叉</strong></p><blockquote><p>两点交叉（Two-point Crossover）：在个体编码串中随机设置了两个交叉点，然后再进行部分基因交换</p></blockquote><p>但是交叉后的结果可能是不可行的方案，我们需要判断一下交叉后的解是否可行，然后再进行一定的策略操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crosscover</span><span class="params">(problem* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两点交叉 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;individual*&gt; subPopulation;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rand() % <span class="number">100</span>) * <span class="number">1.0</span> / <span class="number">100</span> &lt;= PXOVER) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count++ &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                individual *a = <span class="keyword">new</span> individual(population[i*<span class="number">2</span>]);</span><br><span class="line">                individual *b = <span class="keyword">new</span> individual(population[i*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> geneFirst = rand() % (p-&gt;numOfCus);</span><br><span class="line">                <span class="keyword">int</span> geneSecond = rand() % (p-&gt;numOfCus - geneFirst) + geneFirst;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = geneFirst; k &lt;= geneSecond; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a-&gt;cusToFac[k];</span><br><span class="line">                    a-&gt;cusToFac[k] = b-&gt;cusToFac[k];</span><br><span class="line">                    b-&gt;cusToFac[k] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (validCover(p, a) &amp;&amp; validCover(p, b)) &#123;</span><br><span class="line">                    evalute(p, a);</span><br><span class="line">                    evalute(p, b);</span><br><span class="line">                    subPopulation.push_back(a);</span><br><span class="line">                    subPopulation.push_back(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(subPopulation.begin(), subPopulation.end(), [&amp;](<span class="keyword">const</span> individual* a, <span class="keyword">const</span> individual* b) -&gt; <span class="keyword">bool</span>&#123; <span class="keyword">return</span> a-&gt;cost &lt; b-&gt;cost;&#125;);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subPopulation.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; POSIZE; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(population[j]-&gt;cost &gt; subPopulation[i]-&gt;cost) &#123;</span><br><span class="line">                individual* temp = population[j];</span><br><span class="line">                population[j] = subPopulation[i];</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num; i &lt; subPopulation.size(); ++i)</span><br><span class="line">        <span class="keyword">delete</span> subPopulation[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>变异</strong>，使用最基本的基因变异的原理，种群中每个个体的每个顾客看作一个基因，基因突变则看成为该顾客重新选择一个对应的可用的设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 变异</span><br><span class="line">void mutate(problem* p) &#123;</span><br><span class="line">    for(int i = 0; i &lt; POSIZE; ++i) &#123;</span><br><span class="line">        double pro = (rand() % 100) * 1.0 / 100;</span><br><span class="line">        if(pro &lt;= PMUTATION) &#123;</span><br><span class="line">            for(int j = 0; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">                int newFac = rand() % p-&gt;numOfFac;</span><br><span class="line">                population[i]-&gt;freeCapacity[population[i]-&gt;cusToFac[j]] += p-&gt;cusDemand[j];</span><br><span class="line">                while (p-&gt;cusDemand[j] &gt; population[i]-&gt;freeCapacity[newFac])</span><br><span class="line">                    newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">                population[i]-&gt;freeCapacity[newFac] -= p-&gt;cusDemand[j];</span><br><span class="line">                population[i]-&gt;cusToFac[j] = newFac;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><blockquote><p><a href="https://github.com/Liu-YT/CFL-Problem/tree/master/result/csv" target="_blank" rel="noopener">完整结果</a></p></blockquote><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><div class="table-container"><table><thead><tr><th>Problem</th><th>Result</th><th>Time(s)</th></tr></thead><tbody><tr><td>p1</td><td>9075</td><td>0.729</td></tr><tr><td>p2</td><td>8315</td><td>0.685</td></tr><tr><td>p3</td><td>10076</td><td>0.684</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>p68</td><td>26452</td><td>51.886</td></tr><tr><td>p69</td><td>35383</td><td>54.413</td></tr><tr><td>p70</td><td>50826</td><td>51.292</td></tr><tr><td>p71</td><td>39417</td><td>51.519</td></tr></tbody></table></div><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><div class="table-container"><table><thead><tr><th>Problem</th><th>Result</th><th>Time(s)</th></tr></thead><tbody><tr><td>p1</td><td>10220</td><td>10.727</td></tr><tr><td>p2</td><td>9493</td><td>11.888</td></tr><tr><td>p3</td><td>11653</td><td>10.831</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>p68</td><td>33324</td><td>43.275</td></tr><tr><td>p69</td><td>38309</td><td>44.419</td></tr><tr><td>p70</td><td>59304</td><td>38.904</td></tr><tr><td>p71</td><td>46541</td><td>37.729</td></tr></tbody></table></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从结果的运行时间可用比较直观的看出两个算法对于数据量比较大的时候都比较费时，可以控制时间但是会导致解的变差，增大运算此时解可能会更加好，但是时间太长，难以接受</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Liu-YT/CFL-Problem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="NP-hard" scheme="http://yoursite.com/tags/NP-hard/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 6 BoltDB学习与简单剖析</title>
    <link href="http://yoursite.com/2018/12/14/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-6-BoltDB%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/14/服务计算-6-BoltDB学习与简单剖析/</id>
    <published>2018-12-14T07:29:51.000Z</published>
    <updated>2018-12-14T13:08:54.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BoltDB-介绍"><a href="#BoltDB-介绍" class="headerlink" title="BoltDB 介绍"></a>BoltDB 介绍</h1><blockquote><p>Bolt is a pure Go key/value store inspired by Howard Chu’s LMDB project. The goal of the project is to provide a simple, fast, and reliable database for projects that don’t require a full database server such as Postgres or MySQL.<br>Since Bolt is meant to be used as such a low-level piece of functionality, simplicity is key. The API will be small and only focus on getting values and setting values. That’s it.</p></blockquote><p><code>BoltDB</code>是一个嵌入式<code>key/value</code>的数据库，即只需要将其链接到你的应用程序代码中即可使用<code>BoltDB</code>提供的<code>API</code>来高效的存取数据。而且<code>BoltDB</code>支持完全可序列化的<code>ACID事务</code>，让应用程序可以更简单的处理复杂操作</p><h1 id="BoltDB-使用"><a href="#BoltDB-使用" class="headerlink" title="BoltDB 使用"></a>BoltDB 使用</h1><p><strong><code>BoltDB</code>使用<code>Golang</code>开发</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/boltdb/bolt</span></span><br></pre></td></tr></table></figure><h2 id="创建和启动数据库"><a href="#创建和启动数据库" class="headerlink" title="创建和启动数据库"></a>创建和启动数据库</h2><p>使用<code>bolt.Open()</code>函数进行创建或者打开数据库<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := bolt.Open(<span class="string">"data.db"</span>, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p>该命令将打开当前目录下<code>data.db</code>文件，<strong>如果该文件不存在，则将被创建</strong>。</p><p><code>Open</code>方法三个参数</p><ul><li>第一个参数为路径，指定需要打开的数据库，不存在将会被创建</li><li>第二个参数为文件操作权限</li><li>第三个参数为可选参数，内部可以配置只读和超时等</li></ul><p><code>BoltDB</code>是文件操作类型的数据库，打开数据库后将有一个文件锁，不允许多个进程同时打开同一个数据库。如果多个同时操作的话后者会被挂起直到前者关闭操作为止，为了避免无限等待，在打开数据库的时候可以配置超时时间<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := bolt.Open(<span class="string">"my.db"</span>, <span class="number">0600</span>, &amp;bolt.Options&#123;Timeout: <span class="number">1</span> * time.Second&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="读写事务"><a href="#读写事务" class="headerlink" title="读写事务"></a>读写事务</h2><p>对于读写事务，可以使用<code>DB.Update</code>来完成<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>DB.Update</code>方法可以对数据库进行读写操作。在闭包内部，可以获得数据库的一致视图。 在结尾返回<code>nil</code>来提交事务，也可以通过返回错误随时回滚事务。 读写事务中允许所有数据库操作，始终检查返回错误，因为它将报告可能导致您的事务无法完成的任何磁盘故障。 如果您在关闭中返回错误，它将被传递。</p><ul><li><p><strong>Example</strong><br>  需要注意在读写事务以及只读事务中，如果没有相应的<code>Bucket</code>，是不能直接对其进行操作的，必须先创建</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create bucket</span></span><br><span class="line">db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := tx.CreateBucketIfNotExists([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    CheckErr(err)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  往<code>peopleBucket</code>桶中插入一个<code>People</code>，其<code>key</code>值为其ID，<code>value</code>为People的序列化后的字符串</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it = model.People&#123;&#125;</span><br><span class="line">it.ID = <span class="string">"1"</span></span><br><span class="line">db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    b := tx.Bucket([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    jsons, errs := json.Marshal(it)</span><br><span class="line">    CheckErr(errs)</span><br><span class="line">    err := b.Put([]<span class="keyword">byte</span>(it.ID), jsons)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h2><p>对于只读事务，使用<code>DB.View</code>来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.View(func(tx *bolt.Tx) error &#123;</span><br><span class="line">    ...</span><br><span class="line">    return nil</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在此闭包中获得数据库的一致视图，但是，只读事务中不允许进行变更操作。 只能在只读事务中检索存储桶，检索值和复制数据库。需要注意的是读写事务和只读事务不应该在同一个<code>goroutine</code>里同时打开，这是由于读写事务需要周期性重新映射数据文件，与只读事务发生冲突，可能造成死锁。<code>BoltDB</code>一次只允许一个读写事务，单一次允许多个只读事务，保持数据一致性。</p><ul><li><strong>Example</strong><br>  获取<code>peopleBucket</code>桶中<code>key</code>值为<code>&quot;1&quot;</code>的<code>value</code>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    b := tx.Bucket([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    v := b.Get([]<span class="keyword">byte</span>(<span class="string">"1"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, v)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="批量更新事务"><a href="#批量更新事务" class="headerlink" title="批量更新事务"></a>批量更新事务</h2><p>每个<code>DB.Update()</code>等待磁盘提交写入。 通过将多个更新与<code>DB.Batch()</code>函数组合，可以最大限度地减少此开销<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.Batch(func(tx *bolt.Tx) error &#123;</span><br><span class="line">    ...</span><br><span class="line">    return nil</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在整个批处理的过程中，如果某个事务失败了，批处理将会多次调用给定的函数。函数只有在<code>DB.Batch</code>返回成功才表示成功完成。如果批处理中途失败了，整个事务将会回滚。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更多详细的用法请参考 <a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">boltdb/bolt</a></p><h1 id="BoltDB-源码简单剖析"><a href="#BoltDB-源码简单剖析" class="headerlink" title="BoltDB 源码简单剖析"></a>BoltDB 源码简单剖析</h1><p>关于源码部分，纯属一些个人的理解以及网上相关一些讲解，对于某些部分可能理解不是很到位，还望多多指正，源码部分设计到比较底层具体文件存储部分感觉还是很难理解的，此部分只是简单的摸索一下其中的机制与一些方法的执行过程</p><p>首先先探索一下一开始启动数据库中其是设置文件锁<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock file so that other processes using Bolt in read-write mode cannot</span></span><br><span class="line"><span class="comment">// use the database  at the same time. This would cause corruption since</span></span><br><span class="line"><span class="comment">// the two processes would write meta pages and free pages separately.</span></span><br><span class="line"><span class="comment">// The database file is locked exclusively (only one process can grab the lock)</span></span><br><span class="line"><span class="comment">// if !options.ReadOnly.</span></span><br><span class="line"><span class="comment">// The database file is locked using the shared lock (more than one process may</span></span><br><span class="line"><span class="comment">// hold a lock at the same time) otherwise (options.ReadOnly is set).</span></span><br><span class="line"><span class="keyword">if</span> err := flock(db, mode, !db.readOnly, options.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    _ = db.<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>呃其实这部分注释已经解释的很明确了，但是还是看看这个<code>flock</code>函数吧<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flock acquires an advisory lock on a file descriptor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flock</span><span class="params">(db *DB, mode os.FileMode, exclusive <span class="keyword">bool</span>, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t time.Time</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// If we're beyond our timeout then return an error.</span></span><br><span class="line"><span class="comment">// This can only occur after we've attempted a flock once.</span></span><br><span class="line"><span class="keyword">if</span> t.IsZero() &#123;</span><br><span class="line">t = time.Now()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> timeout &gt; <span class="number">0</span> &amp;&amp; time.Since(t) &gt; timeout &#123;</span><br><span class="line"><span class="keyword">return</span> ErrTimeout</span><br><span class="line">&#125;</span><br><span class="line">flag := syscall.LOCK_SH</span><br><span class="line"><span class="keyword">if</span> exclusive &#123;</span><br><span class="line">flag = syscall.LOCK_EX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise attempt to obtain an exclusive lock.</span></span><br><span class="line">err := syscall.Flock(<span class="keyword">int</span>(db.file.Fd()), flag|syscall.LOCK_NB)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != syscall.EWOULDBLOCK &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for a bit and try again.</span></span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来其一开始先定义一个变量，用一个死循环在运行这段代码，如果在设置的<code>timeout</code>时间段内仍然得不到这个文件的锁，则将返回一个超时错误，如果没有设置<code>timeout</code>，则其将一直等待，直到获得该文件的锁，即获得该文件的使用权，其实这与操作系统中的进程同步异步使用一个互斥锁的机制是相似的。接着再来看看其对于未创建过的数据库是如何创建的以及如何对其初始化<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the database if it doesn't exist.</span></span><br><span class="line"><span class="keyword">if</span> info, err := db.file.Stat(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> info.Size() == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize new files with meta pages.</span></span><br><span class="line">    <span class="keyword">if</span> err := db.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Read the first meta page to determine the page size.</span></span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">0x1000</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">if</span> _, err := db.file.ReadAt(buf[:], <span class="number">0</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        m := db.pageInBuffer(buf[:], <span class="number">0</span>).meta()</span><br><span class="line">        <span class="keyword">if</span> err := m.validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// If we can't read the page size, we can assume it's the same</span></span><br><span class="line">            <span class="comment">// as the OS -- since that's how the page size was chosen in the</span></span><br><span class="line">            <span class="comment">// first place.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// If the first page is invalid and this OS uses a different</span></span><br><span class="line">            <span class="comment">// page size than what the database was created with then we</span></span><br><span class="line">            <span class="comment">// are out of luck and cannot access the database.</span></span><br><span class="line">            db.pageSize = os.Getpagesize()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            db.pageSize = <span class="keyword">int</span>(m.pageSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其首先先对文件是否存在以及文件的类型进行判断，调用<code>db.file.Stat</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stat returns the FileInfo structure describing file.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Stat</span><span class="params">()</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> file == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalid</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> file.isdir() &#123;</span><br><span class="line">        <span class="comment">// I don't know any better way to do that for directory</span></span><br><span class="line">        <span class="keyword">return</span> Stat(file.dirinfo.path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isNulName(file.name) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;devNullStat, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ft, err := file.pfd.GetFileType()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">"GetFileType"</span>, file.name, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> ft &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.FILE_TYPE_PIPE, syscall.FILE_TYPE_CHAR:</span><br><span class="line">        <span class="keyword">return</span> &amp;fileStat&#123;name: basename(file.name), filetype: ft&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs, err := newFileStatFromGetFileInformationByHandle(file.name, file.pfd.Sysfd)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    fs.filetype = ft</span><br><span class="line">    <span class="keyword">return</span> fs, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断其实也是比较简单的吧，还是接着看其是如何初始化一个新的数据库<code>db.init()</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init creates a new database file and initializes its meta pages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">init</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Set the page size to the OS page size.</span></span><br><span class="line">db.pageSize = os.Getpagesize()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create two meta pages on a buffer.</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, db.pageSize*<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">p := db.pageInBuffer(buf[:], pgid(i))</span><br><span class="line">p.id = pgid(i)</span><br><span class="line">p.flags = metaPageFlag</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the meta page.</span></span><br><span class="line">m := p.meta()</span><br><span class="line">m.magic = magic</span><br><span class="line">m.version = version</span><br><span class="line">m.pageSize = <span class="keyword">uint32</span>(db.pageSize)</span><br><span class="line">m.freelist = <span class="number">2</span></span><br><span class="line">m.root = bucket&#123;root: <span class="number">3</span>&#125;</span><br><span class="line">m.pgid = <span class="number">4</span></span><br><span class="line">m.txid = txid(i)</span><br><span class="line">m.checksum = m.sum64()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write an empty freelist at page 3.</span></span><br><span class="line">p := db.pageInBuffer(buf[:], pgid(<span class="number">2</span>))</span><br><span class="line">p.id = pgid(<span class="number">2</span>)</span><br><span class="line">p.flags = freelistPageFlag</span><br><span class="line">p.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write an empty leaf page at page 4.</span></span><br><span class="line">p = db.pageInBuffer(buf[:], pgid(<span class="number">3</span>))</span><br><span class="line">p.id = pgid(<span class="number">3</span>)</span><br><span class="line">p.flags = leafPageFlag</span><br><span class="line">p.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the buffer to our data file.</span></span><br><span class="line"><span class="keyword">if</span> _, err := db.ops.writeAt(buf, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fdatasync(db); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这感觉还是能明白在干嘛的，其采用单个文件来将数据存储在磁盘上，该文件的前4个<code>page</code>是固定的，分别是 <code>meta page</code>、<code>meta page</code>、<code>freelist</code>、<code>leaf page</code>，但是对于这4个<code>page</code>，到底是什么就让人很头大了。先看<code>meta page</code>的定义<code>p.meta()</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// meta returns a pointer to the metadata section of the page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *page)</span> <span class="title">meta</span><span class="params">()</span> *<span class="title">meta</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (*meta)(unsafe.Pointer(&amp;p.ptr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还是先看看其基础的<code>page</code>的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> page <span class="keyword">struct</span> &#123;</span><br><span class="line">    id       pgid</span><br><span class="line">    flags    <span class="keyword">uint16</span></span><br><span class="line">    count    <span class="keyword">uint16</span></span><br><span class="line">    overflow <span class="keyword">uint32</span></span><br><span class="line">    ptr      <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>page</code>是<code>boltdb</code>持久化时，与磁盘相关的数据结构。<code>page</code>的大小采用操作系统内存页的大小，即<code>getpagesize</code>系统调用的返回值。<code>id</code>为<code>page</code>的序号，<code>flags</code>表示<code>page</code>的类型，有<code>branchPageFlag/leafPageFlag/metaPageFlag/freelistPageFlag</code>几种，<code>count</code>当<code>page</code>是<code>freelistPageFlag</code>类型时，存储的是<code>freelist</code>中<code>pgid</code>数组中元素的个数;当<code>page</code>时其他类型时，存储的是<code>inode</code>的个数，<code>overflow</code>记录<code>page</code>中数据量超过一个<code>page</code>所能存储的大小时候需要额外的<code>page</code>的数目<br>每个page对应对应一个磁盘上的数据块。这个数据块的layout为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| page struct data | page element items | k-v pairs |</span><br></pre></td></tr></table></figure></p><p>其分为3个部分：</p><ul><li>第一部分<code>page struct data</code>是该<code>page</code>的<code>header</code>，存储的就是<code>pagestruct</code>的数据。</li><li>第二部分<code>page element items</code>其实就是<code>node</code>的里<code>inode</code>的持久化部分数据。</li><li>第三部分<code>k-v pairs</code>存储的是<code>inode</code>里具体的<code>key-value</code>数据。</li></ul></blockquote><p>接着就可以探索一下<code>meta page</code>是什么玩意了<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> meta <span class="keyword">struct</span> &#123;</span><br><span class="line">    magic    <span class="keyword">uint32</span>  <span class="comment">// 存储魔数0xED0CDAED</span></span><br><span class="line">    version  <span class="keyword">uint32</span>  <span class="comment">// 标明存储格式的版本，现在是2</span></span><br><span class="line">    pageSize <span class="keyword">uint32</span>  <span class="comment">// 标明每个page的大小</span></span><br><span class="line">    flags    <span class="keyword">uint32</span>  <span class="comment">// 当前已无用</span></span><br><span class="line">    root     bucket  <span class="comment">// 根Bucket</span></span><br><span class="line">    freelist pgid    <span class="comment">// 标明当前freelist数据存在哪个page中</span></span><br><span class="line">    pgid     pgid    <span class="comment">//</span></span><br><span class="line">    txid     txid    <span class="comment">//</span></span><br><span class="line">    checksum <span class="keyword">uint64</span>  <span class="comment">// 以上数据的校验和，校验数据是否损坏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着再看看<code>freelist</code>是什么，关于<code>freelist</code>的定义需要一层层不断找，比较繁琐<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// freelist represents a list of all pages that are available for allocation.</span></span><br><span class="line"><span class="comment">// It also tracks pages that have been freed but are still in use by open transactions.</span></span><br><span class="line"><span class="keyword">type</span> freelist <span class="keyword">struct</span> &#123;</span><br><span class="line">ids     []pgid          <span class="comment">// all free and available free page ids.</span></span><br><span class="line">pending <span class="keyword">map</span>[txid][]pgid <span class="comment">// mapping of soon-to-be free page ids by tx.</span></span><br><span class="line">cache   <span class="keyword">map</span>[pgid]<span class="keyword">bool</span>   <span class="comment">// fast lookup of all free and pending page ids.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>依赖注释我们已经可以大概猜测出<code>freelist</code>的作用，其是<code>BoltDb</code>实现磁盘空间的重复利用机制中需要用到的文件<code>page</code>缓存</p><blockquote><p><code>ids</code>记录了当前缓存着的空闲<code>page</code>的<code>pgid</code>，<code>cache</code>中记录的也是这些<code>pgid</code>，采用<code>map</code>记录 方便快速查找。</p><p>当用户需要<code>page</code>时，调用<code>freelist.allocate(n int) pgid</code>，其中n为需要的<code>page</code>数量，其会遍历<code>ids</code>，从中 挑选出连续n个空闲的<code>page</code>，然后将其从缓存中剔除，然后将其实的<code>page-id</code>返回给调用者。当不存在满足需求的 page时，返回0，因为文件的起始2个page固定为meta page，因此有效的page-id不可能为0。</p><p>当某个写事务产生无用page时，将调用<code>freelist.free(txid txid, p *page)</code>将指定page p放入pending池和 cache中。当下一个写事务开启时，会将没有Tx引用的pending中的page搬移到ids缓存中。之所以这样做， 是为了支持事务的回滚和并发读事务，从而实现<code>MVCC</code>。</p><p>当发起一个读事务时，<code>Tx</code>单独复制一份<code>meta</code>信息，从这份独有的<code>meta</code>作为入口，可以读出该<code>meta</code>指向的数据， 此时即使有一个写事务修改了相关key的数据，新修改的数据只会被写入新的page，读事务持有的page会进入pending 池，因此该读事务相关的数据并不会被修改。只有该page相关的读事务都结束时，才会从pending池进入到cache池 中，从而被复用修改。</p><p>当写事务更新数据时，并不直接覆盖老数据，而且分配一个新的page将更新后的数据写入，然后将老数据占用的page 放入pending池，建立新的索引。当事务需要回滚时，只需要将pending池中的page释放，将索引回滚即完成数据的 回滚。这样加速了事务的回滚。减少了事务缓存的内存使用，同时避免了对正在读的事务的干扰。</p></blockquote><p>到这里我们也大概了解到<code>BoltDb</code>中部分的机制，说实话关于一些涉及底层方面的有点难以理解，主要关于数据库存储以及操作系统方面的知识面太浅了，之前没有好好学习，还是得先去好好看看数据库和文件系统相关以及存储相关的知识再继续尝试学习源码了吧</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">boltdb/bolt</a></li><li><a href="https://zhuanlan.zhihu.com/p/27444660" target="_blank" rel="noopener">聊聊BoltDB：简单使用</a></li><li><a href="https://studygolang.com/articles/9939" target="_blank" rel="noopener">boltdb持久化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BoltDB-介绍&quot;&gt;&lt;a href=&quot;#BoltDB-介绍&quot; class=&quot;headerlink&quot; title=&quot;BoltDB 介绍&quot;&gt;&lt;/a&gt;BoltDB 介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Bolt is a pure Go key/value s
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>132. Palindrome Partitioning II</title>
    <link href="http://yoursite.com/2018/12/06/132-Palindrome-Partitioning-II/"/>
    <id>http://yoursite.com/2018/12/06/132-Palindrome-Partitioning-II/</id>
    <published>2018-12-06T06:18:55.000Z</published>
    <updated>2018-12-06T08:03:24.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p><p><strong>Example:</strong></p><pre><strong>Input:</strong>&nbsp;"aab"<strong>Output:</strong> 1<strong>Explanation:</strong> The palindrome partitioning ["aa","b"] could be produced using 1 cut.</pre></div></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题给出一个字符串，求出将该字符串最少分割多少次可以实现其分割后的子串都是回文串</li><li>本题求解比较复杂，主要思路是先求字符串某个区间内的子串是否是回文串然后，如果是说明可以被分割，否则不能被进行分割(因为分割以后也不是回文串，需要继续被分割)</li><li>本题使用<code>isPal[i,j]</code>记录字符串在<code>[i,j]</code>是否是一个回文串，使用<code>cut[i]</code>记录字符串在区间<code>[i, size]</code>被分割后所有子串都为回文串需要被分割多少次，因此我们需要分类进行讨论，假设当前的区间为<code>[i,j]</code>    <ul><li>首先需要对区间<code>[i,j]</code>是否是一个回文串进行判断<ul><li><code>i &lt; j</code><ul><li>不满足区间的基本要求</li></ul></li><li><code>i == j</code><ul><li>显然是一个回文串，<code>isPal[i,j] = true</code></li></ul></li><li><code>j == i+1</code> <ul><li>如果<code>s[i] == s[j]</code>，则这也是回文串，即<code>isPal[i,j] = true</code>，否则不是一个回文串</li></ul></li><li><code>i+1 &lt; j</code><ul><li>这部分判断比较麻烦，我们利用动态规划的思想，如果在区间<code>[i+1,j-1]</code>的子串是一个回文串，那么如果<code>s[i] == s[j]</code>的话，则该子串也是一个回文串，即<code>isPal[i,j] = true</code>，否则的话不是</li></ul></li></ul></li><li>判断完该区间的子串是否是回文串后，我们需要对<code>cut[i]</code>进行更新。如果<code>[i,j]</code>是一个回文串(<code>isPal[i,j] == true</code>)的话，说明我们对于区间<code>[i, size)</code>有了一个新的分割方法，即在原基础上变成<code>[i, j] + [j+1, size)</code>，因此我们可以更新<code>cut[i]</code><ul><li><code>cut[i] = min(cut[i], cut[j+1] + 1)</code></li><li>此处将原区间<code>[i, j]</code>分割成<code>[i, j] + [j+1, size)</code>两部分，需要在<code>c[j+1]</code>次的基础上再加一次分割操作，即分割次数为<code>c[j+1]+1</code>，但是我们需要注意的一点是对于第一次分割即<code>[size-1, size)</code>区间操作，其实分割次数是<code>0</code>，不需要对其进行分割，但是为了写法统一还是加1，后面的操作也不断使用到本次分割，因此对于每次的<code>cut[i]</code>都比实际多了1。因此最后返回字符串最小分割次数时候，即分割区间<code>[0, size)</code>的分割次数为<code>cut[0]-1</code></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断区间[i, j]的字符是否是回文串</span></span><br><span class="line">        <span class="keyword">bool</span> isPal[s.size()][s.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录区间[i, size]需要切割的次数</span></span><br><span class="line">        <span class="keyword">int</span> cut[s.size()+<span class="number">1</span>];</span><br><span class="line">        cut[s.size()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cut[i] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.size(); ++j) &#123;</span><br><span class="line">                isPal[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == j || i+<span class="number">1</span> == j &amp;&amp; s[i] == s[j] || i+<span class="number">1</span> &lt; j &amp;&amp; isPal[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                    isPal[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    cut[i] = min(cut[i], cut[j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cut[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given a string &lt;em&gt;s&lt;/em&gt;, partition &lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>57. Insert Interval</title>
    <link href="http://yoursite.com/2018/12/06/57-Insert-Interval/"/>
    <id>http://yoursite.com/2018/12/06/57-Insert-Interval/</id>
    <published>2018-12-06T06:15:54.000Z</published>
    <updated>2018-12-06T06:52:38.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]<strong>Output:</strong> [[1,5],[6,9]]</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code><strong>Output:</strong> [[1,2],[3,10],[12,16]]<strong>Explanation:</strong> Because the new interval <code>[4,8]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</pre></div></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这道题目给出一个有序的区间集合，再给出一个新的区间，将其合并进去区间集合中，然后输出合并后的区间集合</li><li>这道题需要进行分类讨论，主要针对新的区间以及原区间集合的边界问题进行讨论。此处假设新的区间<code>newInterval</code>表现形式为<code>[newStart, newEnd]</code>，当前遍历到区间集合内的区间为<code>[start, end]</code>，此处需要注意的一点是区间集合内的区间都是已经排好序的，即当前区间<code>end</code>小于下一个区间的<code>start</code>。此处讨论主要分区间重叠的情况与不重叠两个方向进行讨论<ul><li>区间不重叠 <ul><li>区间不重叠，说明新的区间无法与当前区间进行合并，因此我们只需要考虑是否将新的区间加入集合以及将当前区间加入的问题即可</li><li><code>newEnd &lt; start</code><ul><li>此时说明新区间在当前区间的前面，但是我们需要判断新的区间是否已经加入区间集合中，如果已经加入，对新的区间无需任何操作，只需要加入当前区间即可，如果未加入，我们需要先加入新的区间（为了保证集合内区间也是排好序的），然后再加入当前区间</li></ul></li><li><code>newStart &gt; end</code><ul><li>无需考虑加入新区间问题，只需要把当前区间加入集合中即可</li></ul></li></ul></li><li>区间重叠<ul><li>当前的区间与新的区间出现重叠的情况，区间可以进行合并。我们不需要考虑是否将区间加入到集合中，因为可能与后面区间仍然可能重叠而需要合并的情况，因此只需要更新一下新的区间，等到不重叠的情况时候再考虑加入，<ul><li><code>newInterval.start = min(newInterval.start, intervals[i].start)</code></li><li><code>newInterval.end = max(newInterval.end, intervals[i].end)</code></li></ul></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; insert(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            v.push_back(newInterval);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isAdd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); ++i) &#123; </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(intervals[i].start &gt; newInterval.end) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isAdd) v.push_back(newInterval);</span><br><span class="line">                v.push_back(intervals[i]);</span><br><span class="line">                isAdd = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i].end &lt; newInterval.start) &#123;</span><br><span class="line">                v.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newInterval.start = min(newInterval.start, intervals[i].start);</span><br><span class="line">                newInterval.end = max(newInterval.end, intervals[i].end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isAdd) v.push_back(newInterval);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given a set of &lt;em&gt;non-overlapping&lt;/em
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>123. Best Time to Buy and Sell Stock III</title>
    <link href="http://yoursite.com/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/"/>
    <id>http://yoursite.com/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/</id>
    <published>2018-12-02T07:29:13.000Z</published>
    <updated>2018-12-02T08:42:07.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:&nbsp;</strong>You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> [3,3,5,0,0,3,1,4]<strong>Output:</strong> 6<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.&nbsp;            Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> [1,2,3,4,5]<strong>Output:</strong> 4<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.&nbsp;            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are&nbsp;            engaging multiple transactions at the same time. You must sell before buying again.</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> [7,6,4,3,1]<strong>Output:</strong> 0<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.</pre></div></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>本题题目意思比较简单，给出连续n天交易日的股票价格，问在其中什么时候买入什么时候卖出获得最大的收入，求出最大的收入值是多少。本题还有一点是比较关键的，<strong>最多允许两次交易</strong>，并且交易日期中买入股票和卖出股票不能在同一天。</li></ul><h4 id="解法-1-超时"><a href="#解法-1-超时" class="headerlink" title="解法 1 - 超时"></a>解法 1 - <code>超时</code></h4><ul><li><p>以某个交易日为分界线将总时间分成两个时间段，计算该天前包括当天的交易获利以及该天以后时间段的交易获利，最后计算总和获得交易两次的最大获利</p><ul><li>时间复杂度 - $O(n^2)$</li><li>空间复杂度 - $O(n)$</li></ul></li><li><p>实现代码</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre[prices.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> post[prices.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求某天前(包括当天)成交的最大利润</span></span><br><span class="line">        <span class="keyword">int</span> prebase = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> preMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">            preMaxProfit = max(preMaxProfit, prices[i] - prebase);</span><br><span class="line">            pre[i] = preMaxProfit;</span><br><span class="line">            prebase = min(prebase, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求某天后成交的最大利润</span></span><br><span class="line">        <span class="keyword">int</span> postBase = prices[prices.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> postMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            postMaxProfit = max(postMaxProfit, postBase - prices[i]);</span><br><span class="line">            post[i<span class="number">-1</span>] = postMaxProfit;</span><br><span class="line">            postBase = max(postBase, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prices.size(); ++j)</span><br><span class="line">                maxProfit = max(maxProfit, pre[i] + post[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>结果 - <code>超时</code><br><img src="/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/1.png" alt="preview"></p></li></ul><h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法 2"></a>解法 2</h4><ul><li><p>该解法其实是总结了一下<code>解法 1</code>以及参考了一下评论里面的解法，其实现起来也比较简单，但是理解起来稍微费解一点，其维护四个变量，<code>buy1</code>表示第一次买股票的花费，<code>sell1</code>表示第一次交易股票后获得的利润，<code>buy2</code>表示第二次买股票后剩余的钱（第一次交易利润-购买的股票价格），<code>sell2</code>表示第二次交易后剩余的钱，即两次交易下来最后的盈利。当然也不一定需要两次交易，加入交易以后亏钱的话是不会进行交易的。</p><ul><li>时间复杂度 - $O(n)$</li><li>空间复杂度 - $O(1)$</li></ul></li><li><p>实现代码</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> buy1 = INT_MIN, buy2 = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>, sell2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices)&#123;</span><br><span class="line">            buy1 = max(buy1, -price);</span><br><span class="line">            sell1 = max(sell1, buy1 + price);</span><br><span class="line">            buy2 = max(buy2, sell1 - price);</span><br><span class="line">            sell2 = max(sell2, buy2 + price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解法-3"><a href="#解法-3" class="headerlink" title="解法 3"></a>解法 3</h4><ul><li>这个解法与解法 2的思路类似，但是做了一定的拓展，其不仅仅适用于只交易2次，也可以拓展适用于交易<code>k</code>次的情况。对于<code>profit[i][j]</code>即交易日<code>i</code>到交易日<code>j</code>这个时间段买入的收入，其应该是大于等于<code>profit[i][j-1]</code>，即大于前一个时间都的利润，同时其也可以在第<code>j</code>个交易日卖出自己的股票，此时收益为<code>余额 + 卖出价格</code>，此时当前时间段最大利润值为<code>余额 + 卖出价格</code>与<code>profit[i][j-1]</code>的最大值</li><li>实现代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交易两次，得到的利润</span></span><br><span class="line">        <span class="keyword">int</span> profit[<span class="number">3</span>][prices.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prices.size(); ++j)</span><br><span class="line">                profit[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> balance = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; prices.size(); j++) &#123;</span><br><span class="line">                profit[i][j] = max(profit[i][j - <span class="number">1</span>], balance + prices[j]);</span><br><span class="line">                balance = max(balance, profit[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit[<span class="number">2</span>][prices.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Say you have an array for which the &lt;e
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>115. Distinct Subsequences</title>
    <link href="http://yoursite.com/2018/11/24/115-Distinct-Subsequences/"/>
    <id>http://yoursite.com/2018/11/24/115-Distinct-Subsequences/</id>
    <published>2018-11-24T12:07:25.000Z</published>
    <updated>2018-11-24T12:57:47.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string <code>S</code> and a string <code>T</code>, count the number of distinct subsequences of <code>S</code>which equals <code>T</code>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 5 ways you can generate &quot;bag&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br></pre></td></tr></table></figure></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>本题是一道动态规划类型的问题，给出两个字符串<code>s</code>、<code>t</code>，计算<code>S</code>的不同子序列中等于<code>T</code>的子序列数量。</li><li>一开始有点迷茫，不知道其中的转移方程是怎样的，只能举例然后观察一下其中的状态转移方程了。使用<code>dp[i][j]</code>记录字符串<code>S</code>的前<code>i</code>个字符的子串中有多少个与字符串<code>T</code>的前<code>j</code>个字符构成的子串相等的子序列。</li><li><strong>Example 1</strong> - <code>S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</code></li></ul><div class="table-container"><table><thead><tr><th>T \ S</th><th>$\emptyset$</th><th>r</th><th>a</th><th>b</th><th>b</th><th>b</th><th>i</th><th>t</th></tr></thead><tbody><tr><td>$\emptyset$</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>r</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>a</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>b</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>b</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>3</td><td>3</td><td>3</td></tr><tr><td>i</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td></tr><tr><td>t</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td></tr></tbody></table></div><ul><li><strong>Example 2</strong> - <code>S = &quot;babgbag&quot;, T = &quot;bag&quot;</code></li></ul><div class="table-container"><table><thead><tr><th>T \ S</th><th>$\emptyset$</th><th>b</th><th>a</th><th>b</th><th>g</th><th>b</th><th>a</th><th>g</th></tr></thead><tbody><tr><td>$\emptyset$</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>b</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>a</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>4</td><td>4</td></tr><tr><td>g</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>5</td></tr></tbody></table></div><ul><li>通过对样例的分析，我们可以得到<code>dp[i][j] &gt;= dp[i][j-1]</code>在<code>j-1&gt;=0</code>的条件下。同时当<code>T</code>为空串的时候，<code>dp[i][0] = 1</code>，因为空串是任一字符串的子串。再仔细观察，可以得到当<code>s[i-1] == t[j-1]</code>的时候，<code>dp[i][j] = dp[i-1][j] + dp[i-1][j-1]</code>。综合起来，我们可以得到状态转移的表示:<code>dp[i][j] = dp[i-1][j] + (s[i-1] == t[j-1] ? dp[i-1][j-1] : 0);</code></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size() + <span class="number">1</span>][t.size() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.size(); ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.size(); ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + (s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] ? dp[i<span class="number">-1</span>][j<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][t.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a string &lt;code&gt;S&lt;/code&gt; and a string &lt;code&gt;T&lt;/code&gt;, count the n
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>120. Triangle</title>
    <link href="http://yoursite.com/2018/11/24/120-Triangle/"/>
    <id>http://yoursite.com/2018/11/24/120-Triangle/</id>
    <published>2018-11-24T03:33:27.000Z</published>
    <updated>2018-11-24T04:11:08.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><pre>[    [<strong>2</strong>],    [<strong>3</strong>,4],    [6,<strong>5</strong>,7],    [4,<strong>1</strong>,8,3]]</pre><p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p><p><strong>Note:</strong></p><p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p></div></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>题意分析：本题是一道动态规划类型的题目，给出一个三角形，每个位置有一个权值，求其一条经过每层的权值最小的路径的权值是多少。</li><li>动态规划 <ul><li>思路 1<ul><li>寻找一条由顶向下的路径，使用<code>path[i][j]</code>表示从顶点<code>(0,0)</code>到结点<code>(i,j)</code>的路径权重<ul><li>主要考虑当前结点<code>（i，j）</code>可以选择的路径<ul><li>考虑从<code>(i-1, j)</code>到达该节点的路径 — <code>(j &lt; triangle[i-1].size())</code></li><li>考虑从<code>(i-1, j-1)</code>到达该节点的路径    — <code>(j - 1 &gt;= 0)</code></li></ul></li></ul></li></ul></li><li>思路 2<ul><li>当然本题也可以考虑从底向顶寻找一条路径，同样使用使用<code>path[i][j]</code>表示从底部到结点<code>(i,j)</code>的路径权重<ul><li>初始最底部结点 <code>path[i][j] = triangle[i][j]</code></li><li>对于其余非底部结点，主要考虑当前结点<code>（i，j）</code>可以选择的路径<ul><li>考虑从<code>(i+1, j)</code>到达该节点的路径 </li><li>考虑从<code>(i+1, j+1)</code>到达该节点的路径</li><li><code>path[i][j] = min(path[i+1][j+1], path[i+1][j]) + triangle[i][j];</code></li></ul></li></ul></li></ul></li><li>时间复杂度 — $O(n^2)$</li><li>空间复杂度 — $O(n^2)$</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><ul><li><p>思路 1</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> path[triangle.size()][triangle[triangle.size()<span class="number">-1</span>].size()];</span><br><span class="line"></span><br><span class="line">        path[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangle.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); ++j) &#123;</span><br><span class="line">                path[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>) path[i][j] = path[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j &lt; triangle[i<span class="number">-1</span>].size())</span><br><span class="line">                    path[i][j] = min(path[i<span class="number">-1</span>][j], path[i][j]); </span><br><span class="line">                path[i][j] += triangle[i][j];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; path[i][j] &lt;&lt; " ";</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triangle[triangle.size()<span class="number">-1</span>].size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(path[triangle.size()<span class="number">-1</span>][i] &lt; min)</span><br><span class="line">                min = path[triangle.size()<span class="number">-1</span>][i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路 2</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> path[triangle.size()][triangle[triangle.size()<span class="number">-1</span>].size()];</span><br><span class="line"></span><br><span class="line">        path[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = triangle[triangle.size() - <span class="number">1</span>].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            path[triangle.size() - <span class="number">1</span>][j] = triangle[triangle.size() - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = triangle[i].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                path[i][j] = min(path[i+<span class="number">1</span>][j+<span class="number">1</span>], path[i+<span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; path[i][j] &lt;&lt; " ";</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given a triangle, find the minimum pat
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>97. Interleaving String</title>
    <link href="http://yoursite.com/2018/11/23/97-Interleaving-String/"/>
    <id>http://yoursite.com/2018/11/23/97-Interleaving-String/</id>
    <published>2018-11-23T04:29:31.000Z</published>
    <updated>2018-11-23T04:31:02.807Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> s1 = "aabcc", s2 = "dbbca", <em>s3</em> = "aadbbcbcac"<strong>Output:</strong> true</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> s1 = "aabcc", s2 = "dbbca", <em>s3</em> = "aadbbbaccc"<strong>Output:</strong> false</pre></div></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这道题目的意思比较简单，给出三个字符串s1,s2,s3，问字符串s3是否由字符串s1和字符串s2交错而成的，返回真假即可。接下来我将会介绍以下几种解决的思路。    </li><li>思路<ul><li>动态规划问题需要先找到子问题，然后子问题递推得到问题的解决。本题我们可以将问题看成字符串s1的前<code>i</code>个字符与s2的前<code>j</code>个字符是否能交错生成s3的前<code>i+j-2</code>个字符。确认子问题后，我们需要找到其中的转移方程。     </li><li>维护一个二维的布尔数组<code>dp[s1.size][s2.size]</code>，，用<code>dp[i][j]</code>表示字符串s1的前<code>i</code>个字符即与字符串s2的前<code>j</code>个字符是否可以交错生成字符串s3的前<code>i+j-2</code>个字符的匹配情况。假如<code>dp[i][j]</code>为<code>true</code>，即表示字符串s3的前<code>i+j-2</code>个字符由字符串s1的前<code>i</code>个字符即与字符串s2的前<code>j</code>个字符交错生成，否则表示不可以。</li><li>对于<code>dp[i][j]</code>的表示，我们可以列出以下几种情况<ul><li><code>i = j = 0</code> <ul><li>空对空，肯定匹配。</li><li><code>dp[i][j] = true</code></li></ul></li><li><code>i != 0 &amp;&amp; j = 0</code><ul><li>此时可以看成s1的前i个字符串与s3的前i个字符串的匹配情况。</li><li><code>dp[i][0] = dp[i-1][0] &amp;&amp; (s1[i-1] == s3[i-1])</code></li></ul></li><li><code>i = 0 &amp;&amp; j != 0</code><ul><li>此时可以看成s2的前j个字符串与s3的前i个字符串的匹配情况。</li><li><code>dp[i][0] = dp[i-1][0] &amp;&amp; (s1[i-1] == s3[i-1])</code></li></ul></li><li><code>i &gt; 0 &amp;&amp; j &gt; 0</code><ul><li><code>dp[i][j]</code>需要考虑可能的组合情况。一个是<code>dp[i-1][j]</code>和<code>s1[i-1]与s3[i+j-1]</code>匹配的情况，另一个是<code>dp[i][j-1]</code>和<code>s2[j-1]与s3[i+j-1]</code>匹配的情况，我们需要将二者得到的匹配情况进行或操作来得到<code>dp[i][j]</code>。</li><li><code>dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]) || (dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1])</code></li></ul></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code class="lang-cpp">// dpclass Solution {public:    bool isInterleave(string s1, string s2, string s3) {        if (s1.size() + s2.size() != s3.size())    return false;        bool dp[s1.size() + 1][s2.size() + 1];        dp[0][0] = true;        for(int i = 1; i &lt;= s1.size(); ++i)            dp[i][0] = dp[i-1][0] &amp;&amp; (s1[i-1] == s3[i-1]);        for(int j = 1; j &lt;= s2.size(); ++j)            dp[0][j] = dp[0][j-1] &amp;&amp; (s2[j-1] == s3[j-1]);        for(int i = 1; i &lt;= s1.size(); ++i) {            for(int j = 1; j &lt;= s2.size(); ++j) {                dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]) || \                            (dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]);            }        }        return dp[s1.size()][s2.size()];    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt;, &lt;em&gt;s3
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>95. Unique Binary Search Trees II</title>
    <link href="http://yoursite.com/2018/11/23/95-Unique-Binary-Search-Trees-II/"/>
    <id>http://yoursite.com/2018/11/23/95-Unique-Binary-Search-Trees-II/</id>
    <published>2018-11-23T04:26:28.000Z</published>
    <updated>2018-11-23T04:28:38.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div><p>Given an integer <em>n</em>, generate all structurally unique         <strong>BST's</strong> (binary search trees) that store values 1 ...&nbsp;<em>n</em>.</p><p><strong>Example:</strong></p><pre><strong>Input:</strong> 3<strong>Output:</strong>[&nbsp; [1,null,3,2],&nbsp; [3,2,null,1],&nbsp; [3,1,null,null,2],&nbsp; [2,1,3],&nbsp; [1,null,2,null,3]]<strong>Explanation:</strong>The above output corresponds to the 5 unique BST's shown below:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</pre></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>本题的题意比较简单，给出二叉搜索树的节点数目<code>n</code>，求出可以构成多少中不同结构的二叉搜索树。</li><li>其实实现起来还是比较简单的。对于其中一个节点<code>i</code>，将其作为该树的根节点，然后其左边的元素都作为其左子树的元素，右边的元素都作为其右子树的元素，再通过递归得到其左子树和右子树的可能出现的情况的集合，然后再组合起来。一些需要注意的情况：<ul><li>递归的结束条件： 当该子树的起点大于终点的时候 — <code>start &gt; end</code>，递归结束，能够生成子树的情况为无，即为<code>NULL</code>。</li><li>对得到的左子树和右子树的返回情况需要判断其是否为空（可能没有不存在左或右节点的情况)，如果不存在，需要推入一个<code>NULL</code>，然后再进行组合，否则遍历组合的时候<code>left.size * right.size = 0</code>，将导致结果不全，只有左右子树都存在的结果。</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">    * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    *     int val;</span></span><br><span class="line"><span class="comment">    *     TreeNode *left;</span></span><br><span class="line"><span class="comment">    *     TreeNode *right;</span></span><br><span class="line"><span class="comment">    *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">    * &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; v = myGenerate(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; myGenerate(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)<span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; left = myGenerate(start, i<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; right = myGenerate(i + <span class="number">1</span>, end);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(!left.size())left.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span>(!right.size())right.push_back(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; left.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; right.size(); ++k) &#123;</span><br><span class="line">                    TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    node-&gt;left = left[j];</span><br><span class="line">                    node-&gt;right = right[k];</span><br><span class="line">                    v.push_back(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div&gt;&lt;p&gt;Given an integer &lt;em&gt;n&lt;/em&gt;, generate all structurally unique    
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>87. Scramble String</title>
    <link href="http://yoursite.com/2018/11/21/87-Scramble-String/"/>
    <id>http://yoursite.com/2018/11/21/87-Scramble-String/</id>
    <published>2018-11-21T03:25:51.000Z</published>
    <updated>2018-11-21T03:33:45.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="question-description__3U1T" style="padding-top: 10px;"><div><p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p><p>Below is one possible representation of <em>s1</em> = <code>"great"</code>:</p><pre>    great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t</pre><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>"gr"</code> and swap its two children, it produces a scrambled string <code>"rgeat"</code>.</p><pre>    rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \            a   t</pre><p>We say that <code>"rgeat"</code> is a scrambled string of <code>"great"</code>.</p><p>Similarly, if we continue to swap the children of nodes <code>"eat"</code> and <code>"at"</code>, it produces a scrambled string <code>"rgtae"</code>.</p><pre>    rgtae    /    \   rg    tae  / \    /  \ r   g  ta   e        / \       t   a</pre><p>We say that <code>"rgtae"</code> is a scrambled string of <code>"great"</code>.</p><p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> s1 = "great", s2 = "rgeat"<strong>Output:</strong> true</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> s1 = "abcde", s2 = "caebd"<strong>Output:</strong> false</pre></div></div><h3 id="题目分析以及解决思路"><a href="#题目分析以及解决思路" class="headerlink" title="题目分析以及解决思路"></a>题目分析以及解决思路</h3><ul><li>题目的意思也比较明确吧，给出两个字符串，将字符串分割成一个二叉树，并且可以交换非叶子节点，求解两个字符串能否相互构造。    </li></ul><h4 id="方法-1-递归"><a href="#方法-1-递归" class="headerlink" title="方法 1    - 递归"></a>方法 1    - <code>递归</code></h4><ul><li>思路：将字符串划分为两部分，分别递归得到结果是否<code>scramble</code>。需要考虑完备性，即需要将各种划分情况都需要考虑一遍。<ul><li>情况①： <code>s1</code>的前<code>k</code>个字符与<code>s2</code>的前<code>k</code>个字符进行判断同时 <code>s1</code>的后<code>size-k</code>个字符与<code>s2</code>的后<code>size-k</code>进行判断 — <code>isScramble(s1.substr(0, k), s2.substr(0, k)) &amp;&amp; isScramble(s1.substr(k, size-k), s2.substr(k, size-k))</code></li><li>情况②：    <code>s1</code>的前<code>k</code>个字符与<code>s2</code>的后<code>k</code>个字符进行判断同时 <code>s1</code>的后<code>size-k</code>个字符与<code>s2</code>的前<code>size-k</code>进行判断 — <code>isScramble(s1.substr(0, size-k), s2.substr(k, size-k)) &amp;&amp; isScramble(s1.substr(size-k, k), s2.substr(0, k))</code></li></ul></li><li>实现代码：<ul><li>如果不剪枝将会造成超时    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == s2)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() != s2.size())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = s1.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">int</span> letter[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            letter[s1[i] - <span class="string">'a'</span>] ++;</span><br><span class="line">            letter[s2[i] - <span class="string">'a'</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(letter[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; size; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>, k), s2.substr(<span class="number">0</span>, k)) &amp;&amp; isScramble(s1.substr(k, size-k), s2.substr(k, size-k)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>, size-k), s2.substr(k, size-k)) &amp;&amp; isScramble(s1.substr(size-k, k), s2.substr(<span class="number">0</span>, k)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="方法-2-动态规划"><a href="#方法-2-动态规划" class="headerlink" title="方法 2 - 动态规划"></a>方法 2 - <code>动态规划</code></h4><ul><li>我们需要维护一个变量<code>match[i][j][n]</code>，其中<code>i</code>为字符串<code>s1</code>的起始字符，<code>j</code>为字符串<code>s2</code>的起始字符，<code>n</code>为当前字符的长度，<code>match[i][j][len]</code>表示的是以<code>i</code>和<code>j</code>分别为<code>s1</code>和<code>s2</code>起点的长度为<code>len</code>的字符串是不是互为<code>scramble</code>。</li><li>如何得到<code>match[i][j][n]</code>，推导出其中的状态转移方程，其实与递归中的思路相同。我们对于当前情况，需要对于目前所有可能的划分都去检索一次，如果有一次划分是<code>scramble</code>的，则<code>match[i][j][len]</code>即为<code>true</code>，倘若所有的划分都不是<code>scramble</code>的，则<code>match[i][j][len]</code>即为<code>false</code>。关于划分，同时需要划分两种情况：<ul><li>情况①： <code>s1</code>以<code>i</code>为起始的前<code>k</code>个字符与<code>s2</code>以<code>j</code>为起始的前<code>k</code>个字符进行判断同时 <code>s1</code>的后<code>len-k</code>个字符与<code>s2</code>的后<code>len-k</code>进行判断 — <code>match[i][j][k] &amp;&amp; match[i+k][j+k][len-k]</code></li><li>情况②：    <code>s1</code>以<code>i</code>为起始的<code>k</code>个字符与<code>s2</code>以<code>j+len-k</code>为起始的<code>k</code>个字符进行判断同时 <code>s1</code>以<code>i+k</code>为起始的<code>len-k</code>个字符与<code>s2</code>以<code>j</code>为起始的<code>len-k</code>进行判断 — <code>match[i][j+len-k][k] &amp;&amp; match[i+k][j][len-k]</code></li></ul></li><li>实现代码：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s1.size() != s2.size())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!s1.size())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = s1.size();</span><br><span class="line">        <span class="comment">// s1_start, s2_start, match_len</span></span><br><span class="line">        <span class="keyword">bool</span> match[size][size][size+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j)</span><br><span class="line">                match[i][j][<span class="number">1</span>] = (s1[i] == s2[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= size; ++len) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size - len; ++i) </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size - len; ++j) &#123;</span><br><span class="line">                    match[i][j][len] = <span class="literal">false</span>;<span class="comment">// initial</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; len; ++k) </span><br><span class="line">                        match[i][j][len] |= (match[i][j][k] &amp;&amp; match[i+k][j+k][len-k]) \</span><br><span class="line">                                            || (match[i][j+len-k][k] &amp;&amp; match[i+k][j][len-k]); </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> match[<span class="number">0</span>][<span class="number">0</span>][size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;question-description__3U1T&quot; style=&quot;padding-top: 10px;&quot;&gt;&lt;div&gt;&lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>63. Unique Paths II</title>
    <link href="http://yoursite.com/2018/11/21/63-Unique-Paths-II/"/>
    <id>http://yoursite.com/2018/11/21/63-Unique-Paths-II/</id>
    <published>2018-11-21T03:25:09.000Z</published>
    <updated>2018-11-21T03:26:45.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>Now consider if some obstacles are added to the grids. How many unique paths would there be?<br>An obstacle and empty space is marked as <code>1</code> and <code>0</code>respectively in the grid.</p><p><strong>Note:</strong> m and n will be at most 100.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">    [0,0,0],</span><br><span class="line">    [0,1,0],</span><br><span class="line">    [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>题目的意思比较简单，给出一个网格图，以其左上角为起点，右下角为终点，求其左下角到右下角路径的数目。</li><li>题目显然是一道<strong>动态规划</strong>的题目，我们需要做的是理清其中的转移方程，首先题目还有一定的限制，某些格子是不能正常通过的（障碍物），并且只能向下或者向右移动，因此我们可以推出起点位置到当前格子的路径数目为：<code>path[i][j] = path[i-1][j] + path[i][j-1]</code>，对于第一排(<code>i = 0</code>)以及第一列(<code>j=0</code>)则需要额外计算，<strong>到达路径数目最多为1</strong>，其与前一个格子到达路径数目以及当前格子是否为障碍物有关。</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *path[i][j] = path[i-1][j] + path[i][j-1]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> path[obstacleGrid.size()][obstacleGrid[<span class="number">0</span>].size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(!obstacleGrid[i][<span class="number">0</span>])</span><br><span class="line">                path[i][<span class="number">0</span>] = i &gt;= <span class="number">1</span> ? path[i<span class="number">-1</span>][<span class="number">0</span>] : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; obstacleGrid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            <span class="keyword">if</span>(!obstacleGrid[<span class="number">0</span>][j])</span><br><span class="line">                path[<span class="number">0</span>][j] = j &gt;= <span class="number">1</span> ? path[<span class="number">0</span>][j<span class="number">-1</span>] : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; obstacleGrid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">                <span class="keyword">if</span>(!obstacleGrid[i][j])</span><br><span class="line">                    path[i][j] = path[i<span class="number">-1</span>][j] + path[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    path[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path[obstacleGrid.size() - <span class="number">1</span>][obstacleGrid[<span class="number">0</span>].size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Sta
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>32. Longest Valid Parentheses</title>
    <link href="http://yoursite.com/2018/11/18/32-Longest-Valid-Parentheses/"/>
    <id>http://yoursite.com/2018/11/18/32-Longest-Valid-Parentheses/</id>
    <published>2018-11-18T05:52:43.000Z</published>
    <updated>2018-11-18T05:54:53.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>题目的意思比较简单，给出一个只由左括号和右括号组成的字符串，求出有效的括号匹配最长长度    </li></ul><h4 id="方法-1-利用stack"><a href="#方法-1-利用stack" class="headerlink" title="方法 1 - 利用stack"></a>方法 1 - <code>利用stack</code></h4><ul><li>利用数据结构<code>stack</code>完成，整个过程中<code>stack</code>的第一个元素为当前已遍历的不匹配括号串的最后一个<code>&#39;)&#39;</code>的下标或者<code>-1</code>，其余在<code>stack</code>中存储的是字符<code>&#39;(&#39;</code>的下标，参见阐述的步骤即可指定。使用<code>stack</code>的<code>FILO</code>    的特性完成判断字符是否括号是否匹配以及计算有效匹配括号的长度</li><li>步骤<ul><li>首先将<code>-1</code>推进<code>stack</code>中</li><li>遍历字符串，对于字符进行不同的处理<ul><li><code>&#39;(&#39;</code>， 直接将其下标推入栈中-<code>stack.push(i)</code></li><li><code>&#39;)&#39;</code>，首先弹出栈顶元素-<code>stack.pop()</code>。接下来的步骤需要划分两种情况进行：</li></ul><ol><li>如果当前栈中已经为空，即证明当前匹配的串已经无效，因为<code>&#39;)&#39;</code>数目大于<code>&#39;(&#39;</code>的数目，无法有效匹配括号，此时不做关于最长匹配的记录，<strong>只把当前下标推入栈中</strong>（当前<code>&#39;)&#39;</code>的下标即为已遍历的不匹配括号串的最后一个<code>&#39;)&#39;</code>的下标）</li><li>如果当前栈不为空，则证明目前匹配的串依旧有效，则更新一下最长匹配长度 - <code>num = max(num, i - myStack.top())</code></li></ol></li></ul></li><li>实现代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; myStack;</span><br><span class="line">        myStack.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                myStack.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                myStack.pop();</span><br><span class="line">                <span class="keyword">if</span>(myStack.empty()) </span><br><span class="line">                    myStack.push(i);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    num = max(num, i - myStack.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法-2-动态规划"><a href="#方法-2-动态规划" class="headerlink" title="方法 2 - 动态规划"></a>方法 2 - <code>动态规划</code></h4><ul><li>思路<ul><li>括号匹配的时候，遇到<code>&#39;)&#39;</code>才可能成功匹配上。因此，使用一个数组<code>num</code>记录每个<code>)</code>最长有效匹配的长度。</li><li>当前检索到<code>&#39;)&#39;</code>有两种情况<ul><li>情况1:  <code>&quot;...()...&quot;</code><ul><li>这种至少匹配的长度是2，但是可能连着之前也是有可能满足的，例如<code>&quot;...()()...&quot;</code>这种情况，因此需要考虑连着已匹配的-<code>(i &gt;= 2 ? num[i-2] : 0)</code>    </li><li>转移方程： <code>num[i] = (i &gt;= 2 ? num[i-2] : 0) + 2;</code>    </li></ul></li><li>情况2:  <code>&quot;...))...&quot;</code>        <ul><li>这种情况的匹配与前一个<code>&#39;)&#39;</code>相关，如果前面是有效匹配的，则需要检查<code>s[i-num[i-1]-1] == &#39;(&#39;</code>(条件：<code>i &gt;= num[i-1] + 1</code>)，即需要考虑<code>&quot;...((...))...&quot;</code>的情况。同时，还需要考虑前面是否可以与有效匹配的串连接起来，例如<code>&quot;...()((...))...&quot;</code>，因此还需要考虑连着已匹配的-<code>i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0</code></li><li>转移方程：<code>num[i] = num[i-1] + 2 + (i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0)</code></li></ul></li></ul></li></ul></li><li><p>实现代码</p><pre><code class="lang-cpp">  // dp  class Solution {  public:      int longestValidParentheses(string s) {          if(!s.size())    return 0;          int maxNum = 0;          int num[s.size()] = {0};          for(int i = 1; i &lt; s.size(); ++i){              if(s[i] == &#39;)&#39; &amp;&amp; s[i-1] == &#39;(&#39;) {                  // &quot;...()...&quot;                      num[i] = (i &gt;= 2 ? num[i-2] : 0) + 2;              }              else if(s[i] == &#39;)&#39; &amp;&amp; s[i-1] == &#39;)&#39; &amp;&amp; i &gt;= num[i-1] + 1 &amp;&amp; s[i-num[i-1]-1] == &#39;(&#39;) {                  // &quot;...((...))...&quot;                   num[i] = num[i-1] + 2 + (i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0);              }              maxNum = max(maxNum, num[i]);          }          return maxNum;      }  };</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a string containing just the characters &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>72. Edit Distance</title>
    <link href="http://yoursite.com/2018/11/18/72-Edit-Distance/"/>
    <id>http://yoursite.com/2018/11/18/72-Edit-Distance/</id>
    <published>2018-11-18T05:48:30.000Z</published>
    <updated>2018-11-18T05:50:49.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two words word1 and word2, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p><p>You have the following 3 operations permitted on a word:</p><ul><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ul><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (remove &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (remove &apos;e&apos;)</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (insert &apos;u&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><ul><li>这道题是一道动态规划的题，需要将一个字符串<code>word1</code>经过<code>add</code>、<code>delete</code>、<code>replace</code>三种操作变换成另一个字符串<code>word2</code>，求最小的编辑距离.</li><li><p>解题思路：假设<code>word1=[123...n]</code>    ,<code>word2=[123...m]</code>，要求使得<code>word1</code>转换成<code>word2</code>。对于这个问题，我们将其分解为子问题求解。</p><ul><li>定义dis[i][j]<ul><li>表示<code>word1&#39; = [1..i]</code>转换成<code>word2&#39; = [1...j]</code>的编辑距离（<code>i</code>代表<code>word1</code>前<code>i</code>个字符,<code>j</code>代表<code>word2</code>前<code>j</code>个字符）</li><li>因此<code>word1</code>到<code>word2</code>的编辑距离为<code>dis[n][m]</code>        </li></ul></li><li>求解<code>word1</code>到<code>word2</code>的编辑距离，我们可以求取<code>word1</code>的前<code>i</code>个字符(<code>0 &lt; i &lt; n</code>)到<code>word2</code>的前<code>j</code>个字符(<code>0 &lt; j &lt; m</code>)的编辑距离<code>dis[i][j]</code>。当然每个<code>dis[i][j]</code>都基于之前的计算。</li><li><p>步骤</p><ul><li>初始化<ul><li>dis[i, 0] = i</li><li>dis[0, j] = j</li></ul></li><li><p><strong>递推关系</strong>—<code>核心</code>    </p><script type="math/tex; mode=display">dis[i][j] = min \begin{cases}      dis[i][j-1] + 1\\      dis[i-1][j] + 1\\      dis[i-1][j-1] + (word1[i-1] == word2[j-1] ? 0 : 1))\\      \end{cases}</script><p>  其中三个操作的表示</p><ul><li><strong>insert</strong>:     <code>dis[i, j] = dis[i][j-1] + 1</code>    </li><li><strong>delete</strong>:    <code>dis[i, j] = dis[i-1][j] + 1</code></li><li><p><strong>replace or no op</strong>：<code>dis[i, j] = dis[i-1][j-1] + (word1[i-1] == word2[j-1] ? 0 : 1)</code></p><p>对于每<code>dis[i][j]</code>，我们选取最小编辑距离    </p></li></ul></li></ul></li><li>最后得到的<code>dis[n][m]</code>就是<code>word1</code>到<code>word2</code>的编辑距离</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.size();</span><br><span class="line">        <span class="keyword">int</span> n = word2.size();</span><br><span class="line">        <span class="keyword">int</span> dis[m+<span class="number">1</span>][n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">            dis[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n; ++j)</span><br><span class="line">            dis[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m or n equal 0</span></span><br><span class="line">        <span class="keyword">if</span> (!m &amp;&amp; !n)</span><br><span class="line">            <span class="keyword">return</span> max(m, n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// insert: dis[i, j] = dis[i][j-1] + 1</span></span><br><span class="line">        <span class="comment">// delete:dis[i, j] = dis[i-1][j] + 1</span></span><br><span class="line">        <span class="comment">// replace or no op：dis[i, j] = dis[i-1][j-1] + (word1[i-1] == word2[j-1] ? 0 : 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dis[i][j] = min(dis[i][j<span class="number">-1</span>] + <span class="number">1</span>,</span><br><span class="line">                    min(dis[i<span class="number">-1</span>][j] + <span class="number">1</span>, dis[i<span class="number">-1</span>][j<span class="number">-1</span>] + (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] ? <span class="number">0</span> : <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://web.stanford.edu/class/cs124/lec/med.pdf" target="_blank" rel="noopener">参考链接 - pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two words word1 and word2, find the minimum number of operations
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>55. Jump Game</title>
    <link href="http://yoursite.com/2018/11/17/55-Jump-Game/"/>
    <id>http://yoursite.com/2018/11/17/55-Jump-Game/</id>
    <published>2018-11-17T07:43:09.000Z</published>
    <updated>2018-11-17T07:44:33.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>题意比较简单，给定每一个点能向前跳跃的距离，求是否能从初始位置到末尾位置</li><li>思路：使用一个变量<code>maxDis</code>记录当前能访问到最远的节点 ，遍历数组节点时候，需要判断当前节点能否被访问到，如果能访问到，则以该节点能访问到的最远节点<code>i + nums[i]</code>与当前能访问的最远节点<code>maxDis</code>比较，使得<code>maxDis = max(maxDis, i + nums[i]</code>(<strong>核心状态转移</strong>)。如果<code>maxDis &gt;= nums.size() - 1</code>，则证明可以访问到最后一个节点。</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(maxDis &lt; len - <span class="number">1</span> &amp;&amp; maxDis &gt;= i &amp;&amp; i &lt; len) &#123;</span><br><span class="line">            maxDis = max(maxDis, i + nums[i]);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDis &gt;= len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an array of non-negative integers, you are initially positioned 
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>330. Patching Array</title>
    <link href="http://yoursite.com/2018/11/17/330-Patching-Array/"/>
    <id>http://yoursite.com/2018/11/17/330-Patching-Array/</id>
    <published>2018-11-17T07:37:21.000Z</published>
    <updated>2018-11-18T13:02:34.883Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3], n = 6</span><br><span class="line">Output: 1 </span><br><span class="line">Explanation:</span><br><span class="line">Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.</span><br><span class="line">Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].</span><br><span class="line">Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].</span><br><span class="line">So we only need 1 patch.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,5,10], n = 20</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The two patches can be [2, 4].</span><br></pre></td></tr></table></figure></p><p><strong>Example 3:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,2], n = 5</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ul><li>题意：题目指给出一个有序的正整数的数列<code>nums</code>，以及一个正整数<code>n</code>，最少需要额外添加的多少个数字才能使得<code>[1,n]</code>中每一个数字能够被数列中若干个数字的和表示，求出最少需要添加的数字数。</li><li><p>解题思路：假设当前<code>[0, t)</code>中每个数字可以由数列中的数字以及额外添加的数字的和表示，则当其选择到下一个<code>num[i]</code>的时候，分两种情况讨论</p><ul><li><code>num[i] &lt;= t</code><ul><li>此时可以将维护的区间扩展到<code>[0 , t+num[i] ]</code></li></ul></li><li><p><code>num[i] &gt; t</code> </p><ul><li>此时不能直接扩展区间，因为中间有一段数字<code>[t, num[i] - 1]</code>是无法表示的。因此此时需要加一个额外的数字，加的数字应该尽可能的大，否则将可能会增加额外需要数字的数目。<strong>当前能够加的最大数字是<code>t</code></strong>，因为如果额外添加的数字<code>newNum</code>大于<code>t</code>，则对于区间<code>[t, newNum - 1]</code>这一段的数字则无法表示，因此每次最多加<code>t</code>，区间扩展到<code>[t, t+t]</code>，同时统计添加数字<code>addNum + 1</code>.</li></ul><p>当前维护的<code>t &gt; n</code>的时候，可以直接输出结果</p></li><li>然而，问题并没有解决，出现了超时的问题。对于测试数据感觉还是比较小的，不太可能是由于时间复杂度出错。然后最后的结果是<code>2147483647</code>，接近了<code>int</code>的最大值，考虑到是区间扩展<code>t + t</code>的时候导致溢出，一直导致<code>t &lt; n</code>，出现死循环了，因此将<code>t</code>改为<code>long long</code>类型<br><img src="/2018/11/17/330-Patching-Array/1.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [0, rightSide)</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rightSide = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> addNums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rightSide &gt; n)<span class="keyword">return</span> addNums;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; rightSide &amp;&amp; rightSide &lt;= n) &#123;</span><br><span class="line">            rightSide += rightSide;</span><br><span class="line">            addNums++;</span><br><span class="line">        &#125;</span><br><span class="line">        rightSide += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rightSide &lt;= n) &#123;</span><br><span class="line">        rightSide += rightSide;</span><br><span class="line">        addNums++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addNums;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/17/330-Patching-Array/2.png" alt="在这里插入图片描述"></p><ul><li>感觉写的思路还是比较混乱，然后稍微优化一下代码的结构</li><li>优化代码</li><li>谈一个新发现： 本来对于区间扩展部分都是使用<code>+=</code>操作，但是最后运行时间与未优化的没有区别，然后看了下提交的dalao们的代码，发现都是<code>a = a + b</code>这样形式的操作，不使用<code>+=</code>操作的，然后就惊奇的发现运行时间神奇的减少大半了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [0, rightSide)</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rightSide = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> addNums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rightSide &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; size &amp;&amp; rightSide &gt;= nums[i]) &#123;</span><br><span class="line">                rightSide = rightSide + nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightSide = rightSide + rightSide;</span><br><span class="line">                ++addNums; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/17/330-Patching-Array/3.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a sorted positive integer array nums and an integer n, add/patch
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 5 Go语言net/http源码解读</title>
    <link href="http://yoursite.com/2018/11/16/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-5-Go%E8%AF%AD%E8%A8%80net-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/11/16/服务计算-5-Go语言net-http源码解读/</id>
    <published>2018-11-16T05:24:26.000Z</published>
    <updated>2018-11-16T13:01:34.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景要提"><a href="#背景要提" class="headerlink" title="背景要提"></a>背景要提</h3><p><code>net/http</code>标准库可以分为客户端和服务器两个部分。以下是net/http标准库的各个组成部分的关于客户端和服务端的一个划分：</p><blockquote><p>图片来源 - 《Go Web编程》<br><img src="net-http标准库的各个组成部分.png" alt="服务计算-5-Go语言net-http源码解读"></p></blockquote><p>如何开始阅读源码，首先我们需要了解一下http包的执行流程:<br><img src="http包执行流程.png" alt="http包执行流程"></p><p>主要步骤:</p><ol><li>创建<code>Listen Socket</code>, 监听指定的端口, 等待客户端请求到来</li><li><code>Listen Socket</code>接受客户端的请求, 得到<code>Client Socket</code>, 接下来通过<code>Client Socket</code>与客户端通信</li><li>创建<code>go</code>线程服务一个连接，处理客户端的请求。 首先从<code>Client Socket</code>读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据。然后交给相应的<code>handler</code>处理请求, <code>handler</code>处理完毕准备好客户端需要的数据, 通过<code>Client Socket</code>写给客户端</li></ol><p>接下来主要通过源码分析服务端的具体实现流程。</p><h3 id="分析Http服务器的执行过程"><a href="#分析Http服务器的执行过程" class="headerlink" title="分析Http服务器的执行过程"></a>分析Http服务器的执行过程</h3><p><img src="http连接处理流程.png" alt="http连接处理流程"></p><h4 id="编写一个简单的服务器"><a href="#编写一个简单的服务器" class="headerlink" title="编写一个简单的服务器"></a>编写一个简单的服务器</h4><p>首先我们需要编写一个简单的服务器，然后逐步的对其中机制进行剖析，关于如何查看源码建议适用<code>VSCode</code>，<code>VSCode</code>安装相关包(<code>godef</code>等等)以后可以直接跳转到相关源码部分，当然也可以考虑直接去<a href="https://sourcegraph.com/github.com/golang/go/-/tree/src/net/http" target="_blank" rel="noopener">源码</a>逐步看。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/hello"</span>, sayHello)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(res, <span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h4><p>首先我们先分析<code>http.HandleFunc(&quot;/hello&quot;, sayHello)</code>，先查看一下源码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们又遇到问题了，<code>DefaultServeMux</code>是什么玩意。这时还是需要继续查看相关的源码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.RWMutex   <span class="comment">// 锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">m  <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry  <span class="comment">// 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式</span></span><br><span class="line">hosts <span class="keyword">bool</span> <span class="comment">// 是否在任意的规则中带有host信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">h        Handler <span class="comment">// 这个路由表达式对应哪个handler</span></span><br><span class="line">pattern  <span class="keyword">string</span>  <span class="comment">// 匹配字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewServeMux allocates and returns a new ServeMux.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServeMux</span><span class="params">()</span> *<span class="title">ServeMux</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(ServeMux) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure></p><p><code>ServeMux</code>结构体：HTTP请求的多路转接器（路由），它负责将每一个接收到的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。它内部用一个map来保存所有处理器Handler。</p><p><code>DefaultServeMux</code>，其实就是一个默认路由，是<code>ServeMux</code>的一个实例，使用包级别的<code>http.Handle()</code>、<code>http.HandleFunc()</code>方法注册处理器时都是注册到该路由中。我们来看看<code>DefaultServeMux.HandleFunc(pattern, handler)</code>中的<code>HandleFunc</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后只能继续看<code>Handle</code>方法的实现<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">mux.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">&#125;</span><br><span class="line">mux.m[pattern] = muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">mux.hosts = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码还是比较直观的，就是将相关信息加入到<code>map</code>中。</p><p>了解完路由信息的注册，我们还需要知道路由信息是如何分发的。</p><h4 id="监听端口、处理请求、路由分配"><a href="#监听端口、处理请求、路由分配" class="headerlink" title="监听端口、处理请求、路由分配"></a>监听端口、处理请求、路由分配</h4><p>服务器中<code>http.ListenAndServe()</code>方法启动服务。但是其究竟是如何实现的呢，我们需要参考下源码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先生成了一个<code>Server</code>对象，然后调用了它的<code>ListenAndServe</code>方法。Server对象封装了有关提供web服务相关的所有信息，是一个比较核心的类。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Server defines parameters for running an HTTP server.</span></span><br><span class="line"><span class="comment">// The zero value for Server is a valid configuration.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr    <span class="keyword">string</span>  <span class="comment">// TCP address to listen on, ":http" if empty</span></span><br><span class="line">Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TLSConfig optionally provides a TLS configuration for use</span></span><br><span class="line"><span class="comment">// by ServeTLS and ListenAndServeTLS. Note that this value is</span></span><br><span class="line"><span class="comment">// cloned by ServeTLS and ListenAndServeTLS, so it's not</span></span><br><span class="line"><span class="comment">// possible to modify the configuration with methods like</span></span><br><span class="line"><span class="comment">// tls.Config.SetSessionTicketKeys. To use</span></span><br><span class="line"><span class="comment">// SetSessionTicketKeys, use Server.Serve with a TLS Listener</span></span><br><span class="line"><span class="comment">// instead.</span></span><br><span class="line">TLSConfig *tls.Config</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadTimeout is the maximum duration for reading the entire</span></span><br><span class="line"><span class="comment">// request, including the body.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because ReadTimeout does not let Handlers make per-request</span></span><br><span class="line"><span class="comment">// decisions on each request body's acceptable deadline or</span></span><br><span class="line"><span class="comment">// upload rate, most users will prefer to use</span></span><br><span class="line"><span class="comment">// ReadHeaderTimeout. It is valid to use them both.</span></span><br><span class="line">ReadTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadHeaderTimeout is the amount of time allowed to read</span></span><br><span class="line"><span class="comment">// request headers. The connection's read deadline is reset</span></span><br><span class="line"><span class="comment">// after reading the headers and the Handler can decide what</span></span><br><span class="line"><span class="comment">// is considered too slow for the body.</span></span><br><span class="line">ReadHeaderTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteTimeout is the maximum duration before timing out</span></span><br><span class="line"><span class="comment">// writes of the response. It is reset whenever a new</span></span><br><span class="line"><span class="comment">// request's header is read. Like ReadTimeout, it does not</span></span><br><span class="line"><span class="comment">// let Handlers make decisions on a per-request basis.</span></span><br><span class="line">WriteTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdleTimeout is the maximum amount of time to wait for the</span></span><br><span class="line"><span class="comment">// next request when keep-alives are enabled. If IdleTimeout</span></span><br><span class="line"><span class="comment">// is zero, the value of ReadTimeout is used. If both are</span></span><br><span class="line"><span class="comment">// zero, ReadHeaderTimeout is used.</span></span><br><span class="line">IdleTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxHeaderBytes controls the maximum number of bytes the</span></span><br><span class="line"><span class="comment">// server will read parsing the request header's keys and</span></span><br><span class="line"><span class="comment">// values, including the request line. It does not limit the</span></span><br><span class="line"><span class="comment">// size of the request body.</span></span><br><span class="line"><span class="comment">// If zero, DefaultMaxHeaderBytes is used.</span></span><br><span class="line">MaxHeaderBytes <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TLSNextProto optionally specifies a function to take over</span></span><br><span class="line"><span class="comment">// ownership of the provided TLS connection when an NPN/ALPN</span></span><br><span class="line"><span class="comment">// protocol upgrade has occurred. The map key is the protocol</span></span><br><span class="line"><span class="comment">// name negotiated. The Handler argument should be used to</span></span><br><span class="line"><span class="comment">// handle HTTP requests and will initialize the Request's TLS</span></span><br><span class="line"><span class="comment">// and RemoteAddr if not already set. The connection is</span></span><br><span class="line"><span class="comment">// automatically closed when the function returns.</span></span><br><span class="line"><span class="comment">// If TLSNextProto is not nil, HTTP/2 support is not enabled</span></span><br><span class="line"><span class="comment">// automatically.</span></span><br><span class="line">TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ConnState</span> <span class="title">specifies</span> <span class="title">an</span> <span class="title">optional</span> <span class="title">callback</span> <span class="title">function</span> <span class="title">that</span> <span class="title">is</span></span></span><br><span class="line"><span class="function">// <span class="title">called</span> <span class="title">when</span> <span class="title">a</span> <span class="title">client</span> <span class="title">connection</span> <span class="title">changes</span> <span class="title">state</span>. <span class="title">See</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">// <span class="title">ConnState</span> <span class="title">type</span> <span class="title">and</span> <span class="title">associated</span> <span class="title">constants</span> <span class="title">for</span> <span class="title">details</span>.</span></span><br><span class="line"><span class="function"><span class="title">ConnState</span> <span class="title">func</span><span class="params">(net.Conn, ConnState)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ErrorLog</span> <span class="title">specifies</span> <span class="title">an</span> <span class="title">optional</span> <span class="title">logger</span> <span class="title">for</span> <span class="title">errors</span> <span class="title">accepting</span></span></span><br><span class="line"><span class="function">// <span class="title">connections</span>, <span class="title">unexpected</span> <span class="title">behavior</span> <span class="title">from</span> <span class="title">handlers</span>, <span class="title">and</span></span></span><br><span class="line"><span class="function">// <span class="title">underlying</span> <span class="title">FileSystem</span> <span class="title">errors</span>.</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">nil</span>, <span class="title">logging</span> <span class="title">is</span> <span class="title">done</span> <span class="title">via</span> <span class="title">the</span> <span class="title">log</span> <span class="title">package</span>'<span class="title">s</span> <span class="title">standard</span> <span class="title">logger</span>.</span></span><br><span class="line"><span class="function"><span class="title">ErrorLog</span> *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">disableKeepAlives</span> <span class="title">int32</span>     // <span class="title">accessed</span> <span class="title">atomically</span>.</span></span><br><span class="line">inShutdown        int32     // accessed atomically (non-zero means we're in Shutdown)</span><br><span class="line">nextProtoOnce     sync.Once <span class="comment">// guards setupHTTP2_* init</span></span><br><span class="line">nextProtoErr      error     <span class="comment">// result of http2.ConfigureServer if used</span></span><br><span class="line"></span><br><span class="line">mu         sync.Mutex</span><br><span class="line">listeners  <span class="keyword">map</span>[*net.Listener]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">activeConn <span class="keyword">map</span>[*conn]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">doneChan   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">onShutdown []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>再回到刚刚说到的<code>Server</code>对象调用它自己的<code>ListenAndServe</code>方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address srv.Addr and then</span></span><br><span class="line"><span class="comment">// calls Serve to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If srv.Addr is blank, ":http" is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error. After Shutdown or Close,</span></span><br><span class="line"><span class="comment">// the returned error is ErrServerClosed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line">addr := srv.Addr</span><br><span class="line"><span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">addr = <span class="string">":http"</span></span><br><span class="line">&#125;</span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ln</code>是一个监听<code>tcp</code>指定端口的监听器，接着把监听器<code>ln</code>断言转换为<code>TCPListener</code>类型，并根据它构造一个<code>tcpKeepAliveListener</code>对象并传递给<code>server.Serve()</code>方法。接着，我们再看看这个<code>Serve</code>方法的功能<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve accepts incoming connections on the Listener l, creating a</span></span><br><span class="line"><span class="comment">// new service goroutine for each. The service goroutines read requests and</span></span><br><span class="line"><span class="comment">// then call srv.Handler to reply to them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span></span><br><span class="line"><span class="comment">// connections and they were configured with "h2" in the TLS</span></span><br><span class="line"><span class="comment">// Config.NextProtos.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Serve always returns a non-nil error and closes l.</span></span><br><span class="line"><span class="comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">fn(srv, l) <span class="comment">// call hook with unwrapped listener</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l = &amp;onceCloseListener&#123;Listener: l&#125;</span><br><span class="line"><span class="keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !srv.trackListener(&amp;l, <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> srv.trackListener(&amp;l, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tempDelay time.Duration     <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rw, e := l.Accept()</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line"><span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tempDelay *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">tempDelay = max</span><br><span class="line">&#125;</span><br><span class="line">srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">time.Sleep(tempDelay)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">tempDelay = <span class="number">0</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line"><span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这一段我们从原作者的注释就可以了解到这个函数的功能，主要是为每个请求创建一个<code>goroutines</code>进行处理。首先调用<code>tcpKeepAliveListener</code>对象的<code>Accept()</code>方法返回一个连接<code>conn</code>，并为每一个<code>conn</code>创建一个新的<code>goroutines</code>执行<code>conn.server()</code>方法</p><blockquote><p>Go为了实现高并发和高性能, 使用了goroutines来处理Conn的读写事件, 这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。这是Go高效的保证。</p></blockquote><p><code>conn.server()</code>实现的功能比较复杂，还涉及到<code>net</code>模块。<code>conn.server()</code>主要读取请求，然后根据<code>conn</code>内保存的<code>server</code>来构造一个<code>serverHandler</code>类型，并调用它的<code>ServeHTTP()</code>方法：<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code>，该方法的源码如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">handler := sh.srv.Handler</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，如果没有指定路由，那么将会使用我们之前介绍的默认路由-<code>DefaultServeMux</code>，接着调用<code>handler</code>的<code>ServerHTTP</code>方法。这时我们将会遇到一个接口<code>Handler</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Handler</code>接口，所有请求的处理器、路由<code>ServeMux</code>都满足该接口。再如前文提到的。接着我们来看看<code>ServeHTTP</code>方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">&#125;</span><br><span class="line">w.WriteHeader(StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">h, _ := mux.Handler(r)</span><br><span class="line">h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>路由<code>ServeMux</code>的<code>ServeHTTP</code>方法中的<code>mux.Handler(r)</code>则会根据当前请求提供的信息来查找最匹配的<code>Handler</code>即路由，然后该路由调用自己处理请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The HandlerFunc type is an adapter to allow the use of</span></span><br><span class="line"><span class="comment">// ordinary functions as HTTP handlers. If f is a function</span></span><br><span class="line"><span class="comment">// with the appropriate signature, HandlerFunc(f) is a</span></span><br><span class="line"><span class="comment">// Handler that calls f.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>大致的流程如上分析，当然这只是一个比较粗劣的解析过程，详情还是需要不断的研读源码。关于<code>net</code>部分没有进行研究，以及对于比较精髓部分<code>conn</code>也没有详细介绍，接下来将会补上。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://sourcegraph.com/github.com/golang/go/-/tree/src/net/http" target="_blank" rel="noopener">Go源码</a></li><li><a href="https://www.cnblogs.com/zongjiang/p/6550319.html" target="_blank" rel="noopener">golang http server分析(一)</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.3.md" target="_blank" rel="noopener">Go如何使得Web工作</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景要提&quot;&gt;&lt;a href=&quot;#背景要提&quot; class=&quot;headerlink&quot; title=&quot;背景要提&quot;&gt;&lt;/a&gt;背景要提&lt;/h3&gt;&lt;p&gt;&lt;code&gt;net/http&lt;/code&gt;标准库可以分为客户端和服务器两个部分。以下是net/http标准库的各个组成部分的
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>134. Gas Station</title>
    <link href="http://yoursite.com/2018/11/15/134-Gas-Station/"/>
    <id>http://yoursite.com/2018/11/15/134-Gas-Station/</id>
    <published>2018-11-15T05:17:01.000Z</published>
    <updated>2018-11-15T05:18:27.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>There are N gas stations along a circular route, where the amount of gas at station i is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p><p><strong>Note:</strong></p><ul><li>If there exists a solution, it is guaranteed to be unique.</li><li>Both input arrays are non-empty and have the same length.</li><li>Each element in the input arrays is a non-negative integer.</li></ul><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 4. Your tank = 4 - 1 + 5 = 8</span><br><span class="line">Travel to station 0. Your tank = 8 - 2 + 1 = 7</span><br><span class="line">Travel to station 1. Your tank = 7 - 3 + 2 = 6</span><br><span class="line">Travel to station 2. Your tank = 6 - 4 + 3 = 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 0. Your tank = 4 - 3 + 2 = 3</span><br><span class="line">Travel to station 1. Your tank = 3 - 3 + 3 = 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这道题还是比较简单的，给出汽车行驶到每个点需要的油量<code>cost[i]</code>以及该点可以补充的油量<code>gas[i]</code>     ,求能否顺序走完一圈</li><li>首先整个行程的总代价<code>total</code>=<code>gas总和</code> - <code>cost总和</code>，如果<code>total</code>小于0，则整个行程不可能可以被完成，但是如果<code>total</code>大于0，则行程一定可以被完成。</li><li><code>preTank</code>记录从开始节点<code>i</code>到当前节点<code>j</code>所得代价<ul><li><code>preTank &lt; 0</code>，则说明不能顺利到达，因为<code>cost</code>比<code>gas</code>大，当然两个地点中间的任意一点也是不能顺利到达的，因为每次前进的<code>preTank</code>都需要大于等于0，此时需要把当前节点作为行程的节点，并且<code>preTank = gas[j] - cost[j]</code>。</li><li><code>preTank &gt;= 0</code>， <code>preTank += gas[j] - cost[j]</code>，继续前进。 </li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = gas.size();</span><br><span class="line">        <span class="keyword">int</span> preTank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(preTank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                preTank = gas[i] - cost[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                preTank += gas[i] - cost[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tank &gt;= <span class="number">0</span> ? start : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;There are N gas stations along a circular route, where the amount of g
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
