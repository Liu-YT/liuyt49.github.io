<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  <icon>https://www.gravatar.com/avatar/1e664c942599f0404df35da54598ea93</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-15T05:18:27.118Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>liuyt49</name>
    <email>1039868176@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>134. Gas Station</title>
    <link href="http://yoursite.com/2018/11/15/134-Gas-Station/"/>
    <id>http://yoursite.com/2018/11/15/134-Gas-Station/</id>
    <published>2018-11-15T05:17:01.000Z</published>
    <updated>2018-11-15T05:18:27.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>There are N gas stations along a circular route, where the amount of gas at station i is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p><p><strong>Note:</strong></p><ul><li>If there exists a solution, it is guaranteed to be unique.</li><li>Both input arrays are non-empty and have the same length.</li><li>Each element in the input arrays is a non-negative integer.</li></ul><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 4. Your tank = 4 - 1 + 5 = 8</span><br><span class="line">Travel to station 0. Your tank = 8 - 2 + 1 = 7</span><br><span class="line">Travel to station 1. Your tank = 7 - 3 + 2 = 6</span><br><span class="line">Travel to station 2. Your tank = 6 - 4 + 3 = 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 0. Your tank = 4 - 3 + 2 = 3</span><br><span class="line">Travel to station 1. Your tank = 3 - 3 + 3 = 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这道题还是比较简单的，给出汽车行驶到每个点需要的油量<code>cost[i]</code>以及该点可以补充的油量<code>gas[i]</code>     ,求能否顺序走完一圈</li><li>首先整个行程的总代价<code>total</code>=<code>gas总和</code> - <code>cost总和</code>，如果<code>total</code>小于0，则整个行程不可能可以被完成，但是如果<code>total</code>大于0，则行程一定可以被完成。</li><li><code>preTank</code>记录从开始节点<code>i</code>到当前节点<code>j</code>所得代价<ul><li><code>preTank &lt; 0</code>，则说明不能顺利到达，因为<code>cost</code>比<code>gas</code>大，当然两个地点中间的任意一点也是不能顺利到达的，因为每次前进的<code>preTank</code>都需要大于等于0，此时需要把当前节点作为行程的节点，并且<code>preTank = gas[j] - cost[j]</code>。</li><li><code>preTank &gt;= 0</code>， <code>preTank += gas[j] - cost[j]</code>，继续前进。 </li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = gas.size();</span><br><span class="line">        <span class="keyword">int</span> preTank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(preTank &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                preTank = gas[i] - cost[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                preTank += gas[i] - cost[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tank &gt;= <span class="number">0</span> ? start : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;There are N gas stations along a circular route, where the amount of g
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>207. Course Schedule II</title>
    <link href="http://yoursite.com/2018/11/15/207-Course-Schedule-II/"/>
    <id>http://yoursite.com/2018/11/15/207-Course-Schedule-II/</id>
    <published>2018-11-15T05:16:40.000Z</published>
    <updated>2018-11-15T05:21:41.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>There are a total of n courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of <code>prerequisite pairs</code>, return the ordering of courses you should take to finish all courses.</p><p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] .</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     </span><br><span class="line">                courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. </span><br><span class="line">                So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong>    </p><ul><li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="noopener">how a graph is represented</a>.</li><li>You may assume that there are no duplicate edges in the input prerequisites.</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这题与之前的<a href="https://liu-yt.github.io/2018/11/14/207-Course-Schedule/" target="_blank" rel="noopener">207. Course Schedule</a>题意差不多，只不过<code>Course Schedule</code>只需判断能否顺利修完课程，<code>Course Schedule ll</code>需要先判断能否修完，能修完需要返回一个选修的顺序，否则返回一个空的。</li><li>思路与上周介绍的实现相同，只是对代码进行优化。</li><li>具体步骤    <ul><li>建立邻接表，关系为后修过程，即每个课程存储需先修完该课程才能修的课程。同时得出每个课程的入度，即每个课程需要的先修课程的数目</li><li>将入度为0的课程加入队列中，同时将该课程邻接表存储的后修课程的入度减1，判断修改后的节点的度数是否为0，为0则加入队列中（注：每当节点加入到队列中，同时也加入到拓扑排序的数组中）</li><li>重复上述步骤，直到队列为空</li><li>判断数组与课程的数是否相等，相等则证明可以拓扑排序，否则证明存在未被加入的课程并且无法完成的课程（课程选修关系存在环）</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">int</span> inDegree[numCourses] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录课程需要先修课程的数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对应存储需要修完该课程才能修的课程</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : prerequisites) &#123;</span><br><span class="line">            inDegree[it.first]++;</span><br><span class="line">            myVec[it.second].push_back(it.first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                v.push_back(i);</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; myVec[tmp].size(); ++j) &#123;</span><br><span class="line">                    inDegree[myVec[tmp][j]]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[myVec[tmp][j]] == <span class="number">0</span>) &#123;</span><br><span class="line">                        v.push_back(myVec[tmp][j]);</span><br><span class="line">                        q.push(myVec[tmp][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v.size() == numCourses) </span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v.clear();</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20181016235724918?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsbGxseXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;There are a total of n courses you have to take, labeled from &lt;code&gt;0&lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>785. Is Graph Bipartite?</title>
    <link href="http://yoursite.com/2018/11/14/785-Is-Graph-Bipartite/"/>
    <id>http://yoursite.com/2018/11/14/785-Is-Graph-Bipartite/</id>
    <published>2018-11-14T03:28:31.000Z</published>
    <updated>2018-11-14T03:30:31.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p><p>Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p><p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists.  Each node is an integer between <code>0</code> and <code>graph.length - 1</code>.  There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn’t contain any element twice.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>graph will have length in range [1, 100].</li><li>graph[i] will contain integers in range [0, graph.length - 1].</li><li>graph[i] will not contain i or duplicate values.</li><li>The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题给了无向图的边，判断这个图是否是一个二分图</li><li>什么是二分图？<blockquote><p>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。孤立点可以任意划分在A或B集合。</p></blockquote></li><li>解法：<ul><li>使用<code>BFS + 染色法</code></li><li><code>BFS</code>以未被染色且非孤立点的点作为<code>BFS</code>搜索的起点</li><li>使用<code>染色法</code>，只使用两种颜色，将与该点相邻（存在一条边）且未被染色的点染成与其不同的颜色，假如相邻的点已被染色且颜色与该点相同，则证明该图不是二分图。</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 染色法 + BFS</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = graph.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> colors[num] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> visited[num] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i].size() &gt; <span class="number">0</span> &amp;&amp; visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// bfs</span></span><br><span class="line">                <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> top = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> i : graph[top]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">                            visited[i] = <span class="number">1</span>;</span><br><span class="line">                            colors[i] = !colors[top];</span><br><span class="line">                            q.push(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(colors[i] == colors[top])</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an undirected &lt;code&gt;graph&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt; if an
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>207. Course Schedule</title>
    <link href="http://yoursite.com/2018/11/14/207-Course-Schedule/"/>
    <id>http://yoursite.com/2018/11/14/207-Course-Schedule/</id>
    <published>2018-11-14T03:00:13.000Z</published>
    <updated>2018-11-14T03:27:11.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>There are a total of n courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">            To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">            To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong></p><ol><li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank" rel="noopener">how a graph is represented</a>.</li><li>You may assume that there are no duplicate edges in the input prerequisites.</li></ol><hr><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ul><li>题意比较容易理解，就是需要选修某一门课程的时候，需要先修某一门课程，给出一组课程的先修关系，问是否能完成课程。这个问题可以抽象为有向图求是否有环路问题，课程的先修关系是一个有向边，每一门课程就是一个点。</li><li>问题抽象成有向图求是否存在环路问题，思考有向图求存在环路的方法。</li></ul><h4 id="拓扑排序实现"><a href="#拓扑排序实现" class="headerlink" title="拓扑排序实现"></a>拓扑排序实现</h4><ul><li>什么是拓扑排序？<blockquote><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。    </p></blockquote></li><li>为什么用拓扑排序？<blockquote><p>如果能够用拓扑排序完成对图中所有节点的排序的话，就说明这个图中没有环，而如果不能完成，则说明有环</p></blockquote></li><li><p>怎样进行拓扑排序？</p><blockquote><ol><li>建立图的邻接表</li><li>然后找出入度数为0的点    </li><li>删除入度数为0的点，将其指这些点的边也删除，同时将这些点加入到结果队列中</li><li>重复2，直到没有点的入度为0</li><li>判断是否仍存在未被加入的点，若存在证明有环</li></ol></blockquote></li><li><p>当然本题不需要这么完整的步骤，不需要得到排序结果什么的，只需要最后判断下是否有环，然后返回<code>true</code>或者<code>false</code> </p></li><li>时间复杂度：$O(V+E)$</li></ul><h4 id="DFS实现"><a href="#DFS实现" class="headerlink" title="DFS实现"></a>DFS实现</h4><ul><li><a href="https://blog.csdn.net/xiangyaquan/article/details/48261949" target="_blank" rel="noopener">需要对DFS有一定深入的了解，了解树边，前向边等等</a></li><li><p>需要DFS稍加变化，来解决这个问题。解决的方法如下：</p><p>  图中的一个节点，根据其<code>vertexState[i]</code>的值，有三种状态：</p><blockquote><p><strong>点的状态</strong></p><ul><li>-1 - 已被访问过，正在访问其后代节点</li><li>0 - 未被访问过</li><li>1 - 已被访问过，且其子节点亦全部访问过</li></ul></blockquote><p>  按照这样的假设，当按照DFS进行搜索时，碰到一个节点时有三种可能：</p><blockquote><p>1、如果vertexState[V]=0，这是一个新的节点，未被访问过，进行dfs搜索<br>2、如果vertexState[V]=-1，说明是在访问该节点的后代的过程中访问到该节点本身，则图中有环。<br>3、如果vertexState[V]=1，该点已经被访问过，且以该点与其后代节点构成的一个子图是一个非强连通图，则遇到这类点不可能有环存在。</p></blockquote></li><li><p>时间复杂度：$O(V)$</p></li></ul><hr><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="解法1-拓扑排序"><a href="#解法1-拓扑排序" class="headerlink" title="解法1 - 拓扑排序"></a>解法1 - 拓扑排序</h4><ul><li><p>拓扑排序思路</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numCourses &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> n = numCourses;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : prerequisites)</span><br><span class="line">            myVec[it.first].insert(it.second);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(myVec[i].size() == <span class="number">0</span>)</span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            n -= size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numCourses; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == tmp)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(myVec[j].find(tmp) != myVec[j].end()) &#123;</span><br><span class="line">                        myVec[j].erase(myVec[j].find(tmp));</span><br><span class="line">                        <span class="keyword">if</span> (myVec[j].size() == <span class="number">0</span>) </span><br><span class="line">                            q.push(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  <img src="https://img-blog.csdn.net/20181012235802251?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsbGxseXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p></li><li><p>拓扑排序优化 — <a href="https://blog.csdn.net/lllllyt/article/details/83099470" target="_blank" rel="noopener">Course Schedule ll</a>中思路</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 1 优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inDegree[numCourses] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录课程需要先修课程的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对应存储需要修完该课程才能修的课程</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : prerequisites) &#123;</span><br><span class="line">            inDegree[it.first]++;</span><br><span class="line">            myVec[it.second].insert(it.first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            numCourses -= size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="comment">// 此处的引用很精髓！！！！</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : myVec[tmp]) &#123;</span><br><span class="line">                    inDegree[j]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.push(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>遍历节点度数时候使用引用传递<img src="https://img-blog.csdn.net/20181017102702105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsbGxseXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li><li><p>遍历节点度数时候使用值传递<img src="https://img-blog.csdn.net/20181017001036927?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsbGxseXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p></li><li><p><strong>引用传递</strong>：在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。<strong>值传递</strong>：形参是实参的拷贝，改变形参的值并不会影响外部实参的值，形参有自己独立的存储空间，每次都需要在栈中申请内存空间并且拷贝实参。因此，引用传递比值传递需要的操作时间小多了。</p></li></ul></li></ul><h4 id="解法2-DFS"><a href="#解法2-DFS" class="headerlink" title="解法2 - DFS"></a>解法2 - DFS</h4><ul><li><p>优化的DFS实现</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : prerequisites)</span><br><span class="line">            myVec[it.second].insert(it.first);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *点的状态</span></span><br><span class="line"><span class="comment">        * -1 - 已被访问过，正在访问其后代节点</span></span><br><span class="line"><span class="comment">        * 0 - 未被访问过</span></span><br><span class="line"><span class="comment">        * 1 - 已被访问过，且其子节点亦全部访问过</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> vertexState[numCourses] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i, myVec, vertexState))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; myVec, <span class="keyword">int</span> *vertexState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vertexState[node] == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        vertexState[node] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : myVec[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vertexState[i] == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i, myVec, vertexState))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vertexState[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  <img src="https://img-blog.csdn.net/20181012235652506?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsbGxseXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;There are a total of n courses you have to take, labeled from &lt;code&gt;0&lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>332. Reconstruct Itinerary</title>
    <link href="http://yoursite.com/2018/11/13/332-Reconstruct-Itinerary/"/>
    <id>http://yoursite.com/2018/11/13/332-Reconstruct-Itinerary/</id>
    <published>2018-11-13T11:39:46.000Z</published>
    <updated>2018-11-13T11:54:03.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p><p><strong>Note:</strong></p><ol><li><p>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].</p></li><li><p>All airports are represented by three capital letters (IATA code).</p></li></ol><ol><li>You may assume all tickets form at least one valid itinerary.</li></ol><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].But it is larger in lexical order.</span><br></pre></td></tr></table></figure></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题是关于图的边进行遍历，每张机票都是图的一条有向边，需要找出经过每条边的路径，并且必定有解本题，则对于某个节点（非起点）其只于一个节点相邻且只存在一条边，则这个节点必定是最后访问的，否则不可能遍历完所有边，并且这种点最多一个（不包含起点）。 </li></ul><h4 id="解法-1-—-DFS-递归"><a href="#解法-1-—-DFS-递归" class="headerlink" title="解法 1 —    DFS + 递归"></a>解法 1 —    <code>DFS + 递归</code></h4><ul><li>解决步骤<ul><li>将图建立起来，建立邻接表，使用<code>map&lt;string, multiset&lt;string&gt;</code> 来存储邻接表。使用multiset可以自动排序。（<code>set的默认排序由小到大，multiset默认排序是由大到小</code>）</li><li>从节点<code>JKF</code>开始DFS遍历，只要当前的映射集合<code>multiset</code>里面还有节点，则取出这个节点，递归遍历这个节点，同时需要将这个节点从<code>multiset</code>中删除掉，当映射集合<code>multiset</code>为空的时候，则将节点加入到结果中</li><li>因为当前存储结果是回溯得到的，需要将结果的存储顺序反转输出    </li></ul></li><li>实现代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; tickets) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; &gt; myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tickets)</span><br><span class="line">            myMap[it.first].insert(it.second);</span><br><span class="line"></span><br><span class="line">        dfs(<span class="string">"JFK"</span>, v, myMap);</span><br><span class="line">        reverse(v.begin(), v.end());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(myMap[start].size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> next = *myMap[start].begin();</span><br><span class="line">            myMap[start].erase(myMap[start].begin());</span><br><span class="line">            dfs(next, v, myMap);</span><br><span class="line">        &#125;</span><br><span class="line">        v.push_back(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解法-2-—-DFS-迭代"><a href="#解法-2-—-DFS-迭代" class="headerlink" title="解法 2 — DFS + 迭代"></a>解法 2 — <code>DFS + 迭代</code></h4><ul><li>思路与解法一相同，利用数据结构<code>stack</code>进行迭代。</li><li>实现代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; tickets) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; &gt; myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tickets)</span><br><span class="line">            myMap[it.first].insert(it.second);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; myStack;</span><br><span class="line">        myStack.push(<span class="string">"JFK"</span>);</span><br><span class="line">        <span class="keyword">while</span>(!myStack.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> node = myStack.top();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!myMap[node].size()) &#123;</span><br><span class="line">                myStack.pop();</span><br><span class="line">                v.push_back(node);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                myStack.push(*myMap[node].begin());</span><br><span class="line">                myMap[node].erase(myMap[node].begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(v.begin(), v.end());</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a list of airline tickets represented by pairs of departure and 
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>310. Minimum Height Trees</title>
    <link href="http://yoursite.com/2018/11/13/310-Minimum-Height-Trees/"/>
    <id>http://yoursite.com/2018/11/13/310-Minimum-Height-Trees/</id>
    <published>2018-11-13T11:37:52.000Z</published>
    <updated>2018-11-13T11:47:16.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p></li><li><p><strong>Format</strong></p><ol><li><p>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number n and a list of undirected <code>edges</code> (each edge is a pair of labels).</p></li><li><p>You can assume that no duplicate <code>edges</code> will appear in edges. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p></li></ol></li><li><p>Example 1 :</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]</span><br><span class="line"></span><br><span class="line">        0</span><br><span class="line">        |</span><br><span class="line">        1</span><br><span class="line">       / \</span><br><span class="line">      2   3 </span><br><span class="line"></span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></li><li><p>Example 2 :</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span><br><span class="line"></span><br><span class="line">     0  1  2</span><br><span class="line">      \ | /</span><br><span class="line">        3</span><br><span class="line">        |</span><br><span class="line">        4</span><br><span class="line">        |</span><br><span class="line">        5 </span><br><span class="line"></span><br><span class="line">Output: [3, 4]</span><br></pre></td></tr></table></figure></li><li><p><strong>Note:</strong></p><ul><li>According to <a href="https://en.wikipedia.org/wiki/Tree_%28graph_theory%29" target="_blank" rel="noopener">the definition of tree on Wikipedia</a>: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</li><li>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</li></ul></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="解法1-暴力破解-超时，Failed"><a href="#解法1-暴力破解-超时，Failed" class="headerlink" title="解法1 - 暴力破解(超时，Failed)"></a>解法1 - <strong>暴力破解</strong>(<code>超时</code>，<code>Failed</code>)</h4><ul><li>步骤<ul><li>以每个节点都为根，对每个节点使用BFS遍历得到以该节点为根时树的高度</li><li>比较各个节点时树的高度，得到<code>Minimum Height Trees</code>的根节点</li></ul></li><li><p>代码</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> edgesArray[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> height[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            height[i] = getHeight(n, i, edges);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最小高度树的根节点</span></span><br><span class="line">        <span class="keyword">int</span> min = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; min) &#123;</span><br><span class="line">            min = height[i];</span><br><span class="line">            v.clear();</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(height[i] == min) &#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> visited[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        visited[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = edges.begin(); iter != edges.end(); iter++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*iter).first == tmp || (*iter).second == tmp) &#123;</span><br><span class="line">            <span class="keyword">int</span> newNode = (*iter).first + (*iter).second - tmp;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[newNode]) &#123;</span><br><span class="line">                            depth[newNode] = depth[tmp] + <span class="number">1</span>;</span><br><span class="line">                            q.push(newNode);</span><br><span class="line">                            visited[newNode] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[i] &gt; max)</span><br><span class="line">                max = depth[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>复杂度 — $O(V^2E)$ (<code>V</code>表示节点数量，<code>E</code>表示边的数量)</p></li><li>结果果然超时了<br>  <img src="https://img-blog.csdn.net/20180930180539280?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsbGxseXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></li><li><p>改进与优化</p><ul><li>可以利用map数据结构，来存储每个节点对应其连接的节点所组成的一个映射<code>map&lt;int, vector&lt;int&gt; &gt;</code>，或者一个二维数组</li><li>复杂度 — $O(VE)$ (<code>V</code>表示节点数量，<code>E</code>表示边的数量)</li><li><p>优化的代码            </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; myMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> height[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = edges.begin(); iter != edges.end(); iter++) &#123;</span><br><span class="line">            myMap[(*iter).first].push_back((*iter).second);</span><br><span class="line">            myMap[(*iter).second].push_back((*iter).first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            height[i] = getHeight(n, i, myMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找最小高度树的根节点</span></span><br><span class="line">        <span class="keyword">int</span> min = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; min) &#123;</span><br><span class="line">                    min = height[i];</span><br><span class="line">            v.clear();</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(height[i] == min) &#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> root, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> visited[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        visited[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter = myMap[tmp].begin(); iter != myMap[tmp].end(); iter++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[(*iter)]) &#123;</span><br><span class="line">                    depth[(*iter)] = depth[tmp] + <span class="number">1</span>;</span><br><span class="line">                    q.push((*iter));</span><br><span class="line">                    visited[(*iter)] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[i] &gt; max)</span><br><span class="line">                max = depth[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>但是依旧超时<br><img src="https://img-blog.csdn.net/20180930210721360?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xsbGxseXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="思考提示：How-many-MHTs-can-a-graph-have-at-most"><a href="#思考提示：How-many-MHTs-can-a-graph-have-at-most" class="headerlink" title="思考提示：How many MHTs can a graph have at most?"></a>思考提示：<strong>How many MHTs can a graph have at most?</strong></h4><ul><li>每个树最多有两个MHTs。假如有三个或多个可以作为MHTs的根节点，根据树的定义，每两个节点都可以找到一条路径连接起来，树是一个强连通的图，不存在简单环，则至少一个一个或多个比其余节点高，则大于三个MHTs不成立。</li></ul><h4 id="解法2-—-类剥洋葱求解-AC"><a href="#解法2-—-类剥洋葱求解-AC" class="headerlink" title="解法2 — 类剥洋葱求解(AC)"></a>解法2 — <strong>类剥洋葱求解</strong>(<code>AC</code>)</h4><ul><li>本方法学习自其他优秀解法</li><li>步骤<ol><li>建立一个映射表，记录每一个点与其直接相连的点</li><li>将树的叶节点（度为1的节点）加入一个队列中</li><li>假如当前队列中存储的节点数<strong>小于等于2</strong>，则退出循环。否则遍历队列中的每个节点。对每个节点，将其弹出队列，同时将与其相连节点的集合中将该节点删去，如果删完该节点后此节点也变成一个叶节点（度数为1），那么将这个节点加入队列中。</li></ol></li><li>时间复杂度 — $O(n)$</li><li>实现代码  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; myVec(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge : edges) &#123;</span><br><span class="line">            myVec[edge.first].insert(edge.second);</span><br><span class="line">            myVec[edge.second].insert(edge.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(myVec[i].size() == <span class="number">1</span>)</span><br><span class="line">                q.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            n -= size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it : myVec[tmp]) &#123;</span><br><span class="line">                    myVec[it].erase(tmp);</span><br><span class="line">                    <span class="keyword">if</span> (myVec[it].size() == <span class="number">1</span>) q.push(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            ans.push_back(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For a undirected graph with tree characteristics, we can choo
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>64. Minimum Path Sum</title>
    <link href="http://yoursite.com/2018/11/12/64-Minimum-Path-Sum/"/>
    <id>http://yoursite.com/2018/11/12/64-Minimum-Path-Sum/</id>
    <published>2018-11-12T02:06:58.000Z</published>
    <updated>2018-11-12T02:15:55.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p></li><li><p><strong>Note:</strong> You can only move either down or right at any point in time.</p></li><li><p><strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">    [1,3,1],</span><br><span class="line">    [1,5,1],</span><br><span class="line">    [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题比较简单，题意是寻找m x n格中左上角到右下角路径的最小距离，并且没有负权值</li><li><code>dp[i][j]:起点到点 [i,j]的最小距离</code></li><li>因为没有负路径和寻路方向只能向下或者向右，因此对于每个点(除起点)，其<code>dp[i][j]</code>的表示为    <code>dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]</code></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Given a m x n grid filled with non-negative numbers, find a p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>50. Pow(x, n)</title>
    <link href="http://yoursite.com/2018/11/12/50-Pow-x-n/"/>
    <id>http://yoursite.com/2018/11/12/50-Pow-x-n/</id>
    <published>2018-11-12T02:06:40.000Z</published>
    <updated>2018-11-12T02:17:15.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Implement pow(x, n), which calculates x raised to the power n (xn).</p><ul><li><p>Example 1:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure></li><li><p>Example 2:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure></li><li><p>Example 3:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure></li></ul><p><strong>Note:</strong></p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n is a 32-bit signed integer, within the range [$−2^{31}$, $2^{31}$ − 1]     </li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="解法-1-—-暴力破解（Failed）"><a href="#解法-1-—-暴力破解（Failed）" class="headerlink" title="解法 1 — 暴力破解（Failed）"></a>解法 1 — <strong>暴力破解</strong>（<code>Failed</code>）</h4><ul><li>将n的值分为<code>n&gt;0</code>,<code>n&lt;0</code>,<code>n=0</code>三种情况</li><li>递归算出结果</li><li><p>实现代码        </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一 暴力破解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(n); ++i) &#123;</span><br><span class="line">            result *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? result : <span class="number">1</span> / result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>这种做法测试后果然不能<code>AC</code>，错误分析</p><ul><li><p>时间$O(n)$，当n很大时，超时</p></li><li><p>未考虑边界条件<code>n =INT_MIN</code>，这个时候<code>-n</code>赋不进<code>n</code></p></li></ul></li></ul><h4 id="解法-2-—-分治（AC）"><a href="#解法-2-—-分治（AC）" class="headerlink" title="解法 2 — 分治（AC）"></a>解法 2 — <strong>分治</strong>（<code>AC</code>）</h4><ul><li><p>超时问题解决</p><ul><li>将$x^n$分解为$x^{n/2} <em> x^{n/2} </em>  x^{n\%2}$递归求解</li><li>时间复杂度$O(logn)$</li></ul></li><li><p>边界越界问题解决</p><ul><li>n = $-2^{31}$时，通过简单的<code>-n</code>来求其相反数将导致溢出，最大正整数为$2^{31}-1$</li><li>对于<code>n&lt;0</code>的情况，令$n’ = -(n+1)$ 。求$x^n$等价于求 $1 / (x^{n’}*x)$</li></ul></li><li>实现代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法二 分治 + 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 越处理--粗糙版</span></span><br><span class="line">            <span class="comment">// x = 1.0 / x;</span></span><br><span class="line">            <span class="comment">// if(n == INT_MIN)</span></span><br><span class="line">            <span class="comment">// return x * myPow(x, -1* (n+1));</span></span><br><span class="line">            <span class="comment">// else</span></span><br><span class="line">            <span class="comment">// return myPow(x, -1 * n);</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 越界处理--精简版 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / (x * myPow(x, <span class="number">-1</span> * (n+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> tmp = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span>  == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> tmp * tmp;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> tmp * tmp * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Implement pow(x, n), which calculates x raised to the power n (xn).&lt;/p
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>22. Generate Parentheses</title>
    <link href="http://yoursite.com/2018/11/11/22-Generate-Parentheses/"/>
    <id>http://yoursite.com/2018/11/11/22-Generate-Parentheses/</id>
    <published>2018-11-11T07:24:31.000Z</published>
    <updated>2018-11-11T07:28:51.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br>For example, given n = 3, a solution set is:      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;((()))&quot;,</span><br><span class="line">    &quot;(()())&quot;,</span><br><span class="line">    &quot;(())()&quot;,</span><br><span class="line">    &quot;()(())&quot;,</span><br><span class="line">    &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题是利用溯源算法去解决的，穷举出每一种可能性，把所有成功的解都返回解空间。<ul><li>本题利用递归和DFS进行解决，其中重点是找到递归的传递关系，在理解递归的时候只需将其理解成一个黑盒子，考虑其中的效果</li><li>递归的思路<ul><li>回归条件  ：<code>当左右括号加起来等于2n的时候</code></li><li>选择条件1：<code>当左括号的数量小于n的时候</code></li><li>递归关系1：<code>左括号的数量加1</code></li><li>选择条件2：<code>当右括号的数量小于左括号的数量的时候</code> </li><li>递归关系2：<code>右括号的数量加1</code></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        dfs(str, <span class="number">0</span>, <span class="number">0</span>, n, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> buildStr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left + right == <span class="number">2</span> * n) &#123;</span><br><span class="line">            v.push_back(<span class="built_in">string</span>(buildStr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &lt; n) &#123;</span><br><span class="line">            dfs(buildStr + <span class="string">"("</span>, left + <span class="number">1</span>, right, n, v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &lt; left) &#123;</span><br><span class="line">            dfs(buildStr + <span class="string">")"</span>, left, right + <span class="number">1</span>, n, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given n pairs of parentheses, write a function to generate all c
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>5. Longest Palindromic Substring</title>
    <link href="http://yoursite.com/2018/11/11/5-Longest-Palindromic-Substring/"/>
    <id>http://yoursite.com/2018/11/11/5-Longest-Palindromic-Substring/</id>
    <published>2018-11-11T07:00:51.000Z</published>
    <updated>2018-11-11T07:30:39.519Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</li><li><strong>Example</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>这道题要求我们找出一个字符串里面的最长回文串，而什么是回文串呢，回文串就是正反读都是一样的字符串。对于这个问题，解决方法就是找一个字符，以其为中心，向两边扩展寻找出最长的回文串，该算法的时间复杂度为$O(n)$,当然还需要注意一点的就是回文串的长度可奇可偶，如长度为奇数的回文串”aba”以及长度为偶数的回文串”baab”，因此在以某个字符为中心的向两边扩展的需要额外的考虑。</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i+<span class="number">1</span>]) </span><br><span class="line">                searchLongestPalindrome(i, i+<span class="number">1</span>, id, len, s);</span><br><span class="line">            searchLongestPalindrome(i, i, id, len, s);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> s.substr(id, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">searchLongestPalindrome</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> &amp;id, <span class="keyword">int</span> &amp;len, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = right - left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt;= len) &#123;</span><br><span class="line">            id = left + <span class="number">1</span>;</span><br><span class="line">            len = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h3><ul><li>对于解决回文子串问题，有一种更加高效的算法，<code>拉车算法(Manacher‘s Algorithm)</code>是用来查找一个字符串的最长回文子串的线性方法，其时间复杂度仅为$O(n)$<ul><li>此方法是学习其他博客的解法<ul><li><a href="https://blog.csdn.net/Form_/article/details/79766986" target="_blank" rel="noopener">参考博客1</a></li><li><a href="http://www.cnblogs.com/grandyang/p/4475985.html" target="_blank" rel="noopener">参考博客2</a></li></ul></li><li>更优解法实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 解法二 Manacher Algorithm 马拉车算法 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) </span><br><span class="line">            str = str + s[i] + <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">-1</span>;    <span class="comment">// 最长回文子串的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxId = <span class="number">-1</span>;    <span class="comment">// 最长回文子串中心点的位置</span></span><br><span class="line">        <span class="keyword">int</span> p[str.size()] = &#123;&#125;; <span class="comment">// 记录当前为起点回文串的长度</span></span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>, mx = <span class="number">0</span>; <span class="comment">// id为已知的最大回文子串中心的位置，mx是已知最大回文串的右边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; mx)</span><br><span class="line">                p[i] = min(p[<span class="number">2</span> * id - i], mx - i);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                p[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(str[i - p[i]] == str[i + p[i]])</span><br><span class="line">                p[i]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx)这句代码，从而提高效率</span></span><br><span class="line">            <span class="keyword">if</span>(mx &lt; i + p[i]) &#123;</span><br><span class="line">                id = i;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p[i] - <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                maxLen = p[i] <span class="number">-1</span>;</span><br><span class="line">                maxId = i;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = (maxId - maxLen - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 将最长回文子串起始位置转换回原串</span></span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given a string s, find the longest palindromic substring in s. Y
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>41. First Missing Positive</title>
    <link href="http://yoursite.com/2018/11/10/41-First-Missing-Positive/"/>
    <id>http://yoursite.com/2018/11/10/41-First-Missing-Positive/</id>
    <published>2018-11-10T01:54:02.000Z</published>
    <updated>2018-11-10T01:58:59.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given an unsorted integer array, find the smallest missing positive integer.</li><li><p><strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></li><li><p><strong>Note:</strong> Your algorithm should run in O(n) time and uses constant extra space.</p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题的题意比较容易理解，即寻找一个无序的数组里面找到一个最小缺失的正整数</li><li>第一想法是将无序数组进行排序，然后遍历一遍排好序的数组即可找出最小缺失的正整数，但是排序算法最优解的时间复杂度都为O(nlogn)，显然不能满足题目的时间复杂度要求</li><li>其次的主要想法就是利用数组的下标，因为下标是从0开始的，不断累增的数列，并且除0外都是正整数<ul><li>遍历数组，将当前元素交换到其减一后作为下标的位置，即<code>nums[i]</code>与<code>nums[nums[i] - 1]</code>进行交换，即将<code>1</code>放到数组<code>0</code>号位，将<code>2</code>放到数组<code>1</code>号位，依此类推。这个步骤比较关键，其中小坑也比较多，有些是提交了才发现的<ul><li>交换条件的选择，可能被交换的元素必须要满足<code>&gt; 0</code>&amp;&amp;<code>&lt; array.size</code>&amp;&amp;<code>nums[i] != nums[nums[i] - 1]</code>,其中最后一个条件是避免两个位置不断的执行交换，例如输入[1,1]的情况，造成死循环</li><li>循环变量的控制，当需要交换的时候需要将循环变量-1，或者说不发生交换的时候，循环变量+1</li></ul></li><li>再次遍历数组，将第一个下标 与对应位置元素 - 1不等的下标返回，若都相等，则返回<code>数组的size</code> + 1</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minPos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将满足条件的的元素进行交换，将元素放到数组下标等于该元素的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; size &amp;&amp; nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，寻找下标与对应位置不等的下标，此下标即为最小整数，否则则为size+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) </span><br><span class="line">            <span class="keyword">if</span>(i != nums[i] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given an unsorted integer array, find the smallest missing posit
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>8. String to Integer (atoi)</title>
    <link href="http://yoursite.com/2018/11/10/8-String-to-Integer-atoi/"/>
    <id>http://yoursite.com/2018/11/10/8-String-to-Integer-atoi/</id>
    <published>2018-11-10T01:49:29.000Z</published>
    <updated>2018-11-10T01:52:14.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p><strong>Note:</strong></p><ul><li>Only the space character<code>&#39; &#39;</code> is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [$−2^{31}$,  $2^{31}$ − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.</li></ul><p><strong>Example:</strong></p><blockquote><p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p><p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer.Thefore INT_MIN (−2^31) is returned.</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题就是相当于重写atoi这个函数，将字符串转化成整数</li><li>本题需要注意的点<ul><li>将字符串前面的空白去掉</li><li>数字的正负</li><li>数字溢出</li><li>输入无效</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">// 返回的数字</span></span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>; <span class="comment">// 返回数字的符号</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str[i] == <span class="string">' '</span>) &#123; ++i; &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; str.length &amp;&amp; (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)) &#123;</span><br><span class="line">        sign = str[i] == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span> &amp;&amp; i &lt; str.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; INT_MAX / <span class="number">10</span> || (ans == INT_MAX / <span class="number">10</span>  &amp;&amp; str[i] &gt; <span class="string">'7'</span>))</span><br><span class="line">            <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">        ans = ans * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;
&lt;p&gt;The funct
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <link href="http://yoursite.com/2018/11/09/3-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://yoursite.com/2018/11/09/3-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2018-11-09T07:13:22.000Z</published>
    <updated>2018-11-09T07:15:19.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given a string, find the length of the longest substring without repeating characters.</li><li>Example   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题目的是得到字符串里面没有重复字符的最长子串的长度，一开始首先想到的就是两个嵌套的循环，通过暴力破解，寻找每个字符开头的最大字串，时间复杂度比较高，为O(n^2)。</li><li>通过与别人讨论得到一定的启发，从头开始遍历字符，类似滑窗思想来解决本题<ul><li>利用一个数组来判断字符是否已经在子串中，其中字符的ASCII值作为数组的下标，其在字符串中的下标则存储在数组相应下标指向的位置</li><li>假设当遇到一个字符‘a’已经出现当前子串中，则从该子串中的’a’的前一个字符继续当前子串的扩展，新的子串的初始长度为<code>i[第二个&#39;a&#39;的下标]-重复字符的下标[第一个&#39;a&#39;的下标]</code></li><li>时间复杂度 O(n)</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;  <span class="comment">// 记录最长字串的长度</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;        <span class="comment">// 遍历字符串时候记录当前字串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[s[i]] == <span class="number">-1</span>) </span><br><span class="line">            ++tmp;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">128</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[s[i]])</span><br><span class="line">                    <span class="built_in">array</span>[j] = <span class="number">-1</span>;</span><br><span class="line">            tmp = i - <span class="built_in">array</span>[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        maxLength = maxLength &gt; tmp ? maxLength : tmp;</span><br><span class="line">        <span class="built_in">array</span>[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given a string, find the length of the longest substring without
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>67. Add Binary</title>
    <link href="http://yoursite.com/2018/11/09/67-Add-Binary/"/>
    <id>http://yoursite.com/2018/11/09/67-Add-Binary/</id>
    <published>2018-11-09T07:07:30.000Z</published>
    <updated>2018-11-09T07:10:35.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>Given two binary strings, return their sum (also a binary string).</li><li>The input strings are both non-empty and contains only characters 1 or 0.</li></ul><blockquote><p>example<br>Input: a = “11”, b = “1”<br>Output: “100”</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>二进制的高精度加法，对字符对应数字从低位逐位的相加，同时加上低位相加得到的进位，不断计算得到新的进位以及相加的结果，最后得到结果。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制高精度加法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>; <span class="comment">// 答案字符串</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            ans += (a[i] - <span class="string">'0'</span> + b[j] - <span class="string">'0'</span> + carry) % <span class="number">2</span> + <span class="string">'0'</span>;</span><br><span class="line">            carry = a[i] - <span class="string">'0'</span> + b[j] - <span class="string">'0'</span> + carry &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a.length() &gt;= b.length()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                ans += (a[i] - <span class="string">'0'</span> + carry) % <span class="number">2</span> + <span class="string">'0'</span>;</span><br><span class="line">                carry = a[i] - <span class="string">'0'</span> + carry &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                ans += (b[j] - <span class="string">'0'</span> + carry) % <span class="number">2</span> + <span class="string">'0'</span>;</span><br><span class="line">                carry = b[j] - <span class="string">'0'</span> + carry &gt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            ans += carry + <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">        reverse(ans.begin(), ans.end()); </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Given two binary strings, return their sum (also a binary string
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>1. Two Sum</title>
    <link href="http://yoursite.com/2018/11/09/1-Two-Sum/"/>
    <id>http://yoursite.com/2018/11/09/1-Two-Sum/</id>
    <published>2018-11-09T06:43:50.000Z</published>
    <updated>2018-11-09T07:05:29.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><blockquote><p>Example:<br>    Given nums = [2, 7, 11, 15], target = 9,<br>   Because nums[0] + nums[1] = 2 + 7 = 9,     return [0, 1].</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>暴力破解，遍历每个元素x并查找是否有另一个值等于target - x。</li><li>时间复杂度为 $O(n^2)$</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target - nums[i] == nums[j]) &#123;</span><br><span class="line">                    ans.push_back(i);</span><br><span class="line">                    ans.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="更优解法"><a href="#更优解法" class="headerlink" title="更优解法"></a>更优解法</h3><ul><li>这个是看了答案发现的，利用map的查找，节省时间。</li><li>时间复杂度为 $O(nlogn)$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(myMap.count(target - nums[i])) &#123;</span><br><span class="line">                ans.push_back(myMap.find(target - nums[i])-&gt;second);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                myMap.insert(make_pair(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such tha
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>区块链基础问答</title>
    <link href="http://yoursite.com/2018/11/08/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E9%97%AE%E7%AD%94/"/>
    <id>http://yoursite.com/2018/11/08/区块链基础问答/</id>
    <published>2018-11-08T11:44:34.000Z</published>
    <updated>2018-11-08T11:45:29.452Z</updated>
    
    <content type="html"><![CDATA[<ul><li>问题1：为什么要有stateRoot?<br>stateRoot是存储整个系统状态的专用Merkle树的根哈希（所有帐户余额，合同存储，合同代码和帐户nonces都在里面）。其方便节点间状态的互相验证，保证在交易的每个区块（每时每刻），所有节点的状态是一致的。</li></ul><ul><li><p>问题2：nonce值有什么用?</p><ul><li>区块中的nonce值：在挖矿中使用，挖矿时需要添加的nonce(随机数)，通过不断修改该值用来计算得到满足要求的哈希值，最后找到一个可以满足要求的nonce值。为了证明工作量的无意义的值，这是挖矿的本质，这个值决定挖矿的难度。</li><li>交易中的nonce值：交易发起者（from账户）发出交易的次数, 同一账户的交易会被依次确认。要求一个账户的每笔交易有一个连续的计数，并且每个节点将根据计数顺序严格执行来自一个用户的交易。作用：<ol><li>确认交易顺序。连续的计数，根据计数顺序严格执行来自一个用户的交易。</li><li>防止双花。交易必须顺序执行每一笔交易被确定的时候，必须前面的交易也已经被确定。</li><li>撤销pending中的交易。使用同样的 nonce 值，重新发送一笔交易，但是使用更高的 Gas 价格，并把转帐金额设为 0，目标地址可以设为自己的发送地址，就是说发送地址和目标地址相同，当然使用原来的地址也没问题</li><li>确定生成的合约地址。新合约地址由此合约账户的地址和nonce确定。</li></ol></li></ul></li><li><p>问题3：Hyperledger Fabric的特点，和Composer的关系?</p><ul><li><p>Hyperledger Fabric的特点</p><ul><li>Hyperledger Fabric是私有和许可业务网络的开源框架实现，其中成员身份和角色为其他成员所知。HyperLedger Fabric是私有的，而且是被许可的，是与其它区块链系统最大的不同点之一。但并不允许未知身份来参与HyperLedger Fabric网络（要求协议验证事务并确保网络的安全），HyperLedger Fabric组织的成员可以通过一个Membership Service Provider（成员服务提供者即MSP）来注册。</li><li>同时其被设计为开发具有模块化架构的解决方案的基础。它允许组件（如账本数据库，共识机制和成员服务）即插即用。同时，它利用容器技术，提供企业级网络安全性，可扩展性和机密性。Hyperledger Fabric提供了一个独特的可伸缩、可扩展的架构，这也是Hyperledger Fabric与其他区块链解决方案的显著区别。</li></ul></li><li><p>Hyperledger Fabric和Hyperledger Composer的关系 </p><p>Hyperledger Fabric和Hyperledger Composer都属于Hyperledger项目。Hyperledger Composer是一组基于 JavaScript 的工具，可简化并加速 Hyperledger Fabric 区块链应用的创建过程。通过使用 Hyperledger Composer，业务所有者和开发人员可以快速创建链码（业务逻辑）和区块链应用。两者都可以用于实现区块链解决方案，但是使用的抽象级别，工具和语言是完全不同的。Hyperledger Composer原本是为了抽象出接口,可以和任何区块链网络对联,但目前的开发状况基本上是基于Hyperledger Fabric来实现的。。在内部，Composer API映射到底层Fabric API - 该映射过程由Composer运行时管理，它可以提供一系列简化应用程序开发的服务。</p></li></ul></li><li><p>问题4：联盟链智能合约 和 中心账本的区别？</p><p>联盟区块链是指其共识过程受到预选节点控制的区块链，写入参与者被提前筛选，读写权限由被选定的参与者们决定，因此联盟链被视为“部分去中心化”。联盟链智能合约即在联盟链上部署智能合约，其将合约以代码的形式实现，具有可溯源，自动执行，安全透明，无法篡改，违约者必受惩罚的特点。联盟链智能合约的信任来自于不可篡改的代码和区块链的去中心化特性，不依赖于任何中心化机构。中心化账本以中心化机构为信任背书，出错难以追溯，数据可以被篡改。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;问题1：为什么要有stateRoot?&lt;br&gt;stateRoot是存储整个系统状态的专用Merkle树的根哈希（所有帐户余额，合同存储，合同代码和帐户nonces都在里面）。其方便节点间状态的互相验证，保证在交易的每个区块（每时每刻），所有节点的状态是一致的。&lt;
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 4 持续集成服务 Travis CI</title>
    <link href="http://yoursite.com/2018/11/08/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-4-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9C%8D%E5%8A%A1-Travis-CI/"/>
    <id>http://yoursite.com/2018/11/08/服务计算-4-持续集成服务-Travis-CI/</id>
    <published>2018-11-08T06:28:51.000Z</published>
    <updated>2018-11-13T12:14:53.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是持续集成服务"><a href="#什么是持续集成服务" class="headerlink" title="什么是持续集成服务"></a>什么是持续集成服务</h2><blockquote><p>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。<br>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码”集成”到主干。<br>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p></blockquote><h2 id="创建一个简单的含测试的go项目"><a href="#创建一个简单的含测试的go项目" class="headerlink" title="创建一个简单的含测试的go项目"></a>创建一个简单的含测试的go项目</h2><pre><code>Travis CI 只支持 Github，不支持其他代码托管服务。</code></pre><ul><li>测试项目： <a href="https://github.com/Liu-YT/Hello-Go" target="_blank" rel="noopener">Hello-Go</a></li><li><code>README.md</code>包含详细的创建过程</li><li>Go test 测试结果<br><img src="/2018/11/08/服务计算-4-持续集成服务-Travis-CI/1.png" alt=""></li></ul><h2 id="Travis-CI的使用"><a href="#Travis-CI的使用" class="headerlink" title="Travis CI的使用"></a>Travis CI的使用</h2><ol><li>打开 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>，使用你的 Github 账号登录后它会同步你的仓库</li><li>找到你的 <code>Hello-Go</code> 仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。<br><img src="/2018/11/08/服务计算-4-持续集成服务-Travis-CI/2.png" alt=""></li><li><p><code>Travis</code> 要求项目的根目录下面，必须有一个<code>.travis.yml</code>文件。这是配置文件，指定了<code>Travis</code>的行为。该文件必须保存在 Github 仓库里面，一旦代码仓库有新的 Commit，Travis 就会去找这个文件，执行里面的命令。在仓库的根目录添加.travis.yml文件，如下：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">go</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span></span><br><span class="line"><span class="attr">go:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">1.11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">go</span> <span class="string">get</span> <span class="bullet">-v</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>git</code> 完成一次提交</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br><span class="line">git commit -m &quot;CI&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>接着点击 <code>travis</code> 上 <code>Hello-Go</code>，可以看见由于提交触发的构建过程:</p><p> <img src="/2018/11/08/服务计算-4-持续集成服务-Travis-CI/3.png" alt="3"><br> 可以看到提交触发的构建过程，所以我们每次可以不用在本地上测试了，只需要提交然后然系统帮我们干活了啦。</p></li><li><p>关于如何弄出下面这样高大上的标志，其实也很简单。</p><p> <img src="/2018/11/08/服务计算-4-持续集成服务-Travis-CI/4.png" alt="4"><br> 点击项目旁边的<code>build|passing</code>标志，弹出一下对话框<br> <img src="/2018/11/08/服务计算-4-持续集成服务-Travis-CI/5.png" alt="5"><br> 将里面的链接在<code>README.md</code>中以链接图片方式就有了啦。</p> <figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### Go 学习 ![build](https://travis-ci.org/Liu-YT/Hello-Go.svg?branch=master)</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是持续集成服务&quot;&gt;&lt;a href=&quot;#什么是持续集成服务&quot; class=&quot;headerlink&quot; title=&quot;什么是持续集成服务&quot;&gt;&lt;/a&gt;什么是持续集成服务&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Travis CI 提供的是持续集成服务（Continuo
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 3 Golang开发Linux命令行实用程序 - selpg</title>
    <link href="http://yoursite.com/2018/11/08/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-3-Golang%E5%BC%80%E5%8F%91Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F-selpg/"/>
    <id>http://yoursite.com/2018/11/08/服务计算-3-Golang开发Linux命令行实用程序-selpg/</id>
    <published>2018-11-08T06:28:34.000Z</published>
    <updated>2018-11-08T06:43:04.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><ul><li>Linux命令行使用程序 - <code>selpg</code>，这个名称代表<code>SELect PaGes</code>。selpg允许用户指定从输入文本抽取的页的范围，这些输入文本可以来自文件或另一个进程。</li><li>关于selpg的详细介绍，参照<a href="https://www.ibm.com/developerworks/cn/linux/shell/clutil/index.html" target="_blank" rel="noopener"><strong>开发Linux命令行实用程序</strong></a></li><li>实现<code>slepg</code>代码<ul><li><a href="https://github.com/Liu-YT/selpg" target="_blank" rel="noopener">我的 - Golang实现</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/shell/clutil/selpg.c" target="_blank" rel="noopener">官方 - C语言实现</a></li></ul></li></ul><h3 id="2-设计与实现"><a href="#2-设计与实现" class="headerlink" title="2. 设计与实现"></a>2. 设计与实现</h3><h4 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a>2.1 设计思路</h4><ul><li>理解<code>selpg</code>命令的功能以及处理流程。</li></ul><ul><li><code>selpg</code>命令涉及的基本操作<ul><li>文件的读写</li><li>从终端获取输入以及在终端输出</li></ul></li></ul><h4 id="2-2-功能模块划分与实现"><a href="#2-2-功能模块划分与实现" class="headerlink" title="2.2 功能模块划分与实现"></a>2.2 功能模块划分与实现</h4><ul><li><p>构建命令行参数的结构体，由于参数使用的比较多，可以使用一个结构体存储起来，使用起来比较方便</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> selpg_args <span class="keyword">struct</span> &#123;</span><br><span class="line">startPage      <span class="keyword">int</span></span><br><span class="line">endPage        <span class="keyword">int</span></span><br><span class="line">inFile         <span class="keyword">string</span></span><br><span class="line">pageLen        <span class="keyword">int</span></span><br><span class="line">pageType       <span class="keyword">bool</span> <span class="comment">// true for -f, false for -lNumber</span></span><br><span class="line">outDestination <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数解析</p><ul><li>使用<a href="https://godoc.org/github.com/spf13/pflag" target="_blank" rel="noopener">pflag包</a>对命令行输入参数进行解析</li><li>使用 pflag 替代 goflag 以满足 Unix 命令行规范， 参考：<a href="https://o-my-chenjian.com/2017/09/20/Using-Flag-And-Pflag-With-Golang/" target="_blank" rel="noopener">Golang之使用Flag和Pflag</a></li><li>获得<code>flag</code>参数后<code>pflag.Parse()</code>函数才能把参数解析出来</li><li>使用<code>pflag.Args()</code>来获取未被标记的参数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析获取参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArgs</span><span class="params">(args *selpg_args)</span></span> &#123;</span><br><span class="line">  pflag.IntVarP(&amp;(args.startPage), <span class="string">"startPage"</span>, <span class="string">"s"</span>, <span class="number">-1</span>, <span class="string">"start page"</span>)</span><br><span class="line">  pflag.IntVarP(&amp;(args.endPage), <span class="string">"endPage"</span>, <span class="string">"e"</span>, <span class="number">-1</span>, <span class="string">"end page"</span>)</span><br><span class="line">  pflag.IntVarP(&amp;(args.pageLen), <span class="string">"pageLen"</span>, <span class="string">"l"</span>, <span class="number">72</span>, <span class="string">"the length of page"</span>)</span><br><span class="line">  pflag.BoolVarP(&amp;(args.pageType), <span class="string">"pageType"</span>, <span class="string">"f"</span>, <span class="literal">false</span>, <span class="string">"page type"</span>)</span><br><span class="line">  pflag.StringVarP(&amp;(args.outDestination), <span class="string">"outDestination"</span>, <span class="string">"d"</span>, <span class="string">""</span>, <span class="string">"print destination"</span>)</span><br><span class="line">  pflag.Parse()</span><br><span class="line"></span><br><span class="line">  other := pflag.Args() <span class="comment">// 其余参数</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(other) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    args.inFile = other[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    args.inFile = <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数检查</p><ul><li>检查输入参数的合法性<ul><li>是否输入了起始页和结束页</li><li>起始页大于1小于结束页以及不能溢出（<code>MaxInt32</code>）</li><li>结束页大于起始页并且不能溢出（<code>MaxInt32</code>）</li></ul></li><li><p>遇到不合法则输出错误同时结束程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查参数合法性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkArgs</span><span class="params">(args *selpg_args)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> args.startPage == <span class="number">-1</span> || args.endPage == <span class="number">-1</span> &#123;</span><br><span class="line">    os.Stderr.Write([]<span class="keyword">byte</span>(<span class="string">"You shouid input like selpg -sNumber -eNumber ... \n"</span>))</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> args.startPage &lt; <span class="number">1</span> || args.startPage &gt; math.MaxInt32 &#123;</span><br><span class="line">    os.Stderr.Write([]<span class="keyword">byte</span>(<span class="string">"You should input valid start page\n"</span>))</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> args.endPage &lt; <span class="number">1</span> || args.endPage &gt; math.MaxInt32 || args.endPage &lt; args.startPage &#123;</span><br><span class="line">    os.Stderr.Write([]<span class="keyword">byte</span>(<span class="string">"You should input valid end page\n"</span>))</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!args.pageType) &amp;&amp; (args.pageLen &lt; <span class="number">1</span> || args.pageLen &gt; math.MaxInt32) &#123;</span><br><span class="line">    os.Stderr.Write([]<span class="keyword">byte</span>(<span class="string">"You should input valid page length\n"</span>))</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>执行命令</p><ul><li><p>执行命令部分主要涉及到文件的读取以及写入或者标准输入的获取以及命令行下输出，我们使用到<a href="https://godoc.org/bufio" target="_blank" rel="noopener">bufio包</a>，至于<code>-dXXX</code> 实现，使用到 <a href="https://studygolang.com/articles/3329" target="_blank" rel="noopener">os/exec包</a> </p></li><li><p><strong><code>bufio包介绍与使用</code></strong></p><ul><li><p><code>bufio包</code>实现了带缓存的 I/O 操作，它封装一个 <code>io.Reader</code> 或 <code>io.Writer</code> 对象，使其具有缓存和一些文本读写功能</p><ul><li><p><code>func NewReaderSize(rd io.Reader, size int) *Reader</code></p><p><code>NewReaderSize</code> 将<code>rd</code> 封装成一个带缓存的 <code>bufio.Reader</code> 对象，缓存大小由 <code>size</code> 指定（如果小于 16 则会被设置为 16）。如果<code>rd</code>的基类型就是有足够缓存的 <code>bufio.Reader</code> 类型，则直接将rd 转换为基类型返回。</p></li><li><p><code>func NewReaderSize(rd io.Reader, size int) *Reader</code></p><p><code>NewReader</code>相当于 <code>NewReaderSize(rd, 4096)</code></p></li><li><p><code>func (reader *Reader) ReadBytes(delim byte) (line []byte, err error)</code></p><p><code>ReadBytes</code> 在 <code>reader</code>中查找<code>delim</code>并读出 <code>delim</code> 及其之前的所有数据。如果 <code>ReadBytes</code> 在找到 <code>delim</code> 之前遇到错误，则返回遇到错误之前的所有数据，同时返回遇到的错误（通常是 <code>io.EOF</code>）。 只有当 <code>ReadBytes</code> 找不到 <code>delim</code>时，<code>err</code> 才不为 <code>nil</code></p></li></ul></li></ul></li><li><p><strong><code>os/exec包介绍与使用</code></strong></p><ul><li><p><code>os/exec</code>包执行外部命令。它包装了<code>os.StartProcess</code>函数以便更容易的修正输入和输出，使用管道连接I/O，以及作其它的一些调整。 </p><ul><li><p><code>func Command(name string, arg ...string) *Cmd</code></p><p>  command返回cmd结构来执行带有相关参数的命令，它仅仅设定cmd结构中的Path和Args参数，如果name参数中不包含路径分隔符，command使用LookPath来解决路径问题，否则的话就直接使用name；Args直接跟在command命令之后，所以在Args中不许要添加命令。我们用该命令创建一个命令对象，参数为子进程路径和子进程参数（可选）　</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定运行的程序，实现模拟的打印机</span></span><br><span class="line">cmd := exec.Command(<span class="string">"./"</span> + args.outDestination)</span><br></pre></td></tr></table></figure></li><li><p><code>func (c *Cmd) StderrPipe() (io.ReadCloser, error)</code>　　</p><p>  StderrPipe返回一个pipe，这个管道连接到command的标准错误，当command命令退出时，Wait将关闭这些pipe</p></li><li><code>func (c *Cmd) StdinPipe() (io.WriteCloser, error)</code>　　　<br>  StdinPipe返回一个连接到command标准输入的管道pipe。我们可以通过在此处写入传输信息，然后作为子进程的标准输入。</li></ul></li><li><p>对于<code>-dXXX</code>的实现，创建一个子进程，让其模拟打印机，使用管道将数据传输给子进程，子进程读取管道内传输的信息并且打印出来。</p></li></ul></li><li><p>处理流程</p><ul><li>判断是否指定输入文件，为空则将标准输入作为输入，否则为文件流</li><li>判断是否为<code>-d</code>类型</li><li>判断输入类型为<code>-l</code>还是<code>-f</code>，依据要求读取输入，在输出到标准输出</li><li><p>判断起始页数以及结束页数是否满足实际标准</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processInput</span><span class="params">(args *selpg_args)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// read the file</span></span><br><span class="line">  <span class="keyword">var</span> reader *bufio.Reader</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> args.inFile == <span class="string">""</span> &#123;</span><br><span class="line">    reader = bufio.NewReader(os.Stdin)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fileIn, err := os.Open(args.inFile)</span><br><span class="line">    <span class="keyword">defer</span> fileIn.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      os.Stderr.Write([]<span class="keyword">byte</span>(<span class="string">"Open file error\n"</span>))</span><br><span class="line">      os.Exit(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reader = bufio.NewReader(fileIn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// output the file</span></span><br><span class="line">  <span class="keyword">if</span> args.outDestination == <span class="string">""</span> &#123;</span><br><span class="line">    <span class="comment">// 输出到当前命令行</span></span><br><span class="line">    outputCurrent(reader, args)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 输出到目的地</span></span><br><span class="line">    outputToDest(reader, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出到当前命令行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outputCurrent</span><span class="params">(reader *bufio.Reader, args *selpg_args)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 输出到指定目的地</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">outputToDest</span><span class="params">(reader *bufio.Reader, args *selpg_args)</span>;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>具体代码参见<a href="https://github.com/Liu-YT/selpg#use" target="_blank" rel="noopener">Github项目</a></p></li></ul></li></ul><h3 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3. 参考文献"></a>3. 参考文献</h3><ul><li><p><a href="https://godoc.org/github.com/spf13/pflag" target="_blank" rel="noopener">PFlag的使用</a></p></li><li><p><a href="https://godoc.org/io#Pipe" target="_blank" rel="noopener">package io</a></p></li><li><p><a href="https://o-my-chenjian.com/2017/09/20/Using-Flag-And-Pflag-With-Golang/" target="_blank" rel="noopener">Golang之使用Flag和Pflag</a></p></li><li><p><a href="https://studygolang.com/articles/3329" target="_blank" rel="noopener">Golang中os/exec包的用法</a></p></li><li><p><a href="https://studygolang.com/articles/4367" target="_blank" rel="noopener">Golang中bufio包的用法</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Linux命令行使用程序 - &lt;code&gt;selpg&lt;/code&gt;，这个名称代表&lt;code&gt;SELect P
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 2 Go语言开发环境配置</title>
    <link href="http://yoursite.com/2018/11/08/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-2-Go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/08/服务计算-2-Go语言开发环境配置/</id>
    <published>2018-11-08T06:28:20.000Z</published>
    <updated>2018-11-08T06:36:10.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装一些必要的工具"><a href="#1-安装一些必要的工具" class="headerlink" title="1. 安装一些必要的工具"></a>1. 安装一些必要的工具</h3><h4 id="1-1-安装Git客户端"><a href="#1-1-安装Git客户端" class="headerlink" title="1.1 安装Git客户端"></a>1.1 安装Git客户端</h4><ul><li>Go 语言的插件主要在 Github 上，安装 git 客户端是首要工作。<ul><li><code>sudo yum install git</code></li></ul></li></ul><h4 id="1-2-安装VSCode编辑器"><a href="#1-2-安装VSCode编辑器" class="headerlink" title="1.2 安装VSCode编辑器"></a>1.2 安装VSCode编辑器</h4><ul><li>本条仅对不熟悉使用<code>vim</code>或者<code>emacs</code>的用户</li><li><p>linux下安装</p><ul><li>官方教程 - <a href="https://code.visualstudio.com/docs/setup/linux" target="_blank" rel="noopener">Running VS Code on Linux</a></li><li><p>本人安装过程</p><ul><li>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc</span><br><span class="line">sudo sh -c &apos;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&apos;</span><br></pre></td></tr></table></figure></li><li><p>然后用<code>yum</code>命令安装</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum check-update</span><br><span class="line">sudo yum install code</span><br></pre></td></tr></table></figure></li><li><p>安装完成</p></li></ul></li></ul></li></ul><h3 id="2-安装golang"><a href="#2-安装golang" class="headerlink" title="2. 安装golang"></a>2. 安装golang</h3><h4 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h4><ul><li>使用系统包管理工具安装<br><code>sudo yum install golang</code></li><li>查看安装的目录<br><code>rpm -ql golang|more</code></li><li>测试安装<br><code>go version</code></li></ul><p><img src="/2018/11/08/服务计算-2-Go语言开发环境配置/0.png" alt="在这里插入图片描述"></p><h4 id="2-2-设置环境变量"><a href="#2-2-设置环境变量" class="headerlink" title="2.2 设置环境变量"></a>2.2 设置环境变量</h4><p><code>go 对编译、包管理、测试、部署、运行提供全程支持，了解环境配置非常重要！</code></p><ul><li>创建工作空间<br><code>mkdir $HOME/gowork</code></li><li><p>配置环境变量</p><ul><li><p>打开<code>~./profile</code>文件</p><ul><li>使用<strong>VSCode</strong>打开<br><code>code ~./profile</code></li><li>使用<strong>Vim</strong>打开<br><code>vim ~./profile</code></li></ul></li><li><p>在<code>~/.profile</code>文件中添加：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/gowork</span><br><span class="line">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure></li><li><p>然后执行这些配置，终端下输入一下命令<br><code>source $HOME/.profile</code></p></li><li>检查配置<ul><li>终端输入<code>go env</code></li><li>查看<code>GOPATH</code>和<code>GOROOT</code>是否已经配置好</li></ul></li></ul></li></ul><h4 id="2-3-创建Hello-World"><a href="#2-3-创建Hello-World" class="headerlink" title="2.3 创建Hello World"></a>2.3 创建Hello World</h4><ul><li><p>先退出当前用户再重新登陆</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su // 切换到root用户</span><br><span class="line">login// 登陆普通用户</span><br></pre></td></tr></table></figure></li><li><p>创建源代码目录，终端输入<br>  <code>mkdir $GOPATH/src/github.com/github-user/hello -p</code></p><ul><li>若提示权限不足，可以考虑切换到root用户进行创建</li></ul></li><li><strong>进入vs code提示需要安装一些go的相关</strong><ul><li>直接点击安装     </li></ul></li><li><a href="https://go-zh.org/doc/code.html" target="_blank" rel="noopener">Go编程教程</a> or <a href="https://blog.csdn.net/lllllyt/article/details/82860644" target="_blank" rel="noopener">学习笔记-初识Go</a></li><li><p>使用vs code创建hello.go</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"hello, world\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>终端运行<br>  <code>go run hello.go</code><br>  <img src="/2018/11/08/服务计算-2-Go语言开发环境配置/1.png" alt="在这里插入图片描述"></p></li></ul><h4 id="2-4-VS-Code安装go的相关失败解决方法"><a href="#2-4-VS-Code安装go的相关失败解决方法" class="headerlink" title="2.4 VS Code安装go的相关失败解决方法"></a>2.4 VS Code安装go的相关失败解决方法</h4><blockquote><p>进入 vscode ，它提示要安装一些工作，但 … 悲剧发生了 failed to install.<br>仔细检查，发现 <a href="https://golang.org/x/tools/" target="_blank" rel="noopener">https://golang.org/x/tools/</a>… ，emmm 原来 golang.org 连不上！</p></blockquote><ul><li>方案一<ul><li>设置相关科学上网代理，可以考虑免费的vpn或者其它的方式。<ul><li>免费vpn<a href="https://s3.amazonaws.com/3z8eilzpfmrb8/index.html" target="_blank" rel="noopener">蓝灯</a></li></ul></li></ul></li><li><p>方案二</p><ol><li><p>下载源代码到本地</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件夹</span><br><span class="line">mkdir $GOPATH/src/golang.org/x/</span><br><span class="line"># 下载源码</span><br><span class="line">go get -d github.com/golang/tools</span><br><span class="line"># copy </span><br><span class="line">cp $GOPATH/src/github.com/golang/tools $GOPATH/src/golang.org/x/ -rf</span><br></pre></td></tr></table></figure></li><li><p>安装工具包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install golang.org/x/tools/go/buildutil</span><br></pre></td></tr></table></figure></li><li><p>安装运行hello world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/github-user/hello</span><br><span class="line">$ hello</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="3-安装与运行go-tour"><a href="#3-安装与运行go-tour" class="headerlink" title="3. 安装与运行go tour"></a>3. 安装与运行go tour</h3><p>细节参见：<a href="https://github.com/Go-zh/tour" target="_blank" rel="noopener">《Go 语言之旅》</a></p><ul><li>安装<ul><li><code>$ go get github.com/Go-zh/tour/gotour</code></li></ul></li><li>运行<ul><li><code>$ gotour</code><br><img src="/2018/11/08/服务计算-2-Go语言开发环境配置/2.png" alt="在这里插入图片描述"></li><li>打开浏览器，根据相关信息打开<img src="/2018/11/08/服务计算-2-Go语言开发环境配置/3.png" alt="在这里插入图片描述"></li></ul></li><li><p>安装失败或无响应</p><ul><li><p>出现权限问题<br><img src="/2018/11/08/服务计算-2-Go语言开发环境配置/4.png" alt="在这里插入图片描述"></p><ul><li>解决方法<ul><li>终端输入<code>su</code>切换到root用户再次执行命令<br>   <img src="/2018/11/08/服务计算-2-Go语言开发环境配置/5.png" alt="在这里插入图片描述"></li></ul></li></ul></li><li><p>输入完<code>gotour</code>后报错，显示无<code>gotour</code>相关</p><ul><li>重启再次尝试安装运行go tour</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装一些必要的工具&quot;&gt;&lt;a href=&quot;#1-安装一些必要的工具&quot; class=&quot;headerlink&quot; title=&quot;1. 安装一些必要的工具&quot;&gt;&lt;/a&gt;1. 安装一些必要的工具&lt;/h3&gt;&lt;h4 id=&quot;1-1-安装Git客户端&quot;&gt;&lt;a href=&quot;#1-1
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 1 VirtualBox搭建私有云</title>
    <link href="http://yoursite.com/2018/11/08/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-1-VirtualBox%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91/"/>
    <id>http://yoursite.com/2018/11/08/服务计算-1-VirtualBox搭建私有云/</id>
    <published>2018-11-08T06:21:20.000Z</published>
    <updated>2018-11-08T06:51:00.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="私有云桌面的搭建"><a href="#私有云桌面的搭建" class="headerlink" title="私有云桌面的搭建"></a>私有云桌面的搭建</h2><h3 id="1-初始准备"><a href="#1-初始准备" class="headerlink" title="1. 初始准备"></a>1. 初始准备</h3><ul><li>VirtualBox，下载Oracle VirtualBox 5.X安装包，<a href="https://www.virtualbox.org/" target="_blank" rel="noopener">官方下载</a></li><li>Centos 7，<a href="https://www.centos.org/download/" target="_blank" rel="noopener">官方下载</a></li><li>需要硬件虚拟化（AMD-V 或 Intel-VT）支持，<a href="http://www.veryhuo.com/a/view/110093.html" target="_blank" rel="noopener">开启教程</a></li></ul><h3 id="2-创建CentOS-7-虚拟机"><a href="#2-创建CentOS-7-虚拟机" class="headerlink" title="2. 创建CentOS 7 虚拟机"></a>2. 创建CentOS 7 虚拟机</h3><ul><li>安装<ul><li>详情参见本人另一篇博客<a href="https://liu-yt.github.io/2018/11/08/VirtualBox%E5%AE%89%E8%A3%85Centos7%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">VirtualBox安装Centos7虚拟机教程</a></li></ul></li><li>网络检查<ul><li>使用<code>nmtui</code>查看虚拟机网卡，如果只有一个网卡<ul><li>关闭虚拟机，<code>shutdown -h now</code></li><li>给虚拟机添加网卡<ul><li>右键虚拟机-&gt;设置-&gt;网络-&gt;网卡2, 连接方式选择<code>Host-Only</code>，网卡选择VirtualBox创建的网卡，同时需要勾选启动按钮<br><img src="/2018/11/08/服务计算-1-VirtualBox搭建私有云/1.png" alt="这里写图片描述"></li></ul></li><li>重启虚拟机</li><li>成功登陆后，输入<code>nmtui</code><ul><li><code>Edit a connection</code> -&gt;  <code>选择非enp0S3的网卡</code> -&gt; <code>Edit...</code> -&gt; 修改IPv4的地址和网关<br>eg:<img src="/2018/11/08/服务计算-1-VirtualBox搭建私有云/2.png" alt="这里写图片描述"></li></ul></li><li>检查是否成功连接，<code>nmcli</code><br>  <img src="/2018/11/08/服务计算-1-VirtualBox搭建私有云/3.png" alt="这里写图片描述"></li></ul></li></ul></li><li>复制虚拟机<ul><li>当再次需要安装虚拟机时候，可以利用虚拟化软件提供的虚拟机复制功能，避免每次安装 OS 系统的痛苦</li><li>复制虚拟机教程<ul><li>点击centos-base选择复制，输入新虚拟机名字，注意必须选择<strong>重新初始化所有网卡的 MAC 地址 </strong></li><li>选择<strong>链接复制</strong></li><li>配置主机名和第二块网卡<ul><li>使用 <code>nmtui</code>修改主机名和第二块网卡IP地址（注意：IP地址不要与原虚拟机或者VirtualBox的虚拟网卡的IP重复）</li></ul></li><li>重启</li><li>如果主机可以ping到该地址则配置成功</li></ul></li></ul></li></ul><h3 id="3-使用SSH登陆和远程连接登陆虚拟机"><a href="#3-使用SSH登陆和远程连接登陆虚拟机" class="headerlink" title="3. 使用SSH登陆和远程连接登陆虚拟机"></a>3. 使用SSH登陆和远程连接登陆虚拟机</h3><h4 id="1-SSH登陆虚拟机"><a href="#1-SSH登陆虚拟机" class="headerlink" title="1.SSH登陆虚拟机"></a>1.SSH登陆虚拟机</h4><ul><li>centos 自带SSH服务，故无需再次安装或配置</li><li>window并未安装SSH，需要安装git bash（unix 命令行模拟环境），然后即可使用SSH服务</li><li>本地使用命令<code>ssh [用户名]@[ip地址]</code>进行登陆虚拟机</li><li>登陆成功显示<br>  <img src="/2018/11/08/服务计算-1-VirtualBox搭建私有云/4.png" alt="这里写图片描述"></li><li>退出ssh连接<ul><li>输入<code>exit</code>然后回车即可退出</li></ul></li><li>登陆失败解决方法<ul><li>多台已启动的虚拟机使用同一ip</li><li>虚拟机网卡配置的ip与virtualbox网卡的ip相同</li><li><a href="https://www.linuxidc.com/Linux/2017-05/143740.htm" target="_blank" rel="noopener">更多解决方法</a></li></ul></li></ul><h4 id="2-远程连接登陆虚拟机"><a href="#2-远程连接登陆虚拟机" class="headerlink" title="2. 远程连接登陆虚拟机"></a>2. 远程连接登陆虚拟机</h4><ul><li>增加VirtualBox远程显示扩展<ul><li>安装可以启用VirtualBox远程显示系统的扩展包，<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">下载Oracle VM VirtualBox Extension Pack</a></li></ul></li><li>在安装扩展包之前，<strong>需要关闭—注意不是挂起—所有运行中的虚拟机</strong>，并关闭整个VirtualBox系统。</li><li>安装扩展包<ul><li>在Windows中，您只需双击扩展包或手动在<code>管理</code>-&gt;<code>全局设定</code>-&gt;<code>扩展</code>中点击Add Package图标(<code>&#39;+&#39;号图标</code>)找到正确的安装包列表。<br><img src="/2018/11/08/服务计算-1-VirtualBox搭建私有云/5.png" alt="这里写图片描述"></li><li>如果您是通过命令行操作的，通过VBoxManager extpack命令添加VirtualBox远程显示扩展包。</li></ul></li><li>设置虚拟机端口<ul><li><code>为每台子虚拟机选择端口号。每台虚拟机必须拥有唯一的RDP访问端口</code></li><li>虚拟机设置端口号<ul><li><code>右键虚拟机</code> -&gt; <code>设置</code> -&gt; <code>显示</code> -&gt; <code>远程桌面</code> -&gt;  勾选<code>启用服务器</code> -&gt; 设置一个端口号</li><li>不建议使用默认端口号，避免端口已被占用<br><img src="/2018/11/08/服务计算-1-VirtualBox搭建私有云/6.png" alt="这里写图片描述"></li></ul></li><li>win 10远程连接虚拟机<ul><li>打开微软小娜服务查询远程连接直接启动远程连接</li><li>输入<code>主机ip + &#39;:&#39;+ 设定的端口号</code>，例：<code>192.168.100.1:3391</code><br><img src="/2018/11/08/服务计算-1-VirtualBox搭建私有云/7.png" alt="这里写图片描述"></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;私有云桌面的搭建&quot;&gt;&lt;a href=&quot;#私有云桌面的搭建&quot; class=&quot;headerlink&quot; title=&quot;私有云桌面的搭建&quot;&gt;&lt;/a&gt;私有云桌面的搭建&lt;/h2&gt;&lt;h3 id=&quot;1-初始准备&quot;&gt;&lt;a href=&quot;#1-初始准备&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
</feed>
