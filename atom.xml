<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  <icon>https://www.gravatar.com/avatar/1e664c942599f0404df35da54598ea93</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-02T08:49:52.364Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>liuyt49</name>
    <email>1039868176@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask服务器部署的踩坑记录</title>
    <link href="http://yoursite.com/2019/05/02/Flask%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/02/Flask服务器部署的踩坑记录/</id>
    <published>2019-05-02T08:34:25.000Z</published>
    <updated>2019-05-02T08:49:52.364Z</updated>
    
    <content type="html"><![CDATA[<p>今天在腾讯云进行flask后台进行配置的时候，按照官方的方法无论如何都无法访问到服务器</p><h2 id="官方关于外部可访问的服务器配置"><a href="#官方关于外部可访问的服务器配置" class="headerlink" title="官方关于外部可访问的服务器配置"></a>官方关于外部可访问的服务器配置</h2><blockquote><p><a href="http://docs.jinkan.org/docs/flask/quickstart.html" target="_blank" rel="noopener">快速入门 — Flask 0.10.1 文档</a></p><p>如果你运行了这个服务器，你会发现它只能从你自己的计算机上访问，网络中其它任何的地方都不能访问。在调试模式下，用户可以在你的计算机上执行任意 Python 代码。因此，这个行为是默认的。</p><p>如果你禁用了 debug 或信任你所在网络的用户，你可以简单修改调用 <a href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.run" target="_blank" rel="noopener"><code>run()</code></a> 的方法使你的服务器公开可用，如下:</p><p><code>app.run(host=&#39;0.0.0.0&#39;)</code></p><p>这会让操作系统监听所有公网 IP。</p></blockquote><p>然而并不行，接着看了网上各种相关问题，主要有几种方面的问题</p><ul><li><p>防火墙是否开放</p><p>这个是与自己的云服务配置相关，需要配置相应的安全组，或者内部直接开启相应的防火墙端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加 --permanent永久生效，没有此参数重启后失效</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent   </span><br><span class="line"><span class="meta">#</span> 重新载入</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>当然也可以暴力点把防火墙直接关掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta">#</span> 关闭</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li><li><p>是否修改了默认的IP为<code>0.0.0.0</code></p></li></ul><p>然而尽管这些都弄好了，问题还是没有解决。接下来将介绍<strong>Window 10</strong>以及<strong>Centos 7</strong>下我的解决方法</p><h2 id="Window-10"><a href="#Window-10" class="headerlink" title="Window 10"></a>Window 10</h2><blockquote><p>Pycharm</p></blockquote><p>需要修改项目的一些配置，流程如下图</p><p><img src="/2019/05/02/Flask服务器部署的踩坑记录/1.png" alt="1"></p><p><img src="/2019/05/02/Flask服务器部署的踩坑记录/2.png" alt="2"></p><p><img src="/2019/05/02/Flask服务器部署的踩坑记录/3.png" alt="3"></p><p>最后发现运行的命令变成了<code>python.exe -m flask run --host=0.0.0.0</code>，并且相应的IP地址也变成了<code>0.0.0.0</code>，此时测试发现服务器能够被外部正常访问了。发现Flask的服务修改默认的IP和端口需要显示指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python.exe -m flask run --host=0.0.0.0 -- port=8080</span><br></pre></td></tr></table></figure></p><h2 id="Centos-7"><a href="#Centos-7" class="headerlink" title="Centos 7"></a>Centos 7</h2><p>其原理其实和<code>Window 10</code>环境一样，不过不需要重新配置项目，只需要直接修改运行命令即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run -h 0.0.0.0 -p 5000</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在腾讯云进行flask后台进行配置的时候，按照官方的方法无论如何都无法访问到服务器&lt;/p&gt;
&lt;h2 id=&quot;官方关于外部可访问的服务器配置&quot;&gt;&lt;a href=&quot;#官方关于外部可访问的服务器配置&quot; class=&quot;headerlink&quot; title=&quot;官方关于外部可访问的服
      
    
    </summary>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现简单的API网关</title>
    <link href="http://yoursite.com/2019/04/25/Golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84API%E7%BD%91%E5%85%B3/"/>
    <id>http://yoursite.com/2019/04/25/Golang实现简单的API网关/</id>
    <published>2019-04-25T14:08:48.000Z</published>
    <updated>2019-04-25T15:52:18.496Z</updated>
    
    <content type="html"><![CDATA[<p>在最近的一个项目中，采用了微服务架构-<code>go-kit</code>进行后端的开发。在微服务架构风格中，一个大应用被拆分成为了多个小的服务系统提供出来，这些小的系统他们可以自成体系，也就是说这些小系统可以拥有自己的数据库，框架甚至语言等，因此我们需要设计一个<strong>API 网关(API Gataway)</strong>，其实网上已经有较多现成的实现框架，但是本项目的需求是比较简单的，因此将使用<code>Golang</code>自行实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。</p></blockquote><p>用于实现API网关的技术有很多，大致分为这么几类：</p><ul><li>通用反向代理：<code>Nginx</code>、<code>Haproxy</code>、……</li><li>网络编程框架：<code>Netty</code>、<code>Servlet</code>、……</li><li>API网关框架：<code>Spring Cloud Gateway</code>、<code>Zuul</code>、<code>Zuul2</code>、……</li></ul><p>API网关最基本的功能就是反向代理。其实现方式有很多，本文将基于标准库<code>net/http/httputil</code>包中的<code>ReverseProxy</code>类型来实现实现一个简单的反向代理。反向代理的实现主要涉及到<code>func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy</code>和<code>type ReverseProxy</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleHostReverseProxy</span><span class="params">(target *url.URL)</span> *<span class="title">ReverseProxy</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSingleHostReverseProxy returns a new ReverseProxy that routes</span></span><br><span class="line"><span class="comment">// URLs to the scheme, host, and base path provided in target. If the</span></span><br><span class="line"><span class="comment">// target's path is "/base" and the incoming request was for "/dir",</span></span><br><span class="line"><span class="comment">// the target request will be for /base/dir.</span></span><br><span class="line"><span class="comment">// NewSingleHostReverseProxy does not rewrite the Host header.</span></span><br><span class="line"><span class="comment">// To rewrite Host headers, use ReverseProxy directly with a custom</span></span><br><span class="line"><span class="comment">// Director policy.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleHostReverseProxy</span><span class="params">(target *url.URL)</span> *<span class="title">ReverseProxy</span></span> &#123;</span><br><span class="line">targetQuery := target.RawQuery</span><br><span class="line">director := <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line">req.URL.Scheme = target.Scheme</span><br><span class="line">req.URL.Host = target.Host</span><br><span class="line">req.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)</span><br><span class="line"><span class="keyword">if</span> targetQuery == <span class="string">""</span> || req.URL.RawQuery == <span class="string">""</span> &#123;</span><br><span class="line">req.URL.RawQuery = targetQuery + req.URL.RawQuery</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">req.URL.RawQuery = targetQuery + <span class="string">"&amp;"</span> + req.URL.RawQuery</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := req.Header[<span class="string">"User-Agent"</span>]; !ok &#123;</span><br><span class="line"><span class="comment">// explicitly disable User-Agent so it's not set to default value</span></span><br><span class="line">req.Header.Set(<span class="string">"User-Agent"</span>, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;ReverseProxy&#123;Director: director&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewSingleHostReverseProxy</code>返回一个新的<code>ReverseProxy</code>，将<code>URLs</code>请求路由到<code>targe</code>的指定的<code>scheme</code>, <code>host</code>, <code>base path</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReverseProxy is an HTTP Handler that takes an incoming request and</span></span><br><span class="line"><span class="comment">// sends it to another server, proxying the response back to the</span></span><br><span class="line"><span class="comment">// client.</span></span><br><span class="line"><span class="keyword">type</span> ReverseProxy <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Director must be a function which modifies</span></span><br><span class="line"><span class="comment">// the request into a new request to be sent</span></span><br><span class="line"><span class="comment">// using Transport. Its response is then copied</span></span><br><span class="line"><span class="comment">// back to the original client unmodified.</span></span><br><span class="line"><span class="comment">// Director must not access the provided Request</span></span><br><span class="line"><span class="comment">// after returning.</span></span><br><span class="line">Director <span class="function"><span class="keyword">func</span><span class="params">(*http.Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Transport</span> <span class="title">http</span>.<span class="title">RoundTripper</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">FlushInterval</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ErrorLog</span> *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">BufferPool</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ModifyResponse</span> <span class="title">is</span> <span class="title">an</span> <span class="title">optional</span> <span class="title">function</span> <span class="title">that</span> <span class="title">modifies</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">// <span class="title">Response</span> <span class="title">from</span> <span class="title">the</span> <span class="title">backend</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">called</span> <span class="title">if</span> <span class="title">the</span> <span class="title">backend</span></span></span><br><span class="line"><span class="function">// <span class="title">returns</span> <span class="title">a</span> <span class="title">response</span> <span class="title">at</span> <span class="title">all</span>, <span class="title">with</span> <span class="title">any</span> <span class="title">HTTP</span> <span class="title">status</span> <span class="title">code</span>.</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">the</span> <span class="title">backend</span> <span class="title">is</span> <span class="title">unreachable</span>, <span class="title">the</span> <span class="title">optional</span> <span class="title">ErrorHandler</span> <span class="title">is</span></span></span><br><span class="line"><span class="function">// <span class="title">called</span> <span class="title">without</span> <span class="title">any</span> <span class="title">call</span> <span class="title">to</span> <span class="title">ModifyResponse</span>.</span></span><br><span class="line"><span class="function">//</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">ModifyResponse</span> <span class="title">returns</span> <span class="title">an</span> <span class="title">error</span>, <span class="title">ErrorHandler</span> <span class="title">is</span> <span class="title">called</span></span></span><br><span class="line"><span class="function">// <span class="title">with</span> <span class="title">its</span> <span class="title">error</span> <span class="title">value</span>. <span class="title">If</span> <span class="title">ErrorHandler</span> <span class="title">is</span> <span class="title">nil</span>, <span class="title">its</span> <span class="title">default</span></span></span><br><span class="line"><span class="function">// <span class="title">implementation</span> <span class="title">is</span> <span class="title">used</span>.</span></span><br><span class="line"><span class="function"><span class="title">ModifyResponse</span> <span class="title">func</span><span class="params">(*http.Response)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ErrorHandler</span> <span class="title">func</span><span class="params">(http.ResponseWriter, *http.Request, error)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><code>ReverseProxy</code>类型有两个重要的属性，分别是<code>Director</code>和<code>ModifyResponse</code>，这两个属性都是函数类型，在接收到客户端请求时，<code>ServeHTTP</code>函数首先调用<code>Director</code>函数对接受到的请求体进行修改，例如修改请求的目标地址、请求头等；然后使用修改后的请求体发起新的请求，接收到响应后，调用<code>ModifyResponse</code>函数对响应进行修改，最后将修改后的响应体拷贝并响应给客户端，这样就实现了反向代理的整个流程。</p><p>在<code>NewSingleHostReverseProxy</code>中源码已经对传入的<code>URLs</code>进行解析并且完成了<code>Director</code>的修改，我们只需要调用<code>NewSingleHostReverseProxy</code>函数并且传入目标服务器的URL即可，一个简单的反向代理就完成了啦。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote><p>实例代码只涉及微服务中 <code>user</code> 与 <code>auth</code>模块，可以根据实际需求自行修改部分</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handle <span class="keyword">struct</span> &#123;</span><br><span class="line">host <span class="keyword">string</span></span><br><span class="line">port <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">auth *handle</span><br><span class="line">user *handle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Service)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> remote *url.URL</span><br><span class="line"><span class="keyword">if</span> strings.Contains(r.RequestURI, <span class="string">"api/auth"</span>) &#123;</span><br><span class="line">remote, _ = url.Parse(<span class="string">"http://"</span> + this.auth.host + <span class="string">":"</span> + this.auth.port)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.Contains(r.RequestURI, <span class="string">"api/user"</span>) &#123;</span><br><span class="line">remote, _ = url.Parse(<span class="string">"http://"</span> + this.user.host + <span class="string">":"</span> + this.user.port)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"404 Not Found"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">proxy := httputil.NewSingleHostReverseProxy(remote)</span><br><span class="line">proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 注册被代理的服务器 (host， port)</span></span><br><span class="line">service := &amp;Service&#123;</span><br><span class="line">auth: &amp;handle&#123;host: <span class="string">"127.0.0.1"</span>, port: <span class="string">"8081"</span>&#125;,</span><br><span class="line">user: &amp;handle&#123;host: <span class="string">"127.0.0.1"</span>, port: <span class="string">"8082"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8888"</span>, service)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">startServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://www.shawpo.me/post/ezapi-reverse/" target="_blank" rel="noopener">Golang实现简单的微服务网关——反向代理</a></li><li><a href="https://cloud.tencent.com/developer/article/1415041" target="_blank" rel="noopener">各大API网关性能比较</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在最近的一个项目中，采用了微服务架构-&lt;code&gt;go-kit&lt;/code&gt;进行后端的开发。在微服务架构风格中，一个大应用被拆分成为了多个小的服务系统提供出来，这些小的系统他们可以自成体系，也就是说这些小系统可以拥有自己的数据库，框架甚至语言等，因此我们需要设计一个&lt;str
      
    
    </summary>
    
      <category term="Go | 微服务" scheme="http://yoursite.com/categories/Go-%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计-作业3</title>
    <link href="http://yoursite.com/2019/04/13/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A3/"/>
    <id>http://yoursite.com/2019/04/13/系统分析与设计-作业3/</id>
    <published>2019-04-13T11:38:47.000Z</published>
    <updated>2019-04-14T12:42:47.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><ul><li><p><strong>简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点</strong></p><blockquote><p>从项目特点、风险特征、人力资源利用角度思考</p></blockquote><ul><li><strong>瀑布模型</strong><br>瀑布模型是将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品。<ul><li><code>优点</code>：定义了软件开发基本流程与活动，降低软件开发的复杂程度，提高软件开发过程的透明性，提高开发过程的可管理性。</li><li><code>缺点</code>：强调过程活动的线性顺序，缺乏灵活性，尤其无法解决软件需求不明确的问题，对于风险的控制能力较弱。瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量，同时管理人员如果仅仅以文档的完成情况来评估项目完成进度，往往会产生错误的结论。</li></ul></li><li><strong>增量模型</strong><br>增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件，同时每个中间版本都要执行必需的过程、活动和任务。<ul><li><code>优点</code>：以组件为单位进行开发降低了软件开发的风险，一个开发周期内的错误不会影响到整个软件系统，降低系统失败风险以及提高系统的可靠性、稳定性喝可维护性。开发顺序灵活，开发人员可以对组件的实现顺序进行优先级排序，先完成需求稳定的核心组件，当组件的优先级发生变化时，还能及时地对实现顺序进行调，对于人力资源的调度更加灵活。</li><li><code>缺点</code>：建立初始模型时，作为增量基础的基本业务服务的确定有一定难度，同时对于增量粒度难以选择。</li></ul></li><li><strong>螺旋模型（含原型方法）</strong><br>螺旋模型采用一种周期性的方法来进行系统开发，其是风险驱动的迭代过程，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。<ul><li><code>优点</code>：适用于需求功能复杂、开发周期长的大项目。引入了明确的风险管理机制。设计上的灵活性,可以在项目的各个阶段进行变更。客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。以小的分段来构建大型系统,使成本计算变得简单容易。</li><li><code>缺点</code>：螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并做出相关反应并不容易，因此螺旋模型往往比较适合内部的大规模软件开发。风险分析需要耗费相当的成本，同时失误的风险分析可能带来更大的风险。 </li></ul></li></ul></li><li><p><strong>简述统一过程三大特点，与面向对象的方法有什么关系？</strong></p><ul><li><p><strong>统一过程的三大特点</strong></p><ul><li><p>统一过程是迭代和增量的过程<br>  RUP强调采用迭代和增量方式来开发软件，把整个项目开发分为多个迭代过程。在每一次迭代中，只考虑系统的一部分需求，进行分析、设计、实现、测试、部署等过程，每次迭代是在已完成部分的基础上进行的，每次增加一些新的功能实现，以此进行下去，直至最后项目的完成。</p></li><li><p>统一过程是用例驱动的<br>  Use Case模型表达了系统的需求。开发过程是沿着一系列从用例得到的工作流前进的：用例被确定、用例被设计、最后用例又称为测试人员构造测试用例的基础。</p></li><li><p>统一过程是以构架为中心的<br>  软件构架的作用与建筑构架所起的作用类似，软件系统的构架是从不同的角度描述即将构造的系统，构架刻画了系统的整体设计，去掉了细节部分，突出了系统的重要特性。</p></li></ul></li><li><p><strong>与面向对象的联系</strong> 统一软件过程是一个面向对象且基于网络的程序开发方法论，其可以为所有方面和层次的程序开发提供指导方针，模版以及事例支持。</p></li></ul></li><li><p><strong>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</strong></p><p>  RUP中的软件生命周期在<strong>时间维度</strong>上被分解为四个顺序的阶段： <strong>初始阶段(Inception)</strong>、<strong>精化阶段(Elaboration)</strong>、<strong>构建阶段 (Construction)</strong>和<strong>产品交付阶段(Transition)</strong>。每个阶段结束于一个主要的里程碑(Major Milestone)，并在阶段结尾执行一次评估以确定这个阶段的目标是否已经满足。如果评估结果令人满意的话，可以允许项目进入下一个阶段</p><p>  <strong>里程碑</strong></p><ul><li><strong>初始阶段</strong>里程碑：生命周期目标(Lifecycle Objective)里程碑，包括一些重要的文档，如：项目构想(Vision)、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务案例等。通过对文档的评审确定用例需求理解正确、项目风险评估合理、阶段计划可行等</li><li><strong>精华阶段</strong>里程碑：生命周期体系结构(Lifecycle Architecture)里程碑，包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软 件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。</li><li><strong>构建阶段</strong>里程碑：初始运行能力(Initial Operational Capability) 里程碑， 包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。</li><li><strong>产品化阶段/移交阶段</strong>里程碑：产品发布(Product Release) 里程碑，确定最终目标 是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段相重合。</li></ul></li><li><p><strong>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</strong><br>  利用软件产品范围的弹性，合理规划范围（20%业务决定80%满意度），使得软件生产按固定节奏运行，固定迭代周期、固定开发周期、固定升级周期。</p><p>  固定节奏生产明确了不同阶段迭代的里程碑与目标，使得开发团队更加明确当前的开发目标，更加容易确定当前进度，同时更加利于人力等各种资源的分配，利于管理，利于提高整体的开发效率。同时固定周期发布软件产品，能提高客户的信任度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="系统分析与设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统分析与设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 作业2</title>
    <link href="http://yoursite.com/2019/03/29/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A2/"/>
    <id>http://yoursite.com/2019/03/29/系统分析与设计-作业2/</id>
    <published>2019-03-29T02:18:48.000Z</published>
    <updated>2019-03-30T08:57:25.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><hr><h2 id="用简短的语言给出对分析、设计的理解"><a href="#用简短的语言给出对分析、设计的理解" class="headerlink" title="用简短的语言给出对分析、设计的理解"></a>用简短的语言给出对分析、设计的理解</h2><ul><li><strong>分析</strong>的主要任务基于客户的大致需求，对其进行研究和提取更加具体详细的核心内容，其强调的是对问题的调查和需求的研究，而不是解决方案。</li><li><strong>设计</strong>的主要任务是基于分析的成果，构建出合理的满足要求的模型或者解决方案，其强调满足要求的概念解决方案（在软件和硬件中），而不是其实现</li></ul><h2 id="用一句话描述面向对象的分析与设计的优势"><a href="#用一句话描述面向对象的分析与设计的优势" class="headerlink" title="用一句话描述面向对象的分析与设计的优势"></a>用一句话描述面向对象的分析与设计的优势</h2><p>分析人员不必是“语言专家”，他们不需要掌握其他领域的专业技能。在开发过程中，问题领域的专家和实施级别的专家可以使用通用表示法进行通信</p><h2 id="简述-UML（统一建模语言）的作用。考试考哪些图？"><a href="#简述-UML（统一建模语言）的作用。考试考哪些图？" class="headerlink" title="简述 UML（统一建模语言）的作用。考试考哪些图？"></a>简述 UML（统一建模语言）的作用。考试考哪些图？</h2><ul><li>UML的作用<ul><li><code>UML作为草图</code> - 非正式和不完整的图表（通常在白板上手绘），<strong>用于探索问题或解决方案空间的难点，利用可视语言的力量</strong></li><li><code>UML作为蓝图</code> - <strong>使用相对详细的设计图表，在逆向工程中让工程师更容易理解项目的设计，在正向工程中利于设计的实现</strong></li><li><code>UML作为编程语言</code> -  <strong>用UML完成软件系统的可执行规范。可执行代码将自动生成。</strong></li></ul></li><li>考察内容<ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系     </li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布状况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul></li></ul><h2 id="从软件本质的角度，解释软件范围（需求）控制的可行性"><a href="#从软件本质的角度，解释软件范围（需求）控制的可行性" class="headerlink" title="从软件本质的角度，解释软件范围（需求）控制的可行性"></a>从软件本质的角度，解释软件范围（需求）控制的可行性</h2><p>在实际软件项目中，即使在有明确的软件开发合同条件下，仍然无法确定出完善的软件需求规格说明书，因为软件生产是易变、不可见、独特的智力生产，其不同于其余具有标准可度量的生产模式。同时由于软件本身的复杂性、不可见性、不一致性、可变性，并且在软件开发的过程中对于软件需求的控制并不是不可商量的，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程，因此需要对软件范围进行一定的控制，我们需要从用户的不明确需求中提取出基本需求，砍去一些不合理或者是不明确的部分，在满足其基本需求的基础下，不断进行迭代，不断进行完善</p><p><hr></p><hr><h1 id="项目管理实践"><a href="#项目管理实践" class="headerlink" title="项目管理实践"></a>项目管理实践</h1><hr><h2 id="看板使用练习"><a href="#看板使用练习" class="headerlink" title="看板使用练习"></a>看板使用练习</h2><ul><li>使用截图工具（png格式输出），展现你团队的任务 Kanban</li><li>每个人的任务是明确的。必须一周后可以看到具体结果</li><li>每个人的任务是1-2项</li><li>至少包含一个团队活动任务</li></ul><p><img src="/2019/03/29/系统分析与设计-作业2/kanban.png" alt="kanban"></p><h2 id="UML绘图工具练习"><a href="#UML绘图工具练习" class="headerlink" title="UML绘图工具练习"></a>UML绘图工具练习</h2><ul><li>请在 参考书2 或 教材 中选择一个类图（给出参考书页码图号）</li></ul><blockquote><p><code>UML和模式应用（原书第3版） P6 1-3 骰子游戏的局部领域模型</code></p></blockquote><p><img src="/2019/03/29/系统分析与设计-作业2/UML.png" alt="UML"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;用简短的语言给出对分析、设计的理解&quot;&gt;&lt;a href=&quot;#用简短的语言给出对分析、设计的理解&quot; class=&quot;h
      
    
    </summary>
    
      <category term="系统分析与设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统分析与设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 作业1</title>
    <link href="http://yoursite.com/2019/03/09/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A1/"/>
    <id>http://yoursite.com/2019/03/09/系统分析与设计-作业1/</id>
    <published>2019-03-09T05:22:43.000Z</published>
    <updated>2019-03-09T12:12:44.729Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h3><p>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科</p><h3 id="解释导致-software-crisis-本质原因、表现，述说克服软件危机的方法"><a href="#解释导致-software-crisis-本质原因、表现，述说克服软件危机的方法" class="headerlink" title="解释导致 software crisis 本质原因、表现，述说克服软件危机的方法"></a>解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</h3><ul><li>软件危机(<code>software crisis</code>)<strong>本质原因</strong>主要是用户需求不明确、软件开发过程缺乏正确的理论指导、软件开发的规模越来越大且软件开发的复杂度越来越高，其根源为软件的大量需求与软件生产力效率之间的矛盾和软件系统的复杂性与软件开发方法之间的矛盾 </li><li><strong>表现</strong><ul><li>项目运行超出预算</li><li>项目运行超出时间</li><li>软件质量低落</li><li>软件通常不匹配需求</li><li>项目无法管理，且代码难以维护</li></ul></li><li><strong>克服软件危机的方法</strong><ul><li>正确认识计算机软件的内涵</li><li>采用工程项目管理方法实施软件开发的管理（软件开发应该是一种组织良好、管理严密、协同配合的工程活动）</li><li>采用成熟的软件开发技术和方法，开发和使用适当的软件工具</li></ul></li></ul><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><p>计算机软件有一个孕育、诞生、成长、成熟、衰亡的生存过程，这样的过程称为软件的生命周期(也称软件开发生命周期SDLC)。软件生命周期将软件开发过程划分为若干阶段，每个阶段有明确的任务 目标和运行机制，从而使复杂的软件开发过程能够得到适当的控制 和管理。 软件生命周期一般包括可行性分析与计划、需求分析、设计(概要 设计和详细设计)、编码实现、测试、运行与维护等活动。这些活动应当以适当的方式分配到不同的阶段去完成。</p><p>软件生命周期的6个阶段：</p><ul><li>可行性分析与计划阶段</li><li>需求分析阶段</li><li>设计阶段</li><li>实现阶段</li><li>测试阶段</li><li>运行与维护阶段 </li></ul><h3 id="SWEBoK-的-15-个知识域（An-Overview-of-the-SWEBOK-Guide-）"><a href="#SWEBoK-的-15-个知识域（An-Overview-of-the-SWEBOK-Guide-）" class="headerlink" title="SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide ）"></a>SWEBoK 的 15 个知识域（<a href="https://www.sebokwiki.org/wiki/An_Overview_of_the_SWEBOK_Guide" target="_blank" rel="noopener">An Overview of the SWEBOK Guide</a> ）</h3><ul><li><p><strong>软件要求 <code>Software Requirements</code></strong></p><p>关注软件需求的启发，协商，分析，规范和验证。软件需求表达对软件产品的需求和限制，这些需求和约束有助于解决一些现实问题。</p></li><li><p><strong>软件设计 <code>Software Design</code></strong></p><p>软件设计涵盖了设计过程和最终产品，软件设计的过程是软件工程生命周期活动，其中分析软件需求以产生软件内部结构及其行为的描述，其将作为其构造的基础。软件设计（结果）必须描述软件体系结构 - 即软件如何分解和组织成组件以及这些组件之间的接口。它还必须描述能够构建它们的详细程度的组件。</p></li><li><p><strong>软件构建 <code>Software Construction</code></strong></p><p>软件构建是指通过结合详细设计，编码，单元测试，继承测试，调试和验证来详细创建工作软件。软件构建包括与满足其要求和设计约束的软件程序开发相关的主题，涵盖了软件构建基础、管理软件建设、建筑技术、实际考虑和软件构建工具。</p></li><li><p><strong>软件测试 <code>Software Testing</code></strong></p><p>软件测试旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。软件测试包括软件测试的基础知识、测试技术、人机界面测试与评估、与测试有关的措施和实际考虑。</p></li><li><p><strong>软件维护 <code>Software Maintenance</code></strong></p><p>软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。软件维护包括软件维护的基础知识（维护的性质和需求，维护类别，维护成本）、软件维护中的关键问题（技术问题，管理问题，维护成本估算，软件维护测量）、 维护过程、软件维护技术（程序理解，重新设计，逆向工程，重构，软件退役）、灾难恢复技术和软件维护工具。</p></li><li><p><strong>软件配置管理 <code>Software Configuration Management</code></strong></p><p>软件配置管理是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。软件配置管理涵盖SCM过程的管理、软件配置识别，控制，状态核算，审计、软件发布管理和交付;</p></li><li><p><strong>软件工程管理 <code>Software Engineering Management</code></strong></p><p>软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。软件工程管理涵盖了启动和范围定义（确定和协商要求，可行性分析以及要求的审查和修订）、软件项目计划（过程计划，工作量估算，成本和进度，资源分配，风险分析，质量计划）、软件项目制定（计量，报告和控制;收购和供应商合同管理）、产品验收、审查和分析项目绩效、项目结束和软件管理工具。</p></li><li><p><strong>软件工程过程 <code>Software Engineering Process</code></strong></p><p>软件工程过程关注软件生命周期过程的定义，实施，评估，测量，管理和改进，其涵盖的主题包括流程实施和变更（流程基础架构，流程实施和变更模型以及软件流程管理）、流程定义（软件生命周期模型和流程，流程定义，流程适应和流程自动化的符号）、过程评估模型和方法、测量（过程测量，产品测量，测量技术和测量结果的质量）和软件处理工具</p></li><li><p><strong>软件工程模型和方法 <code>Software Engineering Models and Methods</code></strong></p><p>涵盖的主题包括建模、 模型类型、分析、和软件开发方法。</p></li><li><p><strong>软件质量 <code>Software Quality</code></strong></p><p>软件质量包括软件质量的基础知识（软件工程文化，软件质量特性，软件质量的价值和成本以及软件质量改进）、软件质量管理流程（软件质量保证，验证和确认，审核和审核和实际考虑（缺陷表征，软件质量测量和软件质量工具）</p></li><li><p><strong>软件工程专业实践 <code>Software Engineering Professional Practice</code></strong></p><p>关注软件工程师必须具备的专业，负责和道德的软件工程知识，技能和态度，涵盖专业性、道德准则、小组动态和够通技巧</p></li><li><p><strong>软件工程经济学 <code>Software Engineering Economics</code></strong></p><p>关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。涵盖的主题包括软件工程经济学的基本原理（提案，现金流量，货币时间价值，计划视野，通货膨胀，折旧，替代和退休决策）；非营利性决策（成本效益分析，优化分析）; 估计，经济风险和不确定性（估算技术，风险决策和不确定性）; 和多属性决策（价值和衡量尺度，补偿和非补偿技术）。</p></li><li><p><strong>计算基础 <code>Computing Foundations</code></strong></p><p>提供软件工程实践所需的计算背景的基础主题。涵盖的主题包括问题解决技术，抽象，算法和复杂性，编程基础，并行和分布式计算的基础知识，计算机组织，操作系统和网络通信。</p></li><li><p><strong>数学基础 <code>Mathematical Foundations</code></strong></p><p>提供软件工程实践所必需的数学背景的基础主题。涵盖的主题包括集合，关系和功能; 基本命题和谓词逻辑; 证明技术; 图形和树木; 离散概率; 语法和有限状态机; 和数论。</p></li><li><p><strong>工程基础 <code>Engineering Foundations</code></strong></p><p>提供软件工程实践所必需的工程背景的基础主题。涵盖的主题包括经验方法和实验技术; 统计分析; 测量和指标; 工程设计; 仿真与建模; 和根本原因分析。</p></li></ul><h3 id="简单解释-CMMI-的五个级别。"><a href="#简单解释-CMMI-的五个级别。" class="headerlink" title="简单解释 CMMI 的五个级别。"></a>简单解释 CMMI 的五个级别。</h3><ul><li><p>Level 1 - Initial</p><p><code>初始级</code>。无序，自发生产模式。管理是反应式的。</p></li><li><p>Level 2 - Managed</p><p><code>可管理级</code>。建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。</p></li><li><p>Level 3 - Defined</p><p><code>已定义级</code>。已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。</p></li><li><p>Level 4 - Quantitatively Managed</p><p><code>量化管理级</code>。分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。</p></li><li><p>Level 5 - Optimizing</p><p><code>优化管理级</code>。过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。</p></li></ul><h3 id="用自己语言简述-SWEBok-或-CMMI"><a href="#用自己语言简述-SWEBok-或-CMMI" class="headerlink" title="用自己语言简述 SWEBok 或 CMMI"></a>用自己语言简述 SWEBok 或 CMMI</h3><p>CMMI全称Capability Maturity Model Integration，是能力成熟度集成模型，是由美国国防部与卡内基-梅隆大学和美国国防工业协会共同开发和研制的，其整合传统上独立的组织功能，设定流程改进目标和优先级，为质量流程提供指导，并为评估当前流程提供参考。该架构能够用来度量你的有效性和实用性；能够找出这样的一些机会，继续改进的机会，包括在商业目标、策略还有降低项目的风险等方面。CMMI为改进一个组织的各种过程提供了一个单一的集成化框架，对于IT产业而言，其帮助IT企业对软件在工作的时候进行管理和不断的改进的，大大的帮助了企业的开发，也帮助企业增强了改进能力，从而可以帮助企业壮大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;软件工程的定义&quot;&gt;&lt;a href=&quot;#软件工程的定义&quot; class=&quot;headerlink&quot; title=&quot;软件工程的定义&quot;&gt;&lt;/a&gt;软件工程的定义&lt;/h3&gt;&lt;p&gt;应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发
      
    
    </summary>
    
      <category term="系统分析与设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统分析与设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>区块链发展与现状</title>
    <link href="http://yoursite.com/2019/01/08/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/"/>
    <id>http://yoursite.com/2019/01/08/区块链发展与现状/</id>
    <published>2019-01-08T10:46:04.000Z</published>
    <updated>2019-01-08T10:46:17.932Z</updated>
    
    <content type="html"><![CDATA[<p>​本次主要阅读了三篇论文，所探讨的主题与当前区块链的安全性以及区块链市场相关。论文<sup><a href="#fn_1" id="reffn_1">1</a></sup>主要以Mt.Gox交易所的交易网络作为样本分析加密货币市场中的市场操纵以及操纵模式，其将交易历史通过一系列的分析以及构造成需要的图，将所有账号分成三类：高账户（EHA）、低账户（ELA）、一般账户（NMA），数据分析发现不正常的账户交易和比特币的价格有关联，此外异常账户存在许多奇怪的事务模式（如自循环、双向、三角形等），这些模式证明了交易市场中存在大量的市场操纵行为。论文<sup><a href="#fn_2" id="reffn_2">2</a></sup>主要通过数据处理和机器学习方法来检测庞氏骗局，其主要基于分析用户交易信息得到用户特征以及反解智能合约的字节码得到操作码，该方法对于检测不提供源代码的智能合约（用户无法之间了解真正的合约内容）是否为庞氏骗局有较大的意义。论文<sup><a href="#fn_3" id="reffn_3">3</a></sup>主要利用图分析技术对区块链中的用户特征进行分类，并用交叉图技术研究以太坊安全问题。</p><p>​区块链可以说是当今最热门的研究方向之一，很多区块链项目也已经落地。但是目前区块链市场方面还是比较混乱的，区块链因为其匿名性以及去中心化吸引大量关注，但是也因为其特性而导致其更加的难以管控与更多安全性问题。目前区块链市场情况比较复杂，很多人只是利用区块链项目圈钱，割完“韭菜”就跑路，也有部分人通过ICO(首次代币发行)进行非法集资，同时存在许多欺诈行为，受害者被骗以后也难以追究到具体的责任（匿名性），更别说挽回损失，更多的只能在各大论坛上发自己被骗了发发牢骚。同时，对于Mt.Gox交易所泄露的交易信息分析中也发现了大量操纵行为，侧面说明区块链市场操纵盛行。操纵市场行为，原本是指个人或机构背离市场自由竞争和供求关系原则，人为地操纵证券价格，以引诱他人参与证券交易，为自己牟取私利的行为，在区块链市场里面主要是部分人通过某些操纵手段（例如：不正常的事务）来引起加密数字货币的价格浮动，从而从中谋取私利。目前证券市场方面由于国家的严加管控已经难以发生市场操纵的行为，而对于区块链这个去中心化的领域而言，如果不能合理的解决市场操纵的问题，则将会称为少部分人的游戏，将造成巨大的不良影响，也将限制区块链的发展与应用。</p><p>​对于区块链领域，目前国家也出台了相关的文件，对一些违法行为进行了监管与约束，例如严禁通过ICO来进行非法融资，同时也发布相应的科普文章《区块链能做什么、不能做什么？》来避免群众过于盲目而被诈骗，当然国家也大力支持区块链技术的发展。但是区块链方面还是有许多的安全性问题尚未解决，区块链因为其匿名性以及去中心化的特性，让用户更加的自由，但是这也带来一系列的问题。如何保留着区块链的特性的前提下让其亦能够健康的发展是一个难题，不过相信随着研究的更加深入，对于区块链骗局与欺诈将会有更多有效的方法来检测与约束，同时对于市场操纵现象也会有相应合理的管控，使得区块链技术得以更加健康的发展。</p><p>参考文献：<br><sup><a href="#fn_1" id="reffn_1">1</a></sup>: Market Manipulation of Bitcoin: Evidence from Mining the Mt. Gox Transaction Network<br><sup><a href="#fn_2" id="reffn_2">2</a></sup>: Detecting Ponzi Schemes on Ethereum: Towards Healthier BlockchainTechnology<br><sup><a href="#fn_3" id="reffn_3">3</a></sup>: Understanding Ethereum via Graph Analysis</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​本次主要阅读了三篇论文，所探讨的主题与当前区块链的安全性以及区块链市场相关。论文&lt;sup&gt;&lt;a href=&quot;#fn_1&quot; id=&quot;reffn_1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;主要以Mt.Gox交易所的交易网络作为样本分析加密货币市场中的市场操纵以及操纵模式，其将交易历史通过一
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>高性能区块链拓展方法</title>
    <link href="http://yoursite.com/2019/01/07/%E9%AB%98%E6%80%A7%E8%83%BD%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/01/07/高性能区块链拓展方法/</id>
    <published>2019-01-07T06:59:26.000Z</published>
    <updated>2019-01-07T07:03:57.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结当前区块链研究中用于提高区块链系统性能和可扩展性的方法。并详细说明侧链技术，以及通过以太坊构建侧链的方法</p></blockquote><p>如今，性能过低是当前区块链技术面临的主要挑战之一。区块链的性能指标主要包括交易吞吐量和延时。比特币理论上每秒最多只能处理七笔交易，每十分钟出一个区块，相当于交易吞吐量为7，交易延时为10分钟，实际上，等待最终确认需要6个左右的区块，也就是说实际交易延时是1个小时。以太坊稍有提高，但也远远不能满足应用需求。从区块链技术来看，目前影响区块链性能因素主要包括广播通信、信息加解密、共识机制、交易验证机制等几个环节。目前提高区块链性能与扩展性已经提出几种方法，主要包括<strong>分片（Sharding）、离链计算（Off-chain computing）及侧链（Slidechain）、有向无环结构（DAG）</strong>等等，这些方式主要是通过将部分链上任务转到链下或其他链进行处理，或者将整个交易分为几个部分并分别处理，另一种思路是<strong>调整共识机制</strong>，采用新的可扩展的共识协议，从PoW到PoS再到DPoS和各种BFT类算法，共识机制不断创新，区块链平台性能也得到大幅提升，或者<strong>系统优化</strong>，通过优化系统 架构、代码结构、 数据存储效率、 网络发送效率等， 提高区块链性能。</p><ul><li><p>分片（Sharding）。分片技术是一种基于数据库分片传统概念的扩容技术，它将数据库分割成多个碎片并将这些碎片放置在不同的服务器上。在公共区块链的情境中，网络上的交易将被分成不同的碎片，其由网络上的不同节点组成。因此，每个节点只需处理一小部分传入的交易，并且通过与网络上的其他节点并行处理就能完成大量的验证工作。将网络分割为碎片会使得更多的交易同时被处理和验证。因此，随着网络的增长，区块链处理越来越多的交易将成为可能。这种属性也称为水平扩容。</p></li><li><p>有向无环结构（DAG）。DAG区块链技术没有区块概念，不是把所有数据打包成区块，再用区块链接区块，而是每个用户都可以提交一个数据单元，这个数据单元里可以有很多东西，比如交易、消息等等。数据单元间通过引用关系链接起来，从而形成具有半序关系的DAG（有向无环图）。DAG的特点是把数据单元的写入操作异步化，大量的钱包客户端可以自主异步地把交易数据写入DAG，从而可以支持极大的并发量和极高的速度。</p></li><li><p><strong>离链计算/侧链</strong>。在主链之下进行交易，中间交 易不进入主链确认，待最后一 笔交易完成后回归到主链。</p><ul><li><p><strong>什么是侧链？</strong></p><p>侧链本质上是一种<strong>跨区块链解决方案</strong>。通过这种解决方案，可以实现数字资产从第一个区块链到第二个区块链的转移，又可以在稍后的时间点从第二个区块链安全返回到第一个区块链。其中第一个区块链通常被称为主区块链或者主链，每二个区块链则被称为侧链。最初，主链通常指的是比特币区块链，而现在主链可以是任何区块链。侧链协议被设想为一种允许数字资产在主链与侧链之间进行转移的方式，其实现的技术基础是<strong>双向锚定（Two-way Peg）</strong>，通过双向锚定技术，可以实现暂时的将数字资产在主链中锁定，同时将等价的数字资产在侧链中释放，同样当等价的数字资产在侧链中被锁定的时候，主链的数字资产也可以被释放。双向锚定实现的最大难点是协议改造需兼容现有主链，也就是不能对现有主链的工作造成影响，其具体实现方式可以分为以下几类：单一托管模式、联盟模式、SPV模式、驱动链模式、混合模式。</p></li></ul></li></ul><h2 id="以太坊构建侧链的方法"><a href="#以太坊构建侧链的方法" class="headerlink" title="以太坊构建侧链的方法"></a>以太坊构建侧链的方法</h2><p>在以太坊上构建侧链，我们可以使用到Plasma。Plasma是一种处理链下交易的技术，需要依赖以太坊底层技术去对其安全性进行保障，它可以允许在以太坊主链上创建“子链”，同时这些“子链”也可以创建它们自己的“子链”。</p><p>任何人都可以在以太坊主链上创建个人化的 Plasma 智能合约，Plasma智能合约运行在根链（以太坊主网）之上，形成一个可靠的侧链链接网络连接到一个分层和树状结构的根链，强制执行区块链历史和 MapReducible 计算进入一系列的 merkle 证明。同时Plasma 链的一个关键属性是所谓的退出机制，它允许用户放弃子链，一旦出现任何问题时可以将资金提取到根链。所有在 Plasma 链上的交易完成都是依靠加密签章，不需要经过主链的共识，经过一段时间后才批次性的广播并写入主链中。因此大量在 Plasma 上的所有交易最后只会浓缩成少数比交易打包进主链中，大幅度降低区块链膨胀问题。</p><p>更加通俗的说明一下Plasma运作：</p><ul><li>首先，我们需要在以太坊主链创建一套智能合约，作为服务于我们Plasma子链的Root。Plasma Root包含了子链的基本状态交易规则，记录了子链状态的哈希值，并且让用户在以太坊主链和子链之间转移资产。</li><li>然后，在将子链根植于主链上之后，子链就被创造出来了。这个子链拥有自己的共识算法，且独立于以太坊主链。然后，我们就可以依据自己的需求来使用了。</li></ul><p>当然现在也有更加好的平台和工具，例如Loom Network，其被称为以太坊上的EOS，其核心产品是一款SDK - Loom SDK。Loom SDK会生成一个称为DApp链的产物（DApp链使用基于Plasma的中继来与以太坊之间来回转移资产），它是一个用以太坊作为基础层的第二层区块链，同时SDK允许开发者选择他们自己的共识算法和规则集。</p><p>参考文献</p><ul><li><a href="https://plasma.io/plasma.pdf" target="_blank" rel="noopener">Plasma: Scalable Autonomous Smart Contracts</a></li><li><a href="https://medium.com/@argongroup/ethereum-plasma-explained-608720d3c60e" target="_blank" rel="noopener">Explained: Ethereum Plasma</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;总结当前区块链研究中用于提高区块链系统性能和可扩展性的方法。并详细说明侧链技术，以及通过以太坊构建侧链的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如今，性能过低是当前区块链技术面临的主要挑战之一。区块链的性能指标主要包括交易吞吐量和延时。比特
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>DApp开发遇到问题以及解决</title>
    <link href="http://yoursite.com/2018/12/24/DApp%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/12/24/DApp开发遇到问题以及解决/</id>
    <published>2018-12-24T11:19:30.000Z</published>
    <updated>2018-12-26T04:40:19.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次博客简单记录下开发DApp过程中遇到的一些问题，以及相应的解决方案，因此写的也是很随意，仅供参考</p><blockquote><p><a href="https://github.com/Liu-YT/public-comment" target="_blank" rel="noopener">项目地址</a></p></blockquote><h1 id="Vue如何使用Web3"><a href="#Vue如何使用Web3" class="headerlink" title="Vue如何使用Web3"></a>Vue如何使用Web3</h1><ul><li><p>安装<code>Web3</code>的依赖</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3@^0.20.0 --save</span><br></pre></td></tr></table></figure></li><li><p>项目里创建全局<code>web3</code>对象</p><ul><li><p>写一个插件，例如命名为<code>Web3.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Web3 <span class="keyword">from</span> <span class="string">"web3"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    install: <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> web3 = <span class="built_in">window</span>.web3</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            web3 = <span class="keyword">new</span> Web3(web3.currentProvider)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:8545'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        Vue.prototype.$web3 = web3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>main.js</code>里启用该插件，以后就可以这样使用<code>this.$web3</code>这个全局对象了</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Web3)</span><br></pre></td></tr></table></figure></li><li><p>例子</p><ul><li>获得第一个区块的信息  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得第一个区块的信息</span></span><br><span class="line"><span class="keyword">this</span>.$web3.eth.getBlock(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在控制台输出相应信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$web3.eth.getBlock(<span class="number">0</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>参考链接 - <a href="https://segmentfault.com/a/1190000014497742" target="_blank" rel="noopener">基于Vue、web3的以太坊项目开发及交易内幕初探</a></p></li></ul><h1 id="创建账号失败问题"><a href="#创建账号失败问题" class="headerlink" title="创建账号失败问题"></a>创建账号失败问题</h1><blockquote><p>此处Web3.js 1.0与0.2的API混用了，没有搞清楚不同版本的区别</p></blockquote><ul><li><p>创建用户写法</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">this</span>.$web3.eth.personal.newAccount(<span class="string">'sysu'</span>,(err, accounts) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(accounts, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>报错</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &apos;newAccount&apos; of undefined at &lt;anonymous&gt;:1:19</span><br></pre></td></tr></table></figure><p>  控制台再次尝试同样结果，内心崩溃<br>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccountError1.png" alt="newAccount"></p></li><li><p>搜寻许久，发现<code>web3</code>下面使用创建用户的模式应该为</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$web3.personal.newAccount(<span class="string">'sysu'</span>, (err, addr) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  即<code>personal</code>不是在<code>eth</code>命名空间下，与在<code>geth</code>中的控制台使用有所区别</p></li><li><p>问题仍然没有解决，还是报错了</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The method personal_newAccount does not exist/is not available] undefine</span><br></pre></td></tr></table></figure><p>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccountError2.png" alt="newAccount"></p></li><li><p>继续查找解决方案</p><blockquote><p>Are you running with code from the Geth console or from an external JavaScript environment? If you connect an external environment to Geth via the HTTP-RPC interface, by default the personal namespace is not available due to security considerations.</p></blockquote><p>发现问题所在，默认情况下，<code>personal</code>由于安全考虑，命名空间不可用</p></li><li><p>解决方案</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Run your node with --rpc and --rpcapi personal,web3 flags.</span><br><span class="line">i.e. geth --dev --rpcapi personal,web3,eth --rpc</span><br><span class="line">You may need to add --rpccorsdomain &quot;&lt;your-domain&gt;&quot;, in case you are using web3 in the web.</span><br><span class="line">geth --dev --rpcapi personal,web3,eth --rpccorsdomain &quot;your-domain&quot;</span><br></pre></td></tr></table></figure><p>  参照dalao的提示，使用<code>geth</code>启动私有链的时候需要加入<code>--rpcapi personal,web3,eth</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr YOUR_IP -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure><p>  然后再次测试<br>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccount.png" alt="newAccount"></p></li><li>参考链接 - <a href="https://github.com/ethereum/go-ethereum/issues/2723#event-698940135" target="_blank" rel="noopener">personal_newAccount does not exist/is not available</a></li></ul><h1 id="Web3-js-0-2XX版本-与-Web3-js-1-0版本"><a href="#Web3-js-0-2XX版本-与-Web3-js-1-0版本" class="headerlink" title="Web3.js 0.2XX版本 与 Web3.js 1.0版本"></a>Web3.js 0.2XX版本 与 Web3.js 1.0版本</h1><ul><li><a href="https://web3.learnblockchain.cn/0.2x.x/" target="_blank" rel="noopener">Web3.js 0.2x.x API 中文版手册</a></li><li><a href="http://cw.hubwiz.com/card/c/web3.js-1.0/1/1/1/" target="_blank" rel="noopener">Web3.js 1.0 中文手册</a> </li><li>二者关于<code>API</code>的使用有较多的区别，不能混用。个人后面发现<code>Web3.js 1.0</code>更加好用，然后就果断上车了</li></ul><h1 id="Remix连接私有链出现的问题"><a href="#Remix连接私有链出现的问题" class="headerlink" title="Remix连接私有链出现的问题"></a>Remix连接私有链出现的问题</h1><h2 id="问题1-Not-possible-to-connect-to-the-Web3-provider"><a href="#问题1-Not-possible-to-connect-to-the-Web3-provider" class="headerlink" title="问题1: Not possible to connect to the Web3 provider"></a>问题1: Not possible to connect to the Web3 provider</h2><p>Not possible to connect to the Web3 provider. Make sure the provider is running and a connection is open (via IPC or RPC).<br>    <img src="/2018/12/24/DApp开发遇到问题以及解决/remixE0.png" alt="remix"><br>错误原因： 在使用<code>geth</code>启动私有链结点的时候没有<code>--rpc</code><br>解决:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth,net --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr 127.0.0.1 -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure></p><pre><code>加入以后可以正常连接了</code></pre><h2 id="问题2-成功连接后显示can-39-t-detect-network"><a href="#问题2-成功连接后显示can-39-t-detect-network" class="headerlink" title="问题2: 成功连接后显示can&#39;t detect network"></a>问题2: 成功连接后显示<code>can&#39;t detect network</code></h2><p><img src="/2018/12/24/DApp开发遇到问题以及解决/remixE1.png" alt="remix"><br>错误原因： 在使用<code>geth</code>启动私有链结点的时候没有zding开启<code>net</code><br>解决:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth,net --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr 127.0.0.1 -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本次博客简单记录下开发DApp过程中遇到的一些问题，以及相应的解决方案，因此写的也是很随意，仅供参考&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Capacitated Facility Location Problem</title>
    <link href="http://yoursite.com/2018/12/22/Capacitated-Facility-Location-Problem/"/>
    <id>http://yoursite.com/2018/12/22/Capacitated-Facility-Location-Problem/</id>
    <published>2018-12-22T13:24:46.000Z</published>
    <updated>2018-12-22T17:53:49.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/Liu-YT/CFL-Problem" target="_blank" rel="noopener">项目地址</a></p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Suppose there are n facilities and m customers. We wish to choose: </p><ul><li>which of the n facilities to open </li><li>the assignment of customers to facilities </li></ul><p>The objective is to minimize the sum of the opening cost and the assignment cost. </p><p><strong>The total demand assigned to a facility must not exceed its capacity.</strong> </p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>该问题阐述的比较明确，目前有<code>n</code>个设备，每个设备开启需要一个固定的费用，然后又有<code>m</code>个顾客，每个顾客有一定的需求，但是每个设备能够提供的资源是有限的，并且每个顾客使用相应的设备的时候还需要提供一笔附加的费用，此处还有一个前提条件是一个顾客所有需求只能被一个设备处理。目前的问题是，如何给顾客分配设备，使得最后总费用最小。</p><p>这是一个<code>NP-hard</code>的问题，给出一种分配方式，我们可以比较容易的确定其是否可行，但是如果想要找到一个最理想的分配方案，则是非常的难的，我们只能尽可能的找到一个比较理想的解。最近在用<code>模拟退火(SA)</code>与<code>遗传算法(GA)</code>解决另一个比较经典的问题-<code>TSP</code>问题，所以本次也就优先想到使用这两种算法来搜索得到一个比较理想的解，但是这些<strong>最终解都是当前解里面最优的，为相应算法中的最优解，并非全局最优</strong> 。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><blockquote><p>关于<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/355508?fr=aladdin" target="_blank" rel="noopener">模拟退火算法</a>以及<a href="https://baike.baidu.com/item/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/838140?fr=aladdin" target="_blank" rel="noopener">遗传算法</a>的具体流程就不再详细，都是比较经典的算法，接下来主要讲讲与问题相关联的核心部分思路与实现</p></blockquote><h2 id="模拟退火-SA"><a href="#模拟退火-SA" class="headerlink" title="模拟退火 (SA)"></a>模拟退火 (SA)</h2><blockquote><p>模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。</p></blockquote><p>在本次算法设计中，比较关键的点在于搜索中<strong>领域操作</strong>的设计上，领域操作影响着最终结果的好坏，通过邻域动作。产生初始解的邻居解，然后根据某种策略选择邻居解。一直重复以上过程，直到达到终止条件。对于本次场景而言，对于产生的解，只要是新解所需要的费用小于目前的费用，则直接选择该接。而对于一些比当前的解要差的解，以一定的概率接受，采纳的概率为:</p><script type="math/tex; mode=display">P_k = e^{(-\Delta E_k) / T}</script><p>本次模拟退火算法设计中，所设计的领域操作位<strong>在用户序列中随机选择两个位置，对于在此之间的用户为其重新随机选择一次所选择的设备，如果随机到的设备所能提供的容量不满足，则再次随机选择设备，直到选择到合适的为止</strong>，该领域操作尽可能的涉及到了各种可能的分配方案，尽可能的扰动当前结果以及概率接受差解，使其可能跳出局部最优解，已得到比较理想的解。</p><p><a href="https://github.com/Liu-YT/CFL-Problem/blob/master/src/SA.hpp" target="_blank" rel="noopener">模拟退火算法主要核心代码</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟退火</span></span><br><span class="line"><span class="keyword">while</span>(T &gt; <span class="number">0.01</span>) &#123;</span><br><span class="line">    <span class="comment">/* 扰动获得寻找较优解，并且可能接收差解 */</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; SEARCHTIMES) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = rand() % (p-&gt;numOfCus);</span><br><span class="line">        <span class="keyword">int</span> second = rand() % (p-&gt;numOfCus - first) + first;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newCusToFac = cusToFac;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newFreeCapacity = freeCapacity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = first; j &lt;= second; ++j)</span><br><span class="line">            newFreeCapacity[newCusToFac[j]] += p-&gt;cusDemand[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机分配一个新的工厂</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = first; j &lt;= second; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;cusDemand[j] &gt; newFreeCapacity[newFac])</span><br><span class="line">                newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            newCusToFac[j] = newFac;</span><br><span class="line">            newFreeCapacity[newFac] -= p-&gt;cusDemand[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cost = calCost(p, newCusToFac, newFreeCapacity);</span><br><span class="line">        <span class="keyword">double</span> probability = (rand() % <span class="number">100</span>) * <span class="number">1.0</span> / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前解，一定概率接受</span></span><br><span class="line">        <span class="keyword">if</span> (cost &lt;= totalCost || probability &lt; <span class="built_in">exp</span>(-<span class="built_in">abs</span>(cost-totalCost) / T)) &#123;</span><br><span class="line">            cusToFac = newCusToFac;</span><br><span class="line">            freeCapacity = newFreeCapacity;</span><br><span class="line">            totalCost = cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 降温</span></span><br><span class="line">    T *= alpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>SEARCHTIMES</code>，局部搜索的次数设置也比较关键，搜索次数也影响着结果的好坏，如果次数太少则可能造成遗漏比较多，而次数设置的比较大的话，对于数据量比较小的情况将造成算力浪费。因此考虑到可能出现的随机情况$C^2_n$，因此对于不同问题，动态设置局部搜索的次数为<code>SEARCHTIMES = n * (n-1) / 2</code>，但是其实还是很耗时，但是效果还可以。</p><h2 id="遗传算法-GA"><a href="#遗传算法-GA" class="headerlink" title="遗传算法 (GA)"></a>遗传算法 (GA)</h2><blockquote><p>关于遗传算法解决，其实个人认为普通的遗传算法效率并不高，并且如果没有针对问题有一定的设计的话，很难达到比较好的状态。</p></blockquote><p>首先需要大概的了解遗传算法的主要流程<br><img src="/2018/12/22/Capacitated-Facility-Location-Problem/GA.png" alt="GA"></p><p><code>Code</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化种群</span></span><br><span class="line">initPopulation(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟遗传</span></span><br><span class="line"><span class="keyword">int</span> curGen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(curGen &lt; MAXGEN) &#123;</span><br><span class="line">    <span class="comment">// 选择</span></span><br><span class="line">    select(p);</span><br><span class="line">    <span class="comment">// 交叉</span></span><br><span class="line">    crosscover(p);</span><br><span class="line">    <span class="comment">// 变异</span></span><br><span class="line">    mutate(p);</span><br><span class="line">    ++curGen; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>适应度评估</strong>，其适应度等于该方案费用<code>cost</code>的倒数，即<code>1 / cost</code></p><hr><p>关于<strong>选择</strong>，使用比较通用的<a href="https://www.cnblogs.com/legend1130/archive/2016/03/29/5333087.html" target="_blank" rel="noopener">轮盘赌</a>，同时选择其他的选择策略的效果也是不错的</p><hr><p>关于<strong>种群初始化</strong>，其实默认是比较容易的，即随机生成种群即可，但是实验起来发现随机生成初始种群，其收敛效果很差并且效率很低。因此<strong>在初始化种群的时候加入部分贪心生成的个体</strong>，加快种群成熟速度，也保证了种群中个体的多样性。关于贪心生成个体的思路也比较简单，打乱顾客挑选设备的顺序，每次未顾客挑选当前所需要费用最小的设备。但是关于贪心生成的较优个体的占额也需要注意，如果占的比列比较大，可能会导致过早收敛，出现早熟现象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化种群</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPopulation</span><span class="params">(problem* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为提高效率，初始时候通过贪心加入一部分较优个体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        individual* ind = <span class="keyword">new</span> individual(p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> fac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;cusDemand[j] &gt; ind-&gt;freeCapacity[fac])</span><br><span class="line">                fac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            ind-&gt;freeCapacity[fac] -= p-&gt;cusDemand[j];</span><br><span class="line">            ind-&gt;cusToFac[j] = fac;</span><br><span class="line">        &#125; </span><br><span class="line">        evalute(p, ind);</span><br><span class="line">        population.push_back(ind);      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贪心生成解</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;numOfCus; ++i) temp.push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        individual *ind = <span class="keyword">new</span> individual(p);</span><br><span class="line">        random_shuffle(temp.begin(), temp.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mixCost = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p-&gt;numOfFac; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;cusDemand[temp[j]] &lt;= ind-&gt;freeCapacity[k] &amp;&amp; mixCost &gt;= p-&gt;useCost[temp[j]][k]) &#123;</span><br><span class="line">                    mixCost = p-&gt;useCost[temp[j]][k];</span><br><span class="line">                    ind-&gt;freeCapacity[k] -= p-&gt;cusDemand[temp[j]];</span><br><span class="line">                    ind-&gt;cusToFac[temp[j]] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        evalute(p, ind);</span><br><span class="line">        population.push_back(ind);</span><br><span class="line">    &#125;</span><br><span class="line">    random_shuffle(population.begin(), population.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>交叉操作</strong>，第<code>n</code>条染色体与第<code>n+1</code>条染色体有一定的概率进行交叉<code>(n = 0, 2, 4, ..., 2n)</code>。这部分使用<strong>两点交叉</strong></p><blockquote><p>两点交叉（Two-point Crossover）：在个体编码串中随机设置了两个交叉点，然后再进行部分基因交换</p></blockquote><p>但是交叉后的结果可能是不可行的方案，我们需要判断一下交叉后的解是否可行，然后再进行一定的策略操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crosscover</span><span class="params">(problem* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两点交叉 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;individual*&gt; subPopulation;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rand() % <span class="number">100</span>) * <span class="number">1.0</span> / <span class="number">100</span> &lt;= PXOVER) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count++ &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                individual *a = <span class="keyword">new</span> individual(population[i*<span class="number">2</span>]);</span><br><span class="line">                individual *b = <span class="keyword">new</span> individual(population[i*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> geneFirst = rand() % (p-&gt;numOfCus);</span><br><span class="line">                <span class="keyword">int</span> geneSecond = rand() % (p-&gt;numOfCus - geneFirst) + geneFirst;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = geneFirst; k &lt;= geneSecond; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a-&gt;cusToFac[k];</span><br><span class="line">                    a-&gt;cusToFac[k] = b-&gt;cusToFac[k];</span><br><span class="line">                    b-&gt;cusToFac[k] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (validCover(p, a) &amp;&amp; validCover(p, b)) &#123;</span><br><span class="line">                    evalute(p, a);</span><br><span class="line">                    evalute(p, b);</span><br><span class="line">                    subPopulation.push_back(a);</span><br><span class="line">                    subPopulation.push_back(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(subPopulation.begin(), subPopulation.end(), [&amp;](<span class="keyword">const</span> individual* a, <span class="keyword">const</span> individual* b) -&gt; <span class="keyword">bool</span>&#123; <span class="keyword">return</span> a-&gt;cost &lt; b-&gt;cost;&#125;);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subPopulation.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; POSIZE; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(population[j]-&gt;cost &gt; subPopulation[i]-&gt;cost) &#123;</span><br><span class="line">                individual* temp = population[j];</span><br><span class="line">                population[j] = subPopulation[i];</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num; i &lt; subPopulation.size(); ++i)</span><br><span class="line">        <span class="keyword">delete</span> subPopulation[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>变异</strong>，使用最基本的基因变异的原理，种群中每个个体的每个顾客看作一个基因，基因突变则看成为该顾客重新选择一个对应的可用的设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 变异</span><br><span class="line">void mutate(problem* p) &#123;</span><br><span class="line">    for(int i = 0; i &lt; POSIZE; ++i) &#123;</span><br><span class="line">        double pro = (rand() % 100) * 1.0 / 100;</span><br><span class="line">        if(pro &lt;= PMUTATION) &#123;</span><br><span class="line">            for(int j = 0; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">                int newFac = rand() % p-&gt;numOfFac;</span><br><span class="line">                population[i]-&gt;freeCapacity[population[i]-&gt;cusToFac[j]] += p-&gt;cusDemand[j];</span><br><span class="line">                while (p-&gt;cusDemand[j] &gt; population[i]-&gt;freeCapacity[newFac])</span><br><span class="line">                    newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">                population[i]-&gt;freeCapacity[newFac] -= p-&gt;cusDemand[j];</span><br><span class="line">                population[i]-&gt;cusToFac[j] = newFac;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><blockquote><p><a href="https://github.com/Liu-YT/CFL-Problem/tree/master/result/csv" target="_blank" rel="noopener">完整结果</a></p></blockquote><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><div class="table-container"><table><thead><tr><th>Problem</th><th>Result</th><th>Time(s)</th></tr></thead><tbody><tr><td>p1</td><td>9075</td><td>0.729</td></tr><tr><td>p2</td><td>8315</td><td>0.685</td></tr><tr><td>p3</td><td>10076</td><td>0.684</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>p68</td><td>26452</td><td>51.886</td></tr><tr><td>p69</td><td>35383</td><td>54.413</td></tr><tr><td>p70</td><td>50826</td><td>51.292</td></tr><tr><td>p71</td><td>39417</td><td>51.519</td></tr></tbody></table></div><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><div class="table-container"><table><thead><tr><th>Problem</th><th>Result</th><th>Time(s)</th></tr></thead><tbody><tr><td>p1</td><td>10220</td><td>10.727</td></tr><tr><td>p2</td><td>9493</td><td>11.888</td></tr><tr><td>p3</td><td>11653</td><td>10.831</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>p68</td><td>33324</td><td>43.275</td></tr><tr><td>p69</td><td>38309</td><td>44.419</td></tr><tr><td>p70</td><td>59304</td><td>38.904</td></tr><tr><td>p71</td><td>46541</td><td>37.729</td></tr></tbody></table></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从结果的运行时间可用比较直观的看出两个算法对于数据量比较大的时候都比较费时，可以控制时间但是会导致解的变差，增大运算此时解可能会更加好，但是时间太长，难以接受</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Liu-YT/CFL-Problem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="NP-hard" scheme="http://yoursite.com/tags/NP-hard/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 6 BoltDB学习与简单剖析</title>
    <link href="http://yoursite.com/2018/12/14/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-6-BoltDB%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/14/服务计算-6-BoltDB学习与简单剖析/</id>
    <published>2018-12-14T07:29:51.000Z</published>
    <updated>2018-12-14T13:08:54.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BoltDB-介绍"><a href="#BoltDB-介绍" class="headerlink" title="BoltDB 介绍"></a>BoltDB 介绍</h1><blockquote><p>Bolt is a pure Go key/value store inspired by Howard Chu’s LMDB project. The goal of the project is to provide a simple, fast, and reliable database for projects that don’t require a full database server such as Postgres or MySQL.<br>Since Bolt is meant to be used as such a low-level piece of functionality, simplicity is key. The API will be small and only focus on getting values and setting values. That’s it.</p></blockquote><p><code>BoltDB</code>是一个嵌入式<code>key/value</code>的数据库，即只需要将其链接到你的应用程序代码中即可使用<code>BoltDB</code>提供的<code>API</code>来高效的存取数据。而且<code>BoltDB</code>支持完全可序列化的<code>ACID事务</code>，让应用程序可以更简单的处理复杂操作</p><h1 id="BoltDB-使用"><a href="#BoltDB-使用" class="headerlink" title="BoltDB 使用"></a>BoltDB 使用</h1><p><strong><code>BoltDB</code>使用<code>Golang</code>开发</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/boltdb/bolt</span></span><br></pre></td></tr></table></figure><h2 id="创建和启动数据库"><a href="#创建和启动数据库" class="headerlink" title="创建和启动数据库"></a>创建和启动数据库</h2><p>使用<code>bolt.Open()</code>函数进行创建或者打开数据库<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := bolt.Open(<span class="string">"data.db"</span>, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p>该命令将打开当前目录下<code>data.db</code>文件，<strong>如果该文件不存在，则将被创建</strong>。</p><p><code>Open</code>方法三个参数</p><ul><li>第一个参数为路径，指定需要打开的数据库，不存在将会被创建</li><li>第二个参数为文件操作权限</li><li>第三个参数为可选参数，内部可以配置只读和超时等</li></ul><p><code>BoltDB</code>是文件操作类型的数据库，打开数据库后将有一个文件锁，不允许多个进程同时打开同一个数据库。如果多个同时操作的话后者会被挂起直到前者关闭操作为止，为了避免无限等待，在打开数据库的时候可以配置超时时间<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := bolt.Open(<span class="string">"my.db"</span>, <span class="number">0600</span>, &amp;bolt.Options&#123;Timeout: <span class="number">1</span> * time.Second&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="读写事务"><a href="#读写事务" class="headerlink" title="读写事务"></a>读写事务</h2><p>对于读写事务，可以使用<code>DB.Update</code>来完成<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>DB.Update</code>方法可以对数据库进行读写操作。在闭包内部，可以获得数据库的一致视图。 在结尾返回<code>nil</code>来提交事务，也可以通过返回错误随时回滚事务。 读写事务中允许所有数据库操作，始终检查返回错误，因为它将报告可能导致您的事务无法完成的任何磁盘故障。 如果您在关闭中返回错误，它将被传递。</p><ul><li><p><strong>Example</strong><br>  需要注意在读写事务以及只读事务中，如果没有相应的<code>Bucket</code>，是不能直接对其进行操作的，必须先创建</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create bucket</span></span><br><span class="line">db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := tx.CreateBucketIfNotExists([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    CheckErr(err)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  往<code>peopleBucket</code>桶中插入一个<code>People</code>，其<code>key</code>值为其ID，<code>value</code>为People的序列化后的字符串</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it = model.People&#123;&#125;</span><br><span class="line">it.ID = <span class="string">"1"</span></span><br><span class="line">db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    b := tx.Bucket([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    jsons, errs := json.Marshal(it)</span><br><span class="line">    CheckErr(errs)</span><br><span class="line">    err := b.Put([]<span class="keyword">byte</span>(it.ID), jsons)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h2><p>对于只读事务，使用<code>DB.View</code>来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.View(func(tx *bolt.Tx) error &#123;</span><br><span class="line">    ...</span><br><span class="line">    return nil</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在此闭包中获得数据库的一致视图，但是，只读事务中不允许进行变更操作。 只能在只读事务中检索存储桶，检索值和复制数据库。需要注意的是读写事务和只读事务不应该在同一个<code>goroutine</code>里同时打开，这是由于读写事务需要周期性重新映射数据文件，与只读事务发生冲突，可能造成死锁。<code>BoltDB</code>一次只允许一个读写事务，单一次允许多个只读事务，保持数据一致性。</p><ul><li><strong>Example</strong><br>  获取<code>peopleBucket</code>桶中<code>key</code>值为<code>&quot;1&quot;</code>的<code>value</code>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    b := tx.Bucket([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    v := b.Get([]<span class="keyword">byte</span>(<span class="string">"1"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, v)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="批量更新事务"><a href="#批量更新事务" class="headerlink" title="批量更新事务"></a>批量更新事务</h2><p>每个<code>DB.Update()</code>等待磁盘提交写入。 通过将多个更新与<code>DB.Batch()</code>函数组合，可以最大限度地减少此开销<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.Batch(func(tx *bolt.Tx) error &#123;</span><br><span class="line">    ...</span><br><span class="line">    return nil</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在整个批处理的过程中，如果某个事务失败了，批处理将会多次调用给定的函数。函数只有在<code>DB.Batch</code>返回成功才表示成功完成。如果批处理中途失败了，整个事务将会回滚。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更多详细的用法请参考 <a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">boltdb/bolt</a></p><h1 id="BoltDB-源码简单剖析"><a href="#BoltDB-源码简单剖析" class="headerlink" title="BoltDB 源码简单剖析"></a>BoltDB 源码简单剖析</h1><p>关于源码部分，纯属一些个人的理解以及网上相关一些讲解，对于某些部分可能理解不是很到位，还望多多指正，源码部分设计到比较底层具体文件存储部分感觉还是很难理解的，此部分只是简单的摸索一下其中的机制与一些方法的执行过程</p><p>首先先探索一下一开始启动数据库中其是设置文件锁<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock file so that other processes using Bolt in read-write mode cannot</span></span><br><span class="line"><span class="comment">// use the database  at the same time. This would cause corruption since</span></span><br><span class="line"><span class="comment">// the two processes would write meta pages and free pages separately.</span></span><br><span class="line"><span class="comment">// The database file is locked exclusively (only one process can grab the lock)</span></span><br><span class="line"><span class="comment">// if !options.ReadOnly.</span></span><br><span class="line"><span class="comment">// The database file is locked using the shared lock (more than one process may</span></span><br><span class="line"><span class="comment">// hold a lock at the same time) otherwise (options.ReadOnly is set).</span></span><br><span class="line"><span class="keyword">if</span> err := flock(db, mode, !db.readOnly, options.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    _ = db.<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>呃其实这部分注释已经解释的很明确了，但是还是看看这个<code>flock</code>函数吧<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flock acquires an advisory lock on a file descriptor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flock</span><span class="params">(db *DB, mode os.FileMode, exclusive <span class="keyword">bool</span>, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t time.Time</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// If we're beyond our timeout then return an error.</span></span><br><span class="line"><span class="comment">// This can only occur after we've attempted a flock once.</span></span><br><span class="line"><span class="keyword">if</span> t.IsZero() &#123;</span><br><span class="line">t = time.Now()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> timeout &gt; <span class="number">0</span> &amp;&amp; time.Since(t) &gt; timeout &#123;</span><br><span class="line"><span class="keyword">return</span> ErrTimeout</span><br><span class="line">&#125;</span><br><span class="line">flag := syscall.LOCK_SH</span><br><span class="line"><span class="keyword">if</span> exclusive &#123;</span><br><span class="line">flag = syscall.LOCK_EX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise attempt to obtain an exclusive lock.</span></span><br><span class="line">err := syscall.Flock(<span class="keyword">int</span>(db.file.Fd()), flag|syscall.LOCK_NB)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != syscall.EWOULDBLOCK &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for a bit and try again.</span></span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来其一开始先定义一个变量，用一个死循环在运行这段代码，如果在设置的<code>timeout</code>时间段内仍然得不到这个文件的锁，则将返回一个超时错误，如果没有设置<code>timeout</code>，则其将一直等待，直到获得该文件的锁，即获得该文件的使用权，其实这与操作系统中的进程同步异步使用一个互斥锁的机制是相似的。接着再来看看其对于未创建过的数据库是如何创建的以及如何对其初始化<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the database if it doesn't exist.</span></span><br><span class="line"><span class="keyword">if</span> info, err := db.file.Stat(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> info.Size() == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize new files with meta pages.</span></span><br><span class="line">    <span class="keyword">if</span> err := db.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Read the first meta page to determine the page size.</span></span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">0x1000</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">if</span> _, err := db.file.ReadAt(buf[:], <span class="number">0</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        m := db.pageInBuffer(buf[:], <span class="number">0</span>).meta()</span><br><span class="line">        <span class="keyword">if</span> err := m.validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// If we can't read the page size, we can assume it's the same</span></span><br><span class="line">            <span class="comment">// as the OS -- since that's how the page size was chosen in the</span></span><br><span class="line">            <span class="comment">// first place.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// If the first page is invalid and this OS uses a different</span></span><br><span class="line">            <span class="comment">// page size than what the database was created with then we</span></span><br><span class="line">            <span class="comment">// are out of luck and cannot access the database.</span></span><br><span class="line">            db.pageSize = os.Getpagesize()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            db.pageSize = <span class="keyword">int</span>(m.pageSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其首先先对文件是否存在以及文件的类型进行判断，调用<code>db.file.Stat</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stat returns the FileInfo structure describing file.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Stat</span><span class="params">()</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> file == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalid</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> file.isdir() &#123;</span><br><span class="line">        <span class="comment">// I don't know any better way to do that for directory</span></span><br><span class="line">        <span class="keyword">return</span> Stat(file.dirinfo.path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isNulName(file.name) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;devNullStat, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ft, err := file.pfd.GetFileType()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">"GetFileType"</span>, file.name, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> ft &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.FILE_TYPE_PIPE, syscall.FILE_TYPE_CHAR:</span><br><span class="line">        <span class="keyword">return</span> &amp;fileStat&#123;name: basename(file.name), filetype: ft&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs, err := newFileStatFromGetFileInformationByHandle(file.name, file.pfd.Sysfd)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    fs.filetype = ft</span><br><span class="line">    <span class="keyword">return</span> fs, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断其实也是比较简单的吧，还是接着看其是如何初始化一个新的数据库<code>db.init()</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init creates a new database file and initializes its meta pages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">init</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Set the page size to the OS page size.</span></span><br><span class="line">db.pageSize = os.Getpagesize()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create two meta pages on a buffer.</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, db.pageSize*<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">p := db.pageInBuffer(buf[:], pgid(i))</span><br><span class="line">p.id = pgid(i)</span><br><span class="line">p.flags = metaPageFlag</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the meta page.</span></span><br><span class="line">m := p.meta()</span><br><span class="line">m.magic = magic</span><br><span class="line">m.version = version</span><br><span class="line">m.pageSize = <span class="keyword">uint32</span>(db.pageSize)</span><br><span class="line">m.freelist = <span class="number">2</span></span><br><span class="line">m.root = bucket&#123;root: <span class="number">3</span>&#125;</span><br><span class="line">m.pgid = <span class="number">4</span></span><br><span class="line">m.txid = txid(i)</span><br><span class="line">m.checksum = m.sum64()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write an empty freelist at page 3.</span></span><br><span class="line">p := db.pageInBuffer(buf[:], pgid(<span class="number">2</span>))</span><br><span class="line">p.id = pgid(<span class="number">2</span>)</span><br><span class="line">p.flags = freelistPageFlag</span><br><span class="line">p.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write an empty leaf page at page 4.</span></span><br><span class="line">p = db.pageInBuffer(buf[:], pgid(<span class="number">3</span>))</span><br><span class="line">p.id = pgid(<span class="number">3</span>)</span><br><span class="line">p.flags = leafPageFlag</span><br><span class="line">p.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the buffer to our data file.</span></span><br><span class="line"><span class="keyword">if</span> _, err := db.ops.writeAt(buf, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fdatasync(db); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这感觉还是能明白在干嘛的，其采用单个文件来将数据存储在磁盘上，该文件的前4个<code>page</code>是固定的，分别是 <code>meta page</code>、<code>meta page</code>、<code>freelist</code>、<code>leaf page</code>，但是对于这4个<code>page</code>，到底是什么就让人很头大了。先看<code>meta page</code>的定义<code>p.meta()</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// meta returns a pointer to the metadata section of the page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *page)</span> <span class="title">meta</span><span class="params">()</span> *<span class="title">meta</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (*meta)(unsafe.Pointer(&amp;p.ptr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还是先看看其基础的<code>page</code>的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> page <span class="keyword">struct</span> &#123;</span><br><span class="line">    id       pgid</span><br><span class="line">    flags    <span class="keyword">uint16</span></span><br><span class="line">    count    <span class="keyword">uint16</span></span><br><span class="line">    overflow <span class="keyword">uint32</span></span><br><span class="line">    ptr      <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>page</code>是<code>boltdb</code>持久化时，与磁盘相关的数据结构。<code>page</code>的大小采用操作系统内存页的大小，即<code>getpagesize</code>系统调用的返回值。<code>id</code>为<code>page</code>的序号，<code>flags</code>表示<code>page</code>的类型，有<code>branchPageFlag/leafPageFlag/metaPageFlag/freelistPageFlag</code>几种，<code>count</code>当<code>page</code>是<code>freelistPageFlag</code>类型时，存储的是<code>freelist</code>中<code>pgid</code>数组中元素的个数;当<code>page</code>时其他类型时，存储的是<code>inode</code>的个数，<code>overflow</code>记录<code>page</code>中数据量超过一个<code>page</code>所能存储的大小时候需要额外的<code>page</code>的数目<br>每个page对应对应一个磁盘上的数据块。这个数据块的layout为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| page struct data | page element items | k-v pairs |</span><br></pre></td></tr></table></figure></p><p>其分为3个部分：</p><ul><li>第一部分<code>page struct data</code>是该<code>page</code>的<code>header</code>，存储的就是<code>pagestruct</code>的数据。</li><li>第二部分<code>page element items</code>其实就是<code>node</code>的里<code>inode</code>的持久化部分数据。</li><li>第三部分<code>k-v pairs</code>存储的是<code>inode</code>里具体的<code>key-value</code>数据。</li></ul></blockquote><p>接着就可以探索一下<code>meta page</code>是什么玩意了<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> meta <span class="keyword">struct</span> &#123;</span><br><span class="line">    magic    <span class="keyword">uint32</span>  <span class="comment">// 存储魔数0xED0CDAED</span></span><br><span class="line">    version  <span class="keyword">uint32</span>  <span class="comment">// 标明存储格式的版本，现在是2</span></span><br><span class="line">    pageSize <span class="keyword">uint32</span>  <span class="comment">// 标明每个page的大小</span></span><br><span class="line">    flags    <span class="keyword">uint32</span>  <span class="comment">// 当前已无用</span></span><br><span class="line">    root     bucket  <span class="comment">// 根Bucket</span></span><br><span class="line">    freelist pgid    <span class="comment">// 标明当前freelist数据存在哪个page中</span></span><br><span class="line">    pgid     pgid    <span class="comment">//</span></span><br><span class="line">    txid     txid    <span class="comment">//</span></span><br><span class="line">    checksum <span class="keyword">uint64</span>  <span class="comment">// 以上数据的校验和，校验数据是否损坏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着再看看<code>freelist</code>是什么，关于<code>freelist</code>的定义需要一层层不断找，比较繁琐<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// freelist represents a list of all pages that are available for allocation.</span></span><br><span class="line"><span class="comment">// It also tracks pages that have been freed but are still in use by open transactions.</span></span><br><span class="line"><span class="keyword">type</span> freelist <span class="keyword">struct</span> &#123;</span><br><span class="line">ids     []pgid          <span class="comment">// all free and available free page ids.</span></span><br><span class="line">pending <span class="keyword">map</span>[txid][]pgid <span class="comment">// mapping of soon-to-be free page ids by tx.</span></span><br><span class="line">cache   <span class="keyword">map</span>[pgid]<span class="keyword">bool</span>   <span class="comment">// fast lookup of all free and pending page ids.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>依赖注释我们已经可以大概猜测出<code>freelist</code>的作用，其是<code>BoltDb</code>实现磁盘空间的重复利用机制中需要用到的文件<code>page</code>缓存</p><blockquote><p><code>ids</code>记录了当前缓存着的空闲<code>page</code>的<code>pgid</code>，<code>cache</code>中记录的也是这些<code>pgid</code>，采用<code>map</code>记录 方便快速查找。</p><p>当用户需要<code>page</code>时，调用<code>freelist.allocate(n int) pgid</code>，其中n为需要的<code>page</code>数量，其会遍历<code>ids</code>，从中 挑选出连续n个空闲的<code>page</code>，然后将其从缓存中剔除，然后将其实的<code>page-id</code>返回给调用者。当不存在满足需求的 page时，返回0，因为文件的起始2个page固定为meta page，因此有效的page-id不可能为0。</p><p>当某个写事务产生无用page时，将调用<code>freelist.free(txid txid, p *page)</code>将指定page p放入pending池和 cache中。当下一个写事务开启时，会将没有Tx引用的pending中的page搬移到ids缓存中。之所以这样做， 是为了支持事务的回滚和并发读事务，从而实现<code>MVCC</code>。</p><p>当发起一个读事务时，<code>Tx</code>单独复制一份<code>meta</code>信息，从这份独有的<code>meta</code>作为入口，可以读出该<code>meta</code>指向的数据， 此时即使有一个写事务修改了相关key的数据，新修改的数据只会被写入新的page，读事务持有的page会进入pending 池，因此该读事务相关的数据并不会被修改。只有该page相关的读事务都结束时，才会从pending池进入到cache池 中，从而被复用修改。</p><p>当写事务更新数据时，并不直接覆盖老数据，而且分配一个新的page将更新后的数据写入，然后将老数据占用的page 放入pending池，建立新的索引。当事务需要回滚时，只需要将pending池中的page释放，将索引回滚即完成数据的 回滚。这样加速了事务的回滚。减少了事务缓存的内存使用，同时避免了对正在读的事务的干扰。</p></blockquote><p>到这里我们也大概了解到<code>BoltDb</code>中部分的机制，说实话关于一些涉及底层方面的有点难以理解，主要关于数据库存储以及操作系统方面的知识面太浅了，之前没有好好学习，还是得先去好好看看数据库和文件系统相关以及存储相关的知识再继续尝试学习源码了吧</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">boltdb/bolt</a></li><li><a href="https://zhuanlan.zhihu.com/p/27444660" target="_blank" rel="noopener">聊聊BoltDB：简单使用</a></li><li><a href="https://studygolang.com/articles/9939" target="_blank" rel="noopener">boltdb持久化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BoltDB-介绍&quot;&gt;&lt;a href=&quot;#BoltDB-介绍&quot; class=&quot;headerlink&quot; title=&quot;BoltDB 介绍&quot;&gt;&lt;/a&gt;BoltDB 介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Bolt is a pure Go key/value s
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>132. Palindrome Partitioning II</title>
    <link href="http://yoursite.com/2018/12/06/132-Palindrome-Partitioning-II/"/>
    <id>http://yoursite.com/2018/12/06/132-Palindrome-Partitioning-II/</id>
    <published>2018-12-06T06:18:55.000Z</published>
    <updated>2018-12-06T08:03:24.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p><p><strong>Example:</strong></p><pre><strong>Input:</strong>&nbsp;"aab"<strong>Output:</strong> 1<strong>Explanation:</strong> The palindrome partitioning ["aa","b"] could be produced using 1 cut.</pre></div></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题给出一个字符串，求出将该字符串最少分割多少次可以实现其分割后的子串都是回文串</li><li>本题求解比较复杂，主要思路是先求字符串某个区间内的子串是否是回文串然后，如果是说明可以被分割，否则不能被进行分割(因为分割以后也不是回文串，需要继续被分割)</li><li>本题使用<code>isPal[i,j]</code>记录字符串在<code>[i,j]</code>是否是一个回文串，使用<code>cut[i]</code>记录字符串在区间<code>[i, size]</code>被分割后所有子串都为回文串需要被分割多少次，因此我们需要分类进行讨论，假设当前的区间为<code>[i,j]</code>    <ul><li>首先需要对区间<code>[i,j]</code>是否是一个回文串进行判断<ul><li><code>i &lt; j</code><ul><li>不满足区间的基本要求</li></ul></li><li><code>i == j</code><ul><li>显然是一个回文串，<code>isPal[i,j] = true</code></li></ul></li><li><code>j == i+1</code> <ul><li>如果<code>s[i] == s[j]</code>，则这也是回文串，即<code>isPal[i,j] = true</code>，否则不是一个回文串</li></ul></li><li><code>i+1 &lt; j</code><ul><li>这部分判断比较麻烦，我们利用动态规划的思想，如果在区间<code>[i+1,j-1]</code>的子串是一个回文串，那么如果<code>s[i] == s[j]</code>的话，则该子串也是一个回文串，即<code>isPal[i,j] = true</code>，否则的话不是</li></ul></li></ul></li><li>判断完该区间的子串是否是回文串后，我们需要对<code>cut[i]</code>进行更新。如果<code>[i,j]</code>是一个回文串(<code>isPal[i,j] == true</code>)的话，说明我们对于区间<code>[i, size)</code>有了一个新的分割方法，即在原基础上变成<code>[i, j] + [j+1, size)</code>，因此我们可以更新<code>cut[i]</code><ul><li><code>cut[i] = min(cut[i], cut[j+1] + 1)</code></li><li>此处将原区间<code>[i, j]</code>分割成<code>[i, j] + [j+1, size)</code>两部分，需要在<code>c[j+1]</code>次的基础上再加一次分割操作，即分割次数为<code>c[j+1]+1</code>，但是我们需要注意的一点是对于第一次分割即<code>[size-1, size)</code>区间操作，其实分割次数是<code>0</code>，不需要对其进行分割，但是为了写法统一还是加1，后面的操作也不断使用到本次分割，因此对于每次的<code>cut[i]</code>都比实际多了1。因此最后返回字符串最小分割次数时候，即分割区间<code>[0, size)</code>的分割次数为<code>cut[0]-1</code></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断区间[i, j]的字符是否是回文串</span></span><br><span class="line">        <span class="keyword">bool</span> isPal[s.size()][s.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录区间[i, size]需要切割的次数</span></span><br><span class="line">        <span class="keyword">int</span> cut[s.size()+<span class="number">1</span>];</span><br><span class="line">        cut[s.size()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cut[i] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.size(); ++j) &#123;</span><br><span class="line">                isPal[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == j || i+<span class="number">1</span> == j &amp;&amp; s[i] == s[j] || i+<span class="number">1</span> &lt; j &amp;&amp; isPal[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                    isPal[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    cut[i] = min(cut[i], cut[j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cut[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given a string &lt;em&gt;s&lt;/em&gt;, partition &lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>57. Insert Interval</title>
    <link href="http://yoursite.com/2018/12/06/57-Insert-Interval/"/>
    <id>http://yoursite.com/2018/12/06/57-Insert-Interval/</id>
    <published>2018-12-06T06:15:54.000Z</published>
    <updated>2018-12-06T06:52:38.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]<strong>Output:</strong> [[1,5],[6,9]]</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code><strong>Output:</strong> [[1,2],[3,10],[12,16]]<strong>Explanation:</strong> Because the new interval <code>[4,8]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</pre></div></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这道题目给出一个有序的区间集合，再给出一个新的区间，将其合并进去区间集合中，然后输出合并后的区间集合</li><li>这道题需要进行分类讨论，主要针对新的区间以及原区间集合的边界问题进行讨论。此处假设新的区间<code>newInterval</code>表现形式为<code>[newStart, newEnd]</code>，当前遍历到区间集合内的区间为<code>[start, end]</code>，此处需要注意的一点是区间集合内的区间都是已经排好序的，即当前区间<code>end</code>小于下一个区间的<code>start</code>。此处讨论主要分区间重叠的情况与不重叠两个方向进行讨论<ul><li>区间不重叠 <ul><li>区间不重叠，说明新的区间无法与当前区间进行合并，因此我们只需要考虑是否将新的区间加入集合以及将当前区间加入的问题即可</li><li><code>newEnd &lt; start</code><ul><li>此时说明新区间在当前区间的前面，但是我们需要判断新的区间是否已经加入区间集合中，如果已经加入，对新的区间无需任何操作，只需要加入当前区间即可，如果未加入，我们需要先加入新的区间（为了保证集合内区间也是排好序的），然后再加入当前区间</li></ul></li><li><code>newStart &gt; end</code><ul><li>无需考虑加入新区间问题，只需要把当前区间加入集合中即可</li></ul></li></ul></li><li>区间重叠<ul><li>当前的区间与新的区间出现重叠的情况，区间可以进行合并。我们不需要考虑是否将区间加入到集合中，因为可能与后面区间仍然可能重叠而需要合并的情况，因此只需要更新一下新的区间，等到不重叠的情况时候再考虑加入，<ul><li><code>newInterval.start = min(newInterval.start, intervals[i].start)</code></li><li><code>newInterval.end = max(newInterval.end, intervals[i].end)</code></li></ul></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; insert(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            v.push_back(newInterval);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isAdd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); ++i) &#123; </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(intervals[i].start &gt; newInterval.end) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isAdd) v.push_back(newInterval);</span><br><span class="line">                v.push_back(intervals[i]);</span><br><span class="line">                isAdd = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i].end &lt; newInterval.start) &#123;</span><br><span class="line">                v.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newInterval.start = min(newInterval.start, intervals[i].start);</span><br><span class="line">                newInterval.end = max(newInterval.end, intervals[i].end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isAdd) v.push_back(newInterval);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given a set of &lt;em&gt;non-overlapping&lt;/em
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>123. Best Time to Buy and Sell Stock III</title>
    <link href="http://yoursite.com/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/"/>
    <id>http://yoursite.com/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/</id>
    <published>2018-12-02T07:29:13.000Z</published>
    <updated>2018-12-02T08:42:07.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:&nbsp;</strong>You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> [3,3,5,0,0,3,1,4]<strong>Output:</strong> 6<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.&nbsp;            Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> [1,2,3,4,5]<strong>Output:</strong> 4<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.&nbsp;            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are&nbsp;            engaging multiple transactions at the same time. You must sell before buying again.</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> [7,6,4,3,1]<strong>Output:</strong> 0<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.</pre></div></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>本题题目意思比较简单，给出连续n天交易日的股票价格，问在其中什么时候买入什么时候卖出获得最大的收入，求出最大的收入值是多少。本题还有一点是比较关键的，<strong>最多允许两次交易</strong>，并且交易日期中买入股票和卖出股票不能在同一天。</li></ul><h4 id="解法-1-超时"><a href="#解法-1-超时" class="headerlink" title="解法 1 - 超时"></a>解法 1 - <code>超时</code></h4><ul><li><p>以某个交易日为分界线将总时间分成两个时间段，计算该天前包括当天的交易获利以及该天以后时间段的交易获利，最后计算总和获得交易两次的最大获利</p><ul><li>时间复杂度 - $O(n^2)$</li><li>空间复杂度 - $O(n)$</li></ul></li><li><p>实现代码</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre[prices.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> post[prices.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求某天前(包括当天)成交的最大利润</span></span><br><span class="line">        <span class="keyword">int</span> prebase = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> preMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">            preMaxProfit = max(preMaxProfit, prices[i] - prebase);</span><br><span class="line">            pre[i] = preMaxProfit;</span><br><span class="line">            prebase = min(prebase, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求某天后成交的最大利润</span></span><br><span class="line">        <span class="keyword">int</span> postBase = prices[prices.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> postMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            postMaxProfit = max(postMaxProfit, postBase - prices[i]);</span><br><span class="line">            post[i<span class="number">-1</span>] = postMaxProfit;</span><br><span class="line">            postBase = max(postBase, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prices.size(); ++j)</span><br><span class="line">                maxProfit = max(maxProfit, pre[i] + post[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>结果 - <code>超时</code><br><img src="/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/1.png" alt="preview"></p></li></ul><h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法 2"></a>解法 2</h4><ul><li><p>该解法其实是总结了一下<code>解法 1</code>以及参考了一下评论里面的解法，其实现起来也比较简单，但是理解起来稍微费解一点，其维护四个变量，<code>buy1</code>表示第一次买股票的花费，<code>sell1</code>表示第一次交易股票后获得的利润，<code>buy2</code>表示第二次买股票后剩余的钱（第一次交易利润-购买的股票价格），<code>sell2</code>表示第二次交易后剩余的钱，即两次交易下来最后的盈利。当然也不一定需要两次交易，加入交易以后亏钱的话是不会进行交易的。</p><ul><li>时间复杂度 - $O(n)$</li><li>空间复杂度 - $O(1)$</li></ul></li><li><p>实现代码</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> buy1 = INT_MIN, buy2 = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>, sell2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices)&#123;</span><br><span class="line">            buy1 = max(buy1, -price);</span><br><span class="line">            sell1 = max(sell1, buy1 + price);</span><br><span class="line">            buy2 = max(buy2, sell1 - price);</span><br><span class="line">            sell2 = max(sell2, buy2 + price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解法-3"><a href="#解法-3" class="headerlink" title="解法 3"></a>解法 3</h4><ul><li>这个解法与解法 2的思路类似，但是做了一定的拓展，其不仅仅适用于只交易2次，也可以拓展适用于交易<code>k</code>次的情况。对于<code>profit[i][j]</code>即交易日<code>i</code>到交易日<code>j</code>这个时间段买入的收入，其应该是大于等于<code>profit[i][j-1]</code>，即大于前一个时间都的利润，同时其也可以在第<code>j</code>个交易日卖出自己的股票，此时收益为<code>余额 + 卖出价格</code>，此时当前时间段最大利润值为<code>余额 + 卖出价格</code>与<code>profit[i][j-1]</code>的最大值</li><li>实现代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交易两次，得到的利润</span></span><br><span class="line">        <span class="keyword">int</span> profit[<span class="number">3</span>][prices.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prices.size(); ++j)</span><br><span class="line">                profit[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> balance = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; prices.size(); j++) &#123;</span><br><span class="line">                profit[i][j] = max(profit[i][j - <span class="number">1</span>], balance + prices[j]);</span><br><span class="line">                balance = max(balance, profit[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit[<span class="number">2</span>][prices.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Say you have an array for which the &lt;e
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>115. Distinct Subsequences</title>
    <link href="http://yoursite.com/2018/11/24/115-Distinct-Subsequences/"/>
    <id>http://yoursite.com/2018/11/24/115-Distinct-Subsequences/</id>
    <published>2018-11-24T12:07:25.000Z</published>
    <updated>2018-11-24T12:57:47.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string <code>S</code> and a string <code>T</code>, count the number of distinct subsequences of <code>S</code>which equals <code>T</code>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 5 ways you can generate &quot;bag&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br></pre></td></tr></table></figure></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>本题是一道动态规划类型的问题，给出两个字符串<code>s</code>、<code>t</code>，计算<code>S</code>的不同子序列中等于<code>T</code>的子序列数量。</li><li>一开始有点迷茫，不知道其中的转移方程是怎样的，只能举例然后观察一下其中的状态转移方程了。使用<code>dp[i][j]</code>记录字符串<code>S</code>的前<code>i</code>个字符的子串中有多少个与字符串<code>T</code>的前<code>j</code>个字符构成的子串相等的子序列。</li><li><strong>Example 1</strong> - <code>S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</code></li></ul><div class="table-container"><table><thead><tr><th>T \ S</th><th>$\emptyset$</th><th>r</th><th>a</th><th>b</th><th>b</th><th>b</th><th>i</th><th>t</th></tr></thead><tbody><tr><td>$\emptyset$</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>r</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>a</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>b</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>b</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>3</td><td>3</td><td>3</td></tr><tr><td>i</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td></tr><tr><td>t</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td></tr></tbody></table></div><ul><li><strong>Example 2</strong> - <code>S = &quot;babgbag&quot;, T = &quot;bag&quot;</code></li></ul><div class="table-container"><table><thead><tr><th>T \ S</th><th>$\emptyset$</th><th>b</th><th>a</th><th>b</th><th>g</th><th>b</th><th>a</th><th>g</th></tr></thead><tbody><tr><td>$\emptyset$</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>b</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>a</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>4</td><td>4</td></tr><tr><td>g</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>5</td></tr></tbody></table></div><ul><li>通过对样例的分析，我们可以得到<code>dp[i][j] &gt;= dp[i][j-1]</code>在<code>j-1&gt;=0</code>的条件下。同时当<code>T</code>为空串的时候，<code>dp[i][0] = 1</code>，因为空串是任一字符串的子串。再仔细观察，可以得到当<code>s[i-1] == t[j-1]</code>的时候，<code>dp[i][j] = dp[i-1][j] + dp[i-1][j-1]</code>。综合起来，我们可以得到状态转移的表示:<code>dp[i][j] = dp[i-1][j] + (s[i-1] == t[j-1] ? dp[i-1][j-1] : 0);</code></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[s.size() + <span class="number">1</span>][t.size() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.size(); ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.size(); ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + (s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] ? dp[i<span class="number">-1</span>][j<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][t.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a string &lt;code&gt;S&lt;/code&gt; and a string &lt;code&gt;T&lt;/code&gt;, count the n
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>120. Triangle</title>
    <link href="http://yoursite.com/2018/11/24/120-Triangle/"/>
    <id>http://yoursite.com/2018/11/24/120-Triangle/</id>
    <published>2018-11-24T03:33:27.000Z</published>
    <updated>2018-11-24T04:11:08.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><pre>[    [<strong>2</strong>],    [<strong>3</strong>,4],    [6,<strong>5</strong>,7],    [4,<strong>1</strong>,8,3]]</pre><p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p><p><strong>Note:</strong></p><p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p></div></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>题意分析：本题是一道动态规划类型的题目，给出一个三角形，每个位置有一个权值，求其一条经过每层的权值最小的路径的权值是多少。</li><li>动态规划 <ul><li>思路 1<ul><li>寻找一条由顶向下的路径，使用<code>path[i][j]</code>表示从顶点<code>(0,0)</code>到结点<code>(i,j)</code>的路径权重<ul><li>主要考虑当前结点<code>（i，j）</code>可以选择的路径<ul><li>考虑从<code>(i-1, j)</code>到达该节点的路径 — <code>(j &lt; triangle[i-1].size())</code></li><li>考虑从<code>(i-1, j-1)</code>到达该节点的路径    — <code>(j - 1 &gt;= 0)</code></li></ul></li></ul></li></ul></li><li>思路 2<ul><li>当然本题也可以考虑从底向顶寻找一条路径，同样使用使用<code>path[i][j]</code>表示从底部到结点<code>(i,j)</code>的路径权重<ul><li>初始最底部结点 <code>path[i][j] = triangle[i][j]</code></li><li>对于其余非底部结点，主要考虑当前结点<code>（i，j）</code>可以选择的路径<ul><li>考虑从<code>(i+1, j)</code>到达该节点的路径 </li><li>考虑从<code>(i+1, j+1)</code>到达该节点的路径</li><li><code>path[i][j] = min(path[i+1][j+1], path[i+1][j]) + triangle[i][j];</code></li></ul></li></ul></li></ul></li><li>时间复杂度 — $O(n^2)$</li><li>空间复杂度 — $O(n^2)$</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><ul><li><p>思路 1</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> path[triangle.size()][triangle[triangle.size()<span class="number">-1</span>].size()];</span><br><span class="line"></span><br><span class="line">        path[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangle.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); ++j) &#123;</span><br><span class="line">                path[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>) path[i][j] = path[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(j &lt; triangle[i<span class="number">-1</span>].size())</span><br><span class="line">                    path[i][j] = min(path[i<span class="number">-1</span>][j], path[i][j]); </span><br><span class="line">                path[i][j] += triangle[i][j];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; path[i][j] &lt;&lt; " ";</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triangle[triangle.size()<span class="number">-1</span>].size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(path[triangle.size()<span class="number">-1</span>][i] &lt; min)</span><br><span class="line">                min = path[triangle.size()<span class="number">-1</span>][i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>思路 2</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> path[triangle.size()][triangle[triangle.size()<span class="number">-1</span>].size()];</span><br><span class="line"></span><br><span class="line">        path[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = triangle[triangle.size() - <span class="number">1</span>].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            path[triangle.size() - <span class="number">1</span>][j] = triangle[triangle.size() - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = triangle[i].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                path[i][j] = min(path[i+<span class="number">1</span>][j+<span class="number">1</span>], path[i+<span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; path[i][j] &lt;&lt; " ";</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given a triangle, find the minimum pat
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>97. Interleaving String</title>
    <link href="http://yoursite.com/2018/11/23/97-Interleaving-String/"/>
    <id>http://yoursite.com/2018/11/23/97-Interleaving-String/</id>
    <published>2018-11-23T04:29:31.000Z</published>
    <updated>2019-01-15T04:24:44.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> s1 = "aabcc", s2 = "dbbca", <em>s3</em> = "aadbbcbcac"<strong>Output:</strong> true</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> s1 = "aabcc", s2 = "dbbca", <em>s3</em> = "aadbbbaccc"<strong>Output:</strong> false</pre></div></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这道题目的意思比较简单，给出三个字符串s1,s2,s3，问字符串s3是否由字符串s1和字符串s2交错而成的，返回真假即可。接下来我将会介绍以下几种解决的思路。    </li><li>思路<ul><li>动态规划问题需要先找到子问题，然后子问题递推得到问题的解决。本题我们可以将问题看成字符串s1的前<code>i</code>个字符与s2的前<code>j</code>个字符是否能交错生成s3的前<code>i+j-2</code>个字符。确认子问题后，我们需要找到其中的转移方程。     </li><li>维护一个二维的布尔数组<code>dp[s1.size][s2.size]</code>，，用<code>dp[i][j]</code>表示字符串s1的前<code>i</code>个字符即与字符串s2的前<code>j</code>个字符是否可以交错生成字符串s3的前<code>i+j-2</code>个字符的匹配情况。假如<code>dp[i][j]</code>为<code>true</code>，即表示字符串s3的前<code>i+j-2</code>个字符由字符串s1的前<code>i</code>个字符即与字符串s2的前<code>j</code>个字符交错生成，否则表示不可以。</li><li>对于<code>dp[i][j]</code>的表示，我们可以列出以下几种情况<ul><li><code>i = j = 0</code> <ul><li>空对空，肯定匹配。</li><li><code>dp[i][j] = true</code></li></ul></li><li><code>i != 0 &amp;&amp; j = 0</code><ul><li>此时可以看成s1的前i个字符串与s3的前i个字符串的匹配情况。</li><li><code>dp[i][0] = dp[i-1][0] &amp;&amp; (s1[i-1] == s3[i-1])</code></li></ul></li><li><code>i = 0 &amp;&amp; j != 0</code><ul><li>此时可以看成s2的前j个字符串与s3的前j个字符串的匹配情况。</li><li><code>dp[0][j] = dp[0][j-1] &amp;&amp; (s2[j-1] == s3[j-1])</code></li></ul></li><li><code>i &gt; 0 &amp;&amp; j &gt; 0</code><ul><li><code>dp[i][j]</code>需要考虑可能的组合情况。一个是<code>dp[i-1][j]</code>和<code>s1[i-1]与s3[i+j-1]</code>匹配的情况，另一个是<code>dp[i][j-1]</code>和<code>s2[j-1]与s3[i+j-1]</code>匹配的情况，我们需要将二者得到的匹配情况进行或操作来得到<code>dp[i][j]</code>。</li><li><code>dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]) || (dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1])</code></li></ul></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code class="lang-cpp">// dpclass Solution {public:    bool isInterleave(string s1, string s2, string s3) {        if (s1.size() + s2.size() != s3.size())    return false;        bool dp[s1.size() + 1][s2.size() + 1];        dp[0][0] = true;        for(int i = 1; i &lt;= s1.size(); ++i)            dp[i][0] = dp[i-1][0] &amp;&amp; (s1[i-1] == s3[i-1]);        for(int j = 1; j &lt;= s2.size(); ++j)            dp[0][j] = dp[0][j-1] &amp;&amp; (s2[j-1] == s3[j-1]);        for(int i = 1; i &lt;= s1.size(); ++i) {            for(int j = 1; j &lt;= s2.size(); ++j) {                dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]) || \                            (dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]);            }        }        return dp[s1.size()][s2.size()];    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt;, &lt;em&gt;s3
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>95. Unique Binary Search Trees II</title>
    <link href="http://yoursite.com/2018/11/23/95-Unique-Binary-Search-Trees-II/"/>
    <id>http://yoursite.com/2018/11/23/95-Unique-Binary-Search-Trees-II/</id>
    <published>2018-11-23T04:26:28.000Z</published>
    <updated>2019-01-15T04:22:44.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div><p>Given an integer <em>n</em>, generate all structurally unique         <strong>BST's</strong> (binary search trees) that store values 1 ...&nbsp;<em>n</em>.</p><p><strong>Example:</strong></p><pre><strong>Input:</strong> 3<strong>Output:</strong>[&nbsp; [1,null,3,2],&nbsp; [3,2,null,1],&nbsp; [3,1,null,null,2],&nbsp; [2,1,3],&nbsp; [1,null,2,null,3]]<strong>Explanation:</strong>The above output corresponds to the 5 unique BST's shown below:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</pre></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>本题的题意比较简单，给出二叉搜索树的节点数目<code>n</code>，求出可以构成多少中不同结构的二叉搜索树。</li><li>其实实现起来还是比较简单的。对于其中一个节点<code>i</code>，将其作为该树的根节点，然后其左边的元素都作为其左子树的元素，右边的元素都作为其右子树的元素，再通过递归得到其左子树和右子树的可能出现的情况的集合，然后再组合起来。一些需要注意的情况：<ul><li>递归的结束条件： 当该子树的起点大于终点的时候 — <code>start &gt; end</code>，递归结束，能够生成子树的情况为无，即为<code>NULL</code>。</li><li>对得到的左子树和右子树的返回情况需要判断其是否为空（可能没有不存在左或右节点的情况)，如果不存在，需要推入一个<code>NULL</code>，然后再进行组合，否则遍历组合的时候<code>left.size * right.size = 0</code>，将导致结果不全，只有左右子树都存在的结果。</li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">    * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    *     int val;</span></span><br><span class="line"><span class="comment">    *     TreeNode *left;</span></span><br><span class="line"><span class="comment">    *     TreeNode *right;</span></span><br><span class="line"><span class="comment">    *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">    * &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; v = myGenerate(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; myGenerate(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)<span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; left = myGenerate(start, i<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; right = myGenerate(i + <span class="number">1</span>, end);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(!left.size())left.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span>(!right.size())right.push_back(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; left.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; right.size(); ++k) &#123;</span><br><span class="line">                    TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    node-&gt;left = left[j];</span><br><span class="line">                    node-&gt;right = right[k];</span><br><span class="line">                    v.push_back(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div&gt;&lt;p&gt;Given an integer &lt;em&gt;n&lt;/em&gt;, generate all structurally unique    
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>87. Scramble String</title>
    <link href="http://yoursite.com/2018/11/21/87-Scramble-String/"/>
    <id>http://yoursite.com/2018/11/21/87-Scramble-String/</id>
    <published>2018-11-21T03:25:51.000Z</published>
    <updated>2018-11-21T03:33:45.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="question-description__3U1T" style="padding-top: 10px;"><div><p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p><p>Below is one possible representation of <em>s1</em> = <code>"great"</code>:</p><pre>    great    /    \   gr    eat  / \    /  \ g   r  e   at            / \           a   t</pre><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>"gr"</code> and swap its two children, it produces a scrambled string <code>"rgeat"</code>.</p><pre>    rgeat    /    \   rg    eat  / \    /  \ r   g  e   at            / \            a   t</pre><p>We say that <code>"rgeat"</code> is a scrambled string of <code>"great"</code>.</p><p>Similarly, if we continue to swap the children of nodes <code>"eat"</code> and <code>"at"</code>, it produces a scrambled string <code>"rgtae"</code>.</p><pre>    rgtae    /    \   rg    tae  / \    /  \ r   g  ta   e        / \       t   a</pre><p>We say that <code>"rgtae"</code> is a scrambled string of <code>"great"</code>.</p><p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> s1 = "great", s2 = "rgeat"<strong>Output:</strong> true</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> s1 = "abcde", s2 = "caebd"<strong>Output:</strong> false</pre></div></div><h3 id="题目分析以及解决思路"><a href="#题目分析以及解决思路" class="headerlink" title="题目分析以及解决思路"></a>题目分析以及解决思路</h3><ul><li>题目的意思也比较明确吧，给出两个字符串，将字符串分割成一个二叉树，并且可以交换非叶子节点，求解两个字符串能否相互构造。    </li></ul><h4 id="方法-1-递归"><a href="#方法-1-递归" class="headerlink" title="方法 1    - 递归"></a>方法 1    - <code>递归</code></h4><ul><li>思路：将字符串划分为两部分，分别递归得到结果是否<code>scramble</code>。需要考虑完备性，即需要将各种划分情况都需要考虑一遍。<ul><li>情况①： <code>s1</code>的前<code>k</code>个字符与<code>s2</code>的前<code>k</code>个字符进行判断同时 <code>s1</code>的后<code>size-k</code>个字符与<code>s2</code>的后<code>size-k</code>进行判断 — <code>isScramble(s1.substr(0, k), s2.substr(0, k)) &amp;&amp; isScramble(s1.substr(k, size-k), s2.substr(k, size-k))</code></li><li>情况②：    <code>s1</code>的前<code>k</code>个字符与<code>s2</code>的后<code>k</code>个字符进行判断同时 <code>s1</code>的后<code>size-k</code>个字符与<code>s2</code>的前<code>size-k</code>进行判断 — <code>isScramble(s1.substr(0, size-k), s2.substr(k, size-k)) &amp;&amp; isScramble(s1.substr(size-k, k), s2.substr(0, k))</code></li></ul></li><li>实现代码：<ul><li>如果不剪枝将会造成超时    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == s2)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() != s2.size())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = s1.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">int</span> letter[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            letter[s1[i] - <span class="string">'a'</span>] ++;</span><br><span class="line">            letter[s2[i] - <span class="string">'a'</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(letter[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; size; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>, k), s2.substr(<span class="number">0</span>, k)) &amp;&amp; isScramble(s1.substr(k, size-k), s2.substr(k, size-k)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>, size-k), s2.substr(k, size-k)) &amp;&amp; isScramble(s1.substr(size-k, k), s2.substr(<span class="number">0</span>, k)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="方法-2-动态规划"><a href="#方法-2-动态规划" class="headerlink" title="方法 2 - 动态规划"></a>方法 2 - <code>动态规划</code></h4><ul><li>我们需要维护一个变量<code>match[i][j][n]</code>，其中<code>i</code>为字符串<code>s1</code>的起始字符，<code>j</code>为字符串<code>s2</code>的起始字符，<code>n</code>为当前字符的长度，<code>match[i][j][len]</code>表示的是以<code>i</code>和<code>j</code>分别为<code>s1</code>和<code>s2</code>起点的长度为<code>len</code>的字符串是不是互为<code>scramble</code>。</li><li>如何得到<code>match[i][j][n]</code>，推导出其中的状态转移方程，其实与递归中的思路相同。我们对于当前情况，需要对于目前所有可能的划分都去检索一次，如果有一次划分是<code>scramble</code>的，则<code>match[i][j][len]</code>即为<code>true</code>，倘若所有的划分都不是<code>scramble</code>的，则<code>match[i][j][len]</code>即为<code>false</code>。关于划分，同时需要划分两种情况：<ul><li>情况①： <code>s1</code>以<code>i</code>为起始的前<code>k</code>个字符与<code>s2</code>以<code>j</code>为起始的前<code>k</code>个字符进行判断同时 <code>s1</code>的后<code>len-k</code>个字符与<code>s2</code>的后<code>len-k</code>进行判断 — <code>match[i][j][k] &amp;&amp; match[i+k][j+k][len-k]</code></li><li>情况②：    <code>s1</code>以<code>i</code>为起始的<code>k</code>个字符与<code>s2</code>以<code>j+len-k</code>为起始的<code>k</code>个字符进行判断同时 <code>s1</code>以<code>i+k</code>为起始的<code>len-k</code>个字符与<code>s2</code>以<code>j</code>为起始的<code>len-k</code>进行判断 — <code>match[i][j+len-k][k] &amp;&amp; match[i+k][j][len-k]</code></li></ul></li><li>实现代码：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s1.size() != s2.size())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!s1.size())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = s1.size();</span><br><span class="line">        <span class="comment">// s1_start, s2_start, match_len</span></span><br><span class="line">        <span class="keyword">bool</span> match[size][size][size+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j)</span><br><span class="line">                match[i][j][<span class="number">1</span>] = (s1[i] == s2[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= size; ++len) </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size - len; ++i) </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size - len; ++j) &#123;</span><br><span class="line">                    match[i][j][len] = <span class="literal">false</span>;<span class="comment">// initial</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; len; ++k) </span><br><span class="line">                        match[i][j][len] |= (match[i][j][k] &amp;&amp; match[i+k][j+k][len-k]) \</span><br><span class="line">                                            || (match[i][j+len-k][k] &amp;&amp; match[i+k][j][len-k]); </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> match[<span class="number">0</span>][<span class="number">0</span>][size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;question-description__3U1T&quot; style=&quot;padding-top: 10px;&quot;&gt;&lt;div&gt;&lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>63. Unique Paths II</title>
    <link href="http://yoursite.com/2018/11/21/63-Unique-Paths-II/"/>
    <id>http://yoursite.com/2018/11/21/63-Unique-Paths-II/</id>
    <published>2018-11-21T03:25:09.000Z</published>
    <updated>2018-11-21T03:26:45.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>Now consider if some obstacles are added to the grids. How many unique paths would there be?<br>An obstacle and empty space is marked as <code>1</code> and <code>0</code>respectively in the grid.</p><p><strong>Note:</strong> m and n will be at most 100.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">    [0,0,0],</span><br><span class="line">    [0,1,0],</span><br><span class="line">    [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>题目的意思比较简单，给出一个网格图，以其左上角为起点，右下角为终点，求其左下角到右下角路径的数目。</li><li>题目显然是一道<strong>动态规划</strong>的题目，我们需要做的是理清其中的转移方程，首先题目还有一定的限制，某些格子是不能正常通过的（障碍物），并且只能向下或者向右移动，因此我们可以推出起点位置到当前格子的路径数目为：<code>path[i][j] = path[i-1][j] + path[i][j-1]</code>，对于第一排(<code>i = 0</code>)以及第一列(<code>j=0</code>)则需要额外计算，<strong>到达路径数目最多为1</strong>，其与前一个格子到达路径数目以及当前格子是否为障碍物有关。</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *path[i][j] = path[i-1][j] + path[i][j-1]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> path[obstacleGrid.size()][obstacleGrid[<span class="number">0</span>].size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(!obstacleGrid[i][<span class="number">0</span>])</span><br><span class="line">                path[i][<span class="number">0</span>] = i &gt;= <span class="number">1</span> ? path[i<span class="number">-1</span>][<span class="number">0</span>] : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; obstacleGrid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            <span class="keyword">if</span>(!obstacleGrid[<span class="number">0</span>][j])</span><br><span class="line">                path[<span class="number">0</span>][j] = j &gt;= <span class="number">1</span> ? path[<span class="number">0</span>][j<span class="number">-1</span>] : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; obstacleGrid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">                <span class="keyword">if</span>(!obstacleGrid[i][j])</span><br><span class="line">                    path[i][j] = path[i<span class="number">-1</span>][j] + path[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    path[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path[obstacleGrid.size() - <span class="number">1</span>][obstacleGrid[<span class="number">0</span>].size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Sta
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>32. Longest Valid Parentheses</title>
    <link href="http://yoursite.com/2018/11/18/32-Longest-Valid-Parentheses/"/>
    <id>http://yoursite.com/2018/11/18/32-Longest-Valid-Parentheses/</id>
    <published>2018-11-18T05:52:43.000Z</published>
    <updated>2018-11-18T05:54:53.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>题目的意思比较简单，给出一个只由左括号和右括号组成的字符串，求出有效的括号匹配最长长度    </li></ul><h4 id="方法-1-利用stack"><a href="#方法-1-利用stack" class="headerlink" title="方法 1 - 利用stack"></a>方法 1 - <code>利用stack</code></h4><ul><li>利用数据结构<code>stack</code>完成，整个过程中<code>stack</code>的第一个元素为当前已遍历的不匹配括号串的最后一个<code>&#39;)&#39;</code>的下标或者<code>-1</code>，其余在<code>stack</code>中存储的是字符<code>&#39;(&#39;</code>的下标，参见阐述的步骤即可指定。使用<code>stack</code>的<code>FILO</code>    的特性完成判断字符是否括号是否匹配以及计算有效匹配括号的长度</li><li>步骤<ul><li>首先将<code>-1</code>推进<code>stack</code>中</li><li>遍历字符串，对于字符进行不同的处理<ul><li><code>&#39;(&#39;</code>， 直接将其下标推入栈中-<code>stack.push(i)</code></li><li><code>&#39;)&#39;</code>，首先弹出栈顶元素-<code>stack.pop()</code>。接下来的步骤需要划分两种情况进行：</li></ul><ol><li>如果当前栈中已经为空，即证明当前匹配的串已经无效，因为<code>&#39;)&#39;</code>数目大于<code>&#39;(&#39;</code>的数目，无法有效匹配括号，此时不做关于最长匹配的记录，<strong>只把当前下标推入栈中</strong>（当前<code>&#39;)&#39;</code>的下标即为已遍历的不匹配括号串的最后一个<code>&#39;)&#39;</code>的下标）</li><li>如果当前栈不为空，则证明目前匹配的串依旧有效，则更新一下最长匹配长度 - <code>num = max(num, i - myStack.top())</code></li></ol></li></ul></li><li>实现代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; myStack;</span><br><span class="line">        myStack.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                myStack.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                myStack.pop();</span><br><span class="line">                <span class="keyword">if</span>(myStack.empty()) </span><br><span class="line">                    myStack.push(i);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    num = max(num, i - myStack.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法-2-动态规划"><a href="#方法-2-动态规划" class="headerlink" title="方法 2 - 动态规划"></a>方法 2 - <code>动态规划</code></h4><ul><li>思路<ul><li>括号匹配的时候，遇到<code>&#39;)&#39;</code>才可能成功匹配上。因此，使用一个数组<code>num</code>记录每个<code>)</code>最长有效匹配的长度。</li><li>当前检索到<code>&#39;)&#39;</code>有两种情况<ul><li>情况1:  <code>&quot;...()...&quot;</code><ul><li>这种至少匹配的长度是2，但是可能连着之前也是有可能满足的，例如<code>&quot;...()()...&quot;</code>这种情况，因此需要考虑连着已匹配的-<code>(i &gt;= 2 ? num[i-2] : 0)</code>    </li><li>转移方程： <code>num[i] = (i &gt;= 2 ? num[i-2] : 0) + 2;</code>    </li></ul></li><li>情况2:  <code>&quot;...))...&quot;</code>        <ul><li>这种情况的匹配与前一个<code>&#39;)&#39;</code>相关，如果前面是有效匹配的，则需要检查<code>s[i-num[i-1]-1] == &#39;(&#39;</code>(条件：<code>i &gt;= num[i-1] + 1</code>)，即需要考虑<code>&quot;...((...))...&quot;</code>的情况。同时，还需要考虑前面是否可以与有效匹配的串连接起来，例如<code>&quot;...()((...))...&quot;</code>，因此还需要考虑连着已匹配的-<code>i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0</code></li><li>转移方程：<code>num[i] = num[i-1] + 2 + (i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0)</code></li></ul></li></ul></li></ul></li><li><p>实现代码</p><pre><code class="lang-cpp">  // dp  class Solution {  public:      int longestValidParentheses(string s) {          if(!s.size())    return 0;          int maxNum = 0;          int num[s.size()] = {0};          for(int i = 1; i &lt; s.size(); ++i){              if(s[i] == &#39;)&#39; &amp;&amp; s[i-1] == &#39;(&#39;) {                  // &quot;...()...&quot;                      num[i] = (i &gt;= 2 ? num[i-2] : 0) + 2;              }              else if(s[i] == &#39;)&#39; &amp;&amp; s[i-1] == &#39;)&#39; &amp;&amp; i &gt;= num[i-1] + 1 &amp;&amp; s[i-num[i-1]-1] == &#39;(&#39;) {                  // &quot;...((...))...&quot;                   num[i] = num[i-1] + 2 + (i &gt;= num[i-1] + 2 ? num[i - num[i-1] - 2] : 0);              }              maxNum = max(maxNum, num[i]);          }          return maxNum;      }  };</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a string containing just the characters &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
