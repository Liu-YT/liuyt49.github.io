<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Blog</title>
  <icon>https://www.gravatar.com/avatar/1e664c942599f0404df35da54598ea93</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-13T10:18:22.411Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>liuyt49</name>
    <email>1039868176@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux| 网络IO模型</title>
    <link href="http://yoursite.com/2019/06/12/Linux-%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/06/12/Linux-网络IO模型/</id>
    <published>2019-06-12T09:42:44.000Z</published>
    <updated>2019-06-13T10:18:22.411Z</updated>
    
    <content type="html"><![CDATA[<p><code>IO(Input/Output, 输入/输出)</code>是计算机体系的重要的一部分。<code>IO</code>有两种操作，<code>同步IO</code>或<code>异步IO</code>。<code>同步IO</code>指的是，必须等待<code>IO</code>操作完成，控制权才返回给用户进程。<code>异步IO</code>指的是，无需等待<code>IO</code>操作完成，就将控制权返回给用户进程。<br>网络中的<code>IO</code>，由于不同的<code>IO</code>设备有着不同的特点，网络通信中往往需要等待。常见的有以下4种情况</p><ul><li>输入操作：等待数据到达套接字接收缓冲区</li><li>输出操作：等待套接字发送缓冲区有足够的空间容纳将要发送的数据</li><li>服务器接收连接请求：等待新的客户端连接请求的到来</li><li>客户端发送连接请求：等待服务器回送客户的发起的<code>SYN</code>对应的<code>ACK</code></li></ul><p>4种网络<code>IO模型</code></p><ul><li><code>阻塞IO模型</code></li><li><code>非阻塞IO模型</code></li><li><code>多路IO复用模型</code></li><li><code>异步IO模型</code></li></ul><h1 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h1><p>在 Linux 中，默认情况下所有的 socket 都是阻塞的，一个典型的<strong>读操作流程</strong>如下所示</p><p><img src="/2019/06/12/Linux-网络IO模型/阻塞IO模型.png" alt="阻塞IO模型"></p><p>当应用进程调用了 recvfrom 这个系统调用后，系统内核就开始了 IO 的第一个阶段：准备数据。对于网络 IO 来说，很多时候数据在一开始还没到达时（比如还没有收到一个完整的 TCP 包），系统内核就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当系统内核一直等到数据准备好了，它就会将数据从系统内核中拷贝到用户内存中，然后系统内核返回结果，用户进程才解除阻塞的状态，重新运行起来。所以，阻塞 IO 模型的特点就是在 IO 执行的两个阶段（等待数据和拷贝数据）都被阻塞了。</p><p><strong>阻塞和非阻塞的概念描述的是用户线程调用内核 IO 操作的方式：阻塞是指 IO 操作需要彻底完成后才返回到用户空间；而非阻塞是指 IO 操作被调用后立即返回给用户一个状态值，不需要等到IO操作彻底完成。</strong></p><p>大部分的 socket 接口都是阻塞的。所谓阻塞型接口是指系统调用时（一般是 IO 接口）却不返回调用结果，并让当前线程一直处于阻塞状态，只有当该系统调用获得结果或者超时出错时才返回结果。除非特别指定，几乎所有的 IO 接口（包括 socket 接口）都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用 <code>send()</code>的同时，线程处于阻塞状态，则在此期间，线程将无法执行任何运算或响应任何网络请求。一个简单的改进方案是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞不会影响其他的连接。<br>多线程的服务器模型似乎完美地解决了多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重的占据系统资源，降低系统对外界响应的效率，而线程与进程本身也更容易进入假死状态。此时考虑使用<strong>线程池</strong>或者<strong>连接池</strong></p><ul><li><strong>线程池</strong>旨在降低创建和销毁线程的频率，使其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务</li><li><strong>连接池</strong>是指维持连接的缓存池，尽量重中已有的连接，减低创建和关闭连接的频率。</li></ul><p><strong>线程池</strong>和<strong>连接池</strong>或许可以缓解部分压力，但是不能解决所有问题，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞模型来尝试解决这个问题</p><hr><h1 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h1><p>在 Linux 中，可以通过设置 socket 使IO变为非阻塞状态。当对一个非阻塞的 socket 执行读 read 操作时，其流程如下</p><p><img src="/2019/06/12/Linux-网络IO模型/非阻塞IO模型.png" alt="非阻塞IO模型"></p><p>当用户进程发出 <code>read</code> 操作时，如果内核中的数据还没有准备好，那么它并不会 <code>block</code> 用户进程，而是立刻返回一个错误。从用户进程角度讲，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。当用户进程判断结果是一个错误时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的系统调用，那么它马上就将数据复制到了用户内存中，然后返回正确的返回值。所以，在<code>非阻塞式 IO</code> 中，用户进程其实需要不断地主动询问 <code>kernel</code> 数据是否准备好。<strong>非阻塞的接口相比于阻塞型接口的显著差异在于被调用之后立即返回</strong>。使用如下的函数可以将某句柄归设为非阻塞状态<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl (fd, F_SETFL, O_NONBLOCK);</span><br></pre></td></tr></table></figure></p><p>在非阻塞状态下， <code>recv()</code>接口在被调用后立即返回，返回值代表了不同的含义，如下所述</p><ul><li><code>recv()</code>返回值大于0，表示接收数据完毕，返回值即是接收到的字节数</li><li><code>recv()</code>返回 0，表示连接已经正常断开</li><li><code>recv()</code>返回－1 ，且 <code>errno</code> 等于 <code>EAGAIN</code>，表示 <code>recv</code> 操作还没执行完成</li><li><code>recv()</code>返回－1 ，且 <code>errno</code> 不等于 <code>EAGAIN</code>，表示 <code>recv</code> 操作遇到系统错误<code>errno</code></li></ul><p>可以看到服务器线程可以通过循环调用<code>recv()</code>接口，可以在单个线程内实现对所有连接的数据接收工作。但是上述模型绝不被推荐，因为循环调用<code>recv()</code>将大幅度占用CPU使用率；此外，在这个方案中<code>recv()</code>更多的是起到检测”操作是否完成”的作用，实际操作系统提供了更为高效的检测”操作是否完成”作用的接口，例如 <code>select()</code>多路复用模式，可以一次检测多个连接是存活跃</p><hr><h1 id="多路IO复用模型"><a href="#多路IO复用模型" class="headerlink" title="多路IO复用模型"></a>多路IO复用模型</h1><p>多路 IO 复用，有时也称为事件驱动 IO。<strong>它的基本原理就是有个函数（例如 <code>select</code>）会不断地轮询所负责的所有 <code>socket</code>，当某个 <code>socket</code> 有数据到达了，就通知用户进程</strong>， 多路 IO 复用模型的流程如下所示</p><p><img src="/2019/06/12/Linux-网络IO模型/多路IO复用模型.png" alt="多路IO复用模型"></p><p>当用户进程调用了 select ，那么整个进程会被阻塞，而同时，内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回。这个时候用户进程再调用 read 操作，将数据从内核拷贝到用户进程。<br><strong>这个模型和<code>阻塞IO</code> 的模型其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用（<code>select</code> 和 <code>recvfrom</code>），而阻塞 IO 只调用了一个系统调用(<code>recvfrom</code>)。但是，用<code>select</code>的优势在于它可以同时处理多个连接。所以，如果处理的连接数不是很高的话，使用<code>select/epoll</code>的 Web server 不一定比使用多线程的<code>阻塞IO</code>的 Web server 性能更好，可能延迟还更大；<code>select/epoll</code>的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong><br>在<code>多路复用IO模型</code>中，对于每一个<code>socket</code>，一般都设置成为非阻塞的，但是，如上图所示，整个用户的进程其实是一直被阻塞的。只不过进程是被 select 这个函数阻塞，而不是被 socket IO 阻塞。 因此使用 <code>select()</code>的效果与<code>非阻塞IO</code>类似</p><blockquote><p>select、epoll相关将会在后续学习中进行补充</p></blockquote><hr><h1 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h1><p>异步IO模型的流程</p><p><img src="/2019/06/12/Linux-网络IO模型/异步IO模型.png" alt="异步IO模型"></p><p>用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其他的事；而另一方面，从内核的角度，当它收到一个异步的 <code>read</code> 请求操作之后，首先会立刻返回，所以不会对用户进程产生任何阻塞。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存中，当这一切都完成之后，内核会给用户进程发送一个信号，返回<code>read</code>操作已完成的信息。</p><p><strong>调用阻塞 IO 会一直阻塞住对应的进程直到操作完成，而非阻塞 IO 在内核还在准备数据的情况下会立刻返回。两者的区别就在于同步 IO 进行 IO 操作时会阻塞进程。按照这个定义，之前所述的阻塞 IO、非阻塞 IO 及多路 IO 复用都属于同步 IO。</strong> 实际上，真实的 IO 操作，就是例子中的 <code>recvfrom</code> 这个系统调用。 非阻塞 IO 在执行 <code>recvfrom</code> 这个系统调用的时候，如果内核的数据没有准备好，这时候不会阻塞进程。但是当内核中数据准备好时，<code>recvfrom</code> 会将数据从内核拷贝到用户内存中，这个时候进程则被阻塞。而异步 IO 则不一样，当进程发起 IO 操作之后，就直接返回，直到内核发送一个信号，告诉进程 IO 已完成，则在这整个过程中，进程完全没有被阻塞。 </p><hr><h1 id="模型比较"><a href="#模型比较" class="headerlink" title="模型比较"></a>模型比较</h1><p>各个 IO 模型的比较</p><p><img src="/2019/06/12/Linux-网络IO模型/各种IO模型比较.png" alt="各种IO模型比较"></p><p><strong><code>非阻塞 IO</code> 和<code>异步 IO</code> 的区别还是很明显的。 在<code>非阻塞 IO</code> 中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动检查，并且当数据准备完成以后，也需要进程主动地再次调用 <code>recvfrom</code> 来将数据拷贝到用户内存中。 而<code>异步 IO</code>则完全不同，它就像是用户进程将整个 IO 操作交给了他人（内核）完成，然后内核做完后发信号通知。在此期间，用户进程不需要去检查 IO 操作的状态，也不需要主动地拷贝数据。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;IO(Input/Output, 输入/输出)&lt;/code&gt;是计算机体系的重要的一部分。&lt;code&gt;IO&lt;/code&gt;有两种操作，&lt;code&gt;同步IO&lt;/code&gt;或&lt;code&gt;异步IO&lt;/code&gt;。&lt;code&gt;同步IO&lt;/code&gt;指的是，必须等待&lt;code
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>谈谈cookie-session和JWT认证机制</title>
    <link href="http://yoursite.com/2019/06/10/%E8%B0%88%E8%B0%88cookie-session%E5%92%8CJWT%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/06/10/谈谈cookie-session和JWT认证机制/</id>
    <published>2019-06-10T11:57:42.000Z</published>
    <updated>2019-06-10T13:27:32.182Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结了网上相关的博客以及一些个人的理解，欢迎指出错误</p></blockquote><h1 id="为什么需要这些认证机制"><a href="#为什么需要这些认证机制" class="headerlink" title="为什么需要这些认证机制"></a>为什么需要这些认证机制</h1><p>众所周知，http协议是一个无状态的协议，每个请求之间是独立的，没有关系的。但是在日常的实际应用中并不能满足我们的需求，我们需要区分请求的用户，需要保存一些访问的状态，因此需要引入会话管理机制，帮助我们区分用户</p><h1 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie-session"></a>cookie-session</h1><h2 id="cookie是什么"><a href="#cookie是什么" class="headerlink" title="cookie是什么"></a>cookie是什么</h2><p><code>cookie</code>，简而言之就是在客户端（浏览器等）保存一些用户操作的历史信息（包括登录信息），并在用户再次访问该站点时浏览器通过<code>HTTP</code>协议将本地<code>cookie</code>内容发送给服务器，从而完成验证，或继续上一步操作</p><h2 id="session是什么"><a href="#session是什么" class="headerlink" title="session是什么"></a>session是什么</h2><p><code>session</code>，简而言之就是在服务器上保存用户操作的历史信息，在用户登录后，服务器存储用户会话的相关信息，并为客户端指定一个访问凭证，如果有客户端凭此凭证发出请求，则在服务端存储的信息中，取出用户相关登录信息，并且使用服务端返回的凭证常存储于<code>cookie</code>中,也可以改写URL，将id放在url中。这个访问凭证一般来说就是<code>session_id</code>。</p><h2 id="机制原理"><a href="#机制原理" class="headerlink" title="机制原理"></a>机制原理</h2><p><code>session</code>是存放在服务端的，而<code>cookie</code>是存储在客户端的用户登录成功的时候，生成<code>session_id</code>,以<code>session_id</code>为<code>key</code>，用户信息经过一系列的加密处理生成<code>value</code>,写入<code>session</code>,<code>session</code>信息可以写入文件、数据库或<a href="https://memcached.org/" target="_blank" rel="noopener">memcached</a>等等。推荐写入<code>memcached</code>，提高访问的速度。然后把<code>session_id</code>写入<code>cookie</code>存放在客户端，每次请求的时候，都会携带<code>cookie</code>，需要用户信息的时候，根据<code>cookie</code>里面的<code>session_id</code>直接从文件或者数据库或者<code>memcached</code>里面取出<code>session</code>信息即可</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><ul><li><code>seesion</code>：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。</li><li><code>可扩展性</code>：在服务端的内存中使用<code>seesion</code>存储登录信息，伴随而来的是可扩展性问题。</li><li><code>CORS(跨域资源共享)</code>：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用<code>Ajax</code>抓取另一个域的资源，就可以会出现禁止请求的情况。</li><li><code>CSRF(跨站请求伪造)</code>：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。</li></ul><h1 id="JWT-JSON-WEB-TOKEN"><a href="#JWT-JSON-WEB-TOKEN" class="headerlink" title="JWT(JSON WEB TOKEN)"></a>JWT(JSON WEB TOKEN)</h1><h2 id="JWT是什么"><a href="#JWT是什么" class="headerlink" title="JWT是什么"></a>JWT是什么</h2><p><code>JSON Web Token（JWT）</code>是一个开放标准(<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">RFC 7519</a>)，它定义了一种紧凑且独立的方式，用于在各方之间作为JSON对象安全地传输信息。此信息可以通过数字签名进行验证和信任。<code>JWT</code>可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名。</p><h2 id="JWT-结构"><a href="#JWT-结构" class="headerlink" title="JWT 结构"></a>JWT 结构</h2><blockquote><p><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">What is the JSON Web Token structure?</a></p></blockquote><p><code>json web token</code>从名字就可以看出来，是<code>json</code>格式的。具体而言，其分为<code>header</code>, <code>payload</code>, <code>signature</code>三部分，因此它的格式为：<code>xxxxx.yyyyy.zzzzz</code></p><ul><li><p><strong>header</strong><br>  <code>header</code>通常由两部分组成：令牌的类型，即<code>JWT</code>，以及正在使用的签名算法，例如HMAC、SHA256或RSA。<br>  例如：</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">    <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>payload</strong><br>  <code>payload</code>信息，主要是<code>claims</code>，用户的信息，发布者的信息等等。这样我们在需要的时候需要的时候在<code>payload</code>里面保存一些信息，这样可以不用查询数据库就可以获取<br>  例如：</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">    <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>signature</strong><br>  要创建签名部分，对<code>header</code>, <code>payload</code>编码，外加一个<code>secret</code>，做一个散列算法</p><p>  例如，如果要使用<code>HMAC SHA256</code>算法，将按以下方式创建签名：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">    base64UrlEncode(header) + "." +</span><br><span class="line">    base64UrlEncode(payload),</span><br><span class="line">    secret)</span><br></pre></td></tr></table></figure><p>  签名用于验证消息在此过程中未被更改，并且，在使用私钥签名的令牌的情况下，它还可以验证<code>JWT</code>的发件人是否是它所声称的人</p></li></ul><h2 id="机制原理-1"><a href="#机制原理-1" class="headerlink" title="机制原理"></a>机制原理</h2><p>首先用户发出登录请求，服务端根据用户的登录请求进行匹配，如果匹配成功，将相关的信息放入<code>payload</code>中，利用上述算法，加上服务端的密钥生成<code>token</code>，这里需要注意的是<code>secret_key</code>很重要，如果这个泄露的话，客户端就可以随意篡改发送的额外信息，它是信息完整性的保证。生成<code>token</code>后服务端将其返回给客户端，客户端可以在下次请求时，将<code>token</code>一起交给服务端，一般来说我们可以将其放在<code>Authorization</code>首部中，这样也就可以避免跨域问题。接下来，服务端根据<code>token</code>进行信息解析，再根据用户信息作出相应的操作</p><h2 id="优势与不足"><a href="#优势与不足" class="headerlink" title="优势与不足"></a>优势与不足</h2><ul><li>优点<ul><li>不需要储存在服务器的<code>session</code>中，更容易扩展服务器</li><li>由于用户信息可以放入<code>token</code>中，所以可以少了一次数据库 / 缓存的查询操作，有更好的性能</li><li>不需要预防<a href="https://segmentfault.com/a/1190000003716037?utm_source=tag-newest" target="_blank" rel="noopener">CSRF</a>的攻击</li><li>解决多平台跨域问题</li></ul></li><li>不足<ul><li><code>token</code>一经泄露或者被盗取，将会暴露该用户</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.imooc.com/article/details/id/47255" target="_blank" rel="noopener">浅谈session,cookie和jwt(Json Web Token)认证方式</a></li><li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">What is JSON Web Token?</a></li><li><a href="https://zhuanlan.zhihu.com/p/63061864" target="_blank" rel="noopener">彻底理解cookie，session，token</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;总结了网上相关的博客以及一些个人的理解，欢迎指出错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;为什么需要这些认证机制&quot;&gt;&lt;a href=&quot;#为什么需要这些认证机制&quot; class=&quot;headerlink&quot; title=&quot;为什么需要这些认证
      
    
    </summary>
    
      <category term="笔记总结" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="笔记总结" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux| Socket网络编程</title>
    <link href="http://yoursite.com/2019/06/10/Linux-Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/06/10/Linux-Socket网络编程/</id>
    <published>2019-06-10T07:44:08.000Z</published>
    <updated>2019-06-10T11:15:01.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于TCP网络编程API</p></blockquote><h1 id="什么是-socket？"><a href="#什么是-socket？" class="headerlink" title="什么是 socket？"></a>什么是 socket？</h1><p><code>socket</code>起源于UNIX，而 UNIX/Linux 基本哲学之一就是”一切皆文件”，都可以用<code>打开(open) -&gt; 读写(write/read) -&gt; 关闭(close)</code>模式来操作。<code>socket</code>其实就是该模式的一个实现，<code>socket</code>即是一种特殊的文件，一些<code>socket</code>函数就是对其进行的操作(读／写、 打开、关闭)。</p><h1 id="socket-的基本操作"><a href="#socket-的基本操作" class="headerlink" title="socket 的基本操作"></a>socket 的基本操作</h1><p><code>socket</code>是<code>open-write/read-close</code>模式的一种实现，那么<code>socket</code>就提供了这些操作对应的函数接口，本文将以<code>TCP</code>协议通信<code>socket</code>为例，讲解相关的函数接口</p><p><strong>TCP三次握手</strong><br><img src="/2019/06/10/Linux-Socket网络编程/TCP三次握手.png" alt="TCP三次握手"></p><p><strong>TCP交互流程</strong><br><img src="/2019/06/10/Linux-Socket网络编程/TCP交互流程.png" alt="TCP交互流程"></p><h2 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h2><p><code>socket</code>函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述符，而<code>socket()</code>用于创建一个<code>socket</code>描述符(<code>socket description</code>)，它唯一标识一个<code>socket</code>。这个<code>socket</code>描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它进行一些读写操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></p><p><code>参数简述</code></p><ul><li><code>domain</code>：协议域，又称为协议族(<code>family</code>)。常用的协议族有：<code>AF_INEF</code>、<code>AF_INET6</code>、<code>AF_LOCAL</code>等。协议族决定了<code>socket</code>的地址类型，在通信种必须采用对应的地址，如<code>AF_INEF</code>决定了要用ipv4地址（322）位与端口号（16位）</li><li><code>type</code>：指定socket类型。常用的socket类型有：<code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>等等。其中， <code>SOCK_STREAM</code>表示提供面向连接的稳定数据传输，即 TCP 协议。<code>SOCK_DGRAM</code>表示使用不连续、不可靠的数据包连接</li><li><code>protocol</code>：指定协议。常用的协议有：<code>IPPROTO_TCP</code>, <code>IPPTOTO_UDP</code>, <code>IPPROTO _ SCTP</code>、 <code>IPPROTO_TIPC</code> 等，它们分别对应 TCP 传输协议、 UDP 传输协议、 STCP 传输协议、 TIPC 传输协议</li></ul><h2 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h2><p><code>bind()</code> 函数把一个地址族中的特定地址赋给 <code>socket</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><code>参数简述</code></p><ul><li><code>sockfd</code>：即<code>socket</code>描述字，它是通过<code>socket()</code>函数创建来唯一标识一个socket的。<code>bind()</code>函数就是将给这个描述字绑定一个名字</li><li><code>addr</code>：一个 <code>const struct sockaddr＊</code>指针，指向要绑定给 <code>sockfd</code>的协议地址。 这个地 结构根据地址创建 <code>socket</code>时的地址协议族的不同而不同</li><li><code>addrlen</code>：对应的是地址的长度</li></ul><h2 id="listen-和-connect-函数"><a href="#listen-和-connect-函数" class="headerlink" title="listen 和 connect 函数"></a>listen 和 connect 函数</h2><p>如果作为一个服务器，在调用<code>socket()</code>、<code>bind()</code>之后就会调用<code>listen()</code>来监听这个<code>socket</code>，如果客户端这时调用<code>connect()</code>发出连接请求，服务器端就会接收到这个请求。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure></p><p><code>listen</code>函数的第一个参数即为要监听的<code>socket</code>描述字，第二个参数为相应<code>socket</code>可以排队的最大连接个数。<code>socket()</code>函数创建的 <code>socket</code> 默认是一个主动类型的， <code>listen</code> 函数将 <code>socket</code> 变为被动类型的，等待客户的连接请求。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><code>connect</code>函数的第一个参数即为客户端的<code>socket</code>描述字，第二参数为服务器的<code>socket</code>地址，第三个参数为<code>socket</code>地址的长度。客户端通过调用<code>connect</code>函数来建立与TCP服务器的连接</p><h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h2><p>TCP 服务器端依次调用 <code>socket()</code>、<code>bind()</code>、<code>listen()</code>之后，就会监听指定的<code>socket</code> 地址了。TCP 客户端依次调用 <code>socket()</code>、<code>connect()</code>之后就会向 TCP 服务器发送了一个连接请求。 TCP 服务器监听到这个请求之后，就会调用<code>accept()</code>取接收请求，这样连接就建立好了。 之后就可以开始网络 I/O 操作了，即类同于普通文件的读写 I/O 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><code>accept</code>函数的第一个参数为服务器的 <code>socket</code> 描述字；第二个参数为指向 <code>struct sockaddr*</code> 的指针，用于返回客户端的协议地址；第三个参数为协议地址的长度。如果 <code>accpet</code>成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的 TCP 连接</p><p><strong>注意</strong>：<code>accept</code>的第一个参数为服务器的 <code>socket</code> 描述字，是服务器开始调用 <code>socket()</code>函数生成的，称为监听<code>socket</code>描述字；而 <code>accept</code>函数返回的是己连接的 <code>socket</code>描述字。 一个服务器通常仅仅只创建一个监听 <code>socket</code> 描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户创建了一个已连接 <code>socket</code> 描述字，当服务器完成了对某个客户的服务，相应的已连接 <code>socket</code>描述字就被关闭</p><h2 id="read-和-write-函数"><a href="#read-和-write-函数" class="headerlink" title="read 和 write 函数"></a>read 和 write 函数</h2><p>至此服务器与客户已经建立好连接了，可以调用网络 I/O 进行读写操作了，即实现了网络中不同进程之间的通信。网络 I/O 操作有下面几组</p><ul><li><code>read() / write()</code></li><li><code>recv() / send()</code> </li><li><code>readv() / writev()</code> </li><li><code>recvmsg() / sendmsg()</code> </li><li><code>recvfrom() / sendto()</code> </li></ul><p>比较常用的是<code>read</code>和<code>write</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p><p><code>read()</code>函数是负责从fd中读取内容。当读取成功时，<code>read()</code>返回实际所读的字节数，如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。如果错误为 <code>EINTR</code> 说明读是由中断引起的，如果是 <code>ECONNREST</code> 表示网络连接出了问题。</p><ul><li><code>socket</code> 描述字 <code>fd</code></li><li>缓冲区 <code>buf</code></li><li>缓冲区长度 <code>count</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p><code>write()</code>函数将buf中的 nbytes 字节内容写入文件描述符fd成功时返回写的字节数。失败时返回-1，并设置 <code>errno</code> 变量。在网络程序中，当我们向套接字文件描述符写时有两种可能: 1.<code>write</code> 的返回值大于0，表示写了部分或者是全部的数据; 2.返回的值小于 0，此时出现了错误。实际中要根据错误类型来处理。如果错误为 <code>EINTR</code> 表示在写的时候出现了中断错误。如果为 <code>EPIPE</code> 表示网络连接出现了问题（对方已经关闭了连接）</p><ul><li>fd 表示 socket 描述字</li><li>buf表示缓冲区</li><li>count 表示缓冲区长度</li></ul><h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的 <code>socket</code>描述字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p><code>close</code>一个 <code>TCP socket</code> 的默认行为时，会把该 <code>socket</code> 标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为 <code>read</code> 或 <code>write</code> 的第一个参数</p><h1 id="实现简单的TCP-Server"><a href="#实现简单的TCP-Server" class="headerlink" title="实现简单的TCP-Server"></a>实现简单的TCP-Server</h1><p>该实现主要是了解一些相关API的调用，起主要参考的<strong>TCP交互流程</strong>即可 - <a href="https://github.com/Liu-YT/TCP-Server" target="_blank" rel="noopener">项目 - TCP-Server</a><br><img src="/2019/06/10/Linux-Socket网络编程/TCP交互流程.png" alt="TCP交互流程"></p><h1 id="网络字节序与主机序"><a href="#网络字节序与主机序" class="headerlink" title="网络字节序与主机序"></a>网络字节序与主机序</h1><ul><li><code>主机序</code> - 不同的<code>CPU</code>有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，称为主机序。最常见的就是大端和小端<ul><li><code>Little Endian</code> - 小端: 把地址低位存储值的低位，地址高位存储值的高位</li><li><code>Big Endian</code> - 大端: 把地址低位存储值的高位，地址高位存储值的低位</li></ul></li><li><code>网络字节序</code> - 4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于<code>TCP/IP</code>首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序</li><li><strong>网络协议也都是采用 <code>Big Endian</code> 的方式来传输数据的。 所以有时也会把 <code>Big Endian</code> 方式称之为网络字节序。 当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成网络字节序后再进行传输</strong></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/26850616/" target="_blank" rel="noopener">后台开发：核心技术与应用实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于TCP网络编程API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是-socket？&quot;&gt;&lt;a href=&quot;#什么是-socket？&quot; class=&quot;headerlink&quot; title=&quot;什么是 socket？&quot;&gt;&lt;/a&gt;什么是 so
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 作业5</title>
    <link href="http://yoursite.com/2019/05/18/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A5/"/>
    <id>http://yoursite.com/2019/05/18/系统分析与设计-作业5/</id>
    <published>2019-05-18T07:25:54.000Z</published>
    <updated>2019-05-25T06:59:58.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-UMLet-建模："><a href="#使用-UMLet-建模：" class="headerlink" title="使用 UMLet 建模："></a>使用 UMLet 建模：</h1><h2 id="1、根据订旅馆建模文档，Asg-RH-pdf："><a href="#1、根据订旅馆建模文档，Asg-RH-pdf：" class="headerlink" title="1、根据订旅馆建模文档，Asg-RH.pdf："></a>1、根据订旅馆建模文档，<a href="https://sysu-swsad.github.io/swad-guide/material/Asg_RH.pdf" target="_blank" rel="noopener">Asg-RH.pdf</a>：</h2><ul><li><p>绘制用例图模型（到子用例）</p><p>  <img src="/2019/05/18/系统分析与设计-作业5/1.png" alt="1"></p></li><li><p>给出 <code>make reservation</code> 用例的活动图</p></li></ul><pre><code>![2](2.png)</code></pre><h2 id="2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"><a href="#2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景" class="headerlink" title="2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"></a>2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景</h2><ul><li><p>分别用多泳道图建模三个场景的业务过程</p><ul><li><p>x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。</p><p>  <img src="/2019/05/18/系统分析与设计-作业5/3.png" alt="3"></p></li><li><p>随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。</p><p>  <img src="/2019/05/18/系统分析与设计-作业5/4.png" alt="4"></p></li><li><p>x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。</p><p>  <img src="/2019/05/18/系统分析与设计-作业5/5.png" alt="5"></p></li></ul></li><li><p>根据上述流程，给出快递柜系统最终的用例图模型</p><ul><li>用正常色彩表示第一个业务流程反映的用例</li><li>用绿色背景表述第二个业务场景添加或修改的用例，以及支持 <code>Actor</code></li><li><p>用黄色背景表述第三个业务场景添加或修改的用例，以及支持 <code>Actor</code></p><p><img src="/2019/05/18/系统分析与设计-作业5/6.png" alt="6"></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-UMLet-建模：&quot;&gt;&lt;a href=&quot;#使用-UMLet-建模：&quot; class=&quot;headerlink&quot; title=&quot;使用 UMLet 建模：&quot;&gt;&lt;/a&gt;使用 UMLet 建模：&lt;/h1&gt;&lt;h2 id=&quot;1、根据订旅馆建模文档，Asg-RH-pdf：&quot;&gt;
      
    
    </summary>
    
      <category term="系统分析与设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统分析与设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 作业4</title>
    <link href="http://yoursite.com/2019/05/18/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A4/"/>
    <id>http://yoursite.com/2019/05/18/系统分析与设计-作业4/</id>
    <published>2019-05-18T07:23:16.000Z</published>
    <updated>2019-05-22T05:30:51.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><ul><li><p>用例的概念</p><blockquote><p>use case is a collection of related success and failure scenarios that describe an actor using a system to support a goal.</p></blockquote><p>  用例是相关成功和失败场景的集合，用来描述使用系统来达到一个目的的参与者。</p></li><li><p>用例和场景的关系？什么是主场景或<code>happy path</code>？</p><ul><li>用例(<code>use case</code>)和场景(<code>scenario</code>)的关系：用例表示一组场景(<code>a collection of scenarios</code>)，场景属于用例的实例。</li><li>主场景(<code>the primary scenario</code>)或<code>happy path</code>：主场景是最常用的一个业务场景，对应于主要的系统交互，通常是“成功”场景，表示系统所实现的基本业务。</li></ul></li><li><p>用例有哪些形式？</p><ul><li><code>Brief(high level)</code>: 一段简单的概要，通常是主要成功案例。主要在早期需求分析中，快速了解主题和范围，创作可能只需几分钟</li><li><code>Casual(简便格式)</code>: 非正式格式，涵盖各种场景的多个段落，主要在早期需求分析中使用</li><li><code>Fully</code>: 所有的步骤和变化都写得很详细，并有支持部分，如前提条件和成功保证。主要在确定了许多用例并以简短格式编写后，详细编写了一些具有架构意义和高价值的用例</li></ul></li></ul><ul><li><p>对于复杂业务，为什么编制完整用例非常难？<br>  复杂业务涉及到的场景比较多，业务流程复杂繁琐，不同场景之间存在关联，系统交互比较复杂，需要考虑的备选流众多，因此编制完整用例非常难</p></li><li><p>什么是用例图？<br>  用例图是指由参与者（<code>Actor</code>）、用例（<code>Use Case</code>），边界以及它们之间的关系构成的用于描述系统功能的视图。用例图是外部用户（被称为参与者）所能观察到的系统功能的模型图。用例图是系统的蓝图。用例图呈现了一些参与者，一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行建模。</p></li><li><p>用例图的基本符号与元素？</p><ul><li><p>参与者(<code>Actor</code>) - 表示的是一个系统用户，也就是与应用程序进行交互的用户、组织或者外部系统</p><p>  <img src="/2019/05/18/系统分析与设计-作业4/1.png" alt="1"></p></li><li><p>用例(<code>Use Case</code>) - 表示的是对系统提供的功能、服务的一种描述</p><p>  <img src="/2019/05/18/系统分析与设计-作业4/2.png" alt="2"></p></li><li><p>用例之间的关系</p><ul><li><p>包含关系(<code>Include</code>) - 表示用例可以简单地包含其他用例所具有的行为，并把它所包含的用例行为作为自身行为的一部分。在UML中常用带箭头的虚线表示，箭头指向被包含的用例</p><p><img src="/2019/05/18/系统分析与设计-作业4/3.png" alt="3"></p></li><li><p>泛化关系(<code>Generalization</code>) - 泛化指的是一个父用例可以被特化形成多个子用例，而父用例和子用例之间的关系就是泛化关系。在UML中用空心三角箭头的实线表示，箭头指向父用例</p><p><img src="/2019/05/18/系统分析与设计-作业4/4.png" alt="4"></p></li><li><p>关联关系(<code>Association</code>) - 表示的是参与者与用例之间的关系。在UML中常用一条直线，或者是一条带箭头的线条来表示，箭头指向信息接收方</p><p><img src="/2019/05/18/系统分析与设计-作业4/5.png" alt="5"></p></li><li><p>扩展/延伸关系(<code>Extend</code>) - 表示在一定条件下，把新的行为加入到已有的用例中，获得的新用例叫做扩展用例，原有的用例叫做基础用例，相当于为基础用例提供一个附加功能。在UML中用带箭头的虚线表示，箭头指向基础用例</p><p><img src="/2019/05/18/系统分析与设计-作业4/6.png" alt="6"></p></li></ul></li><li><p>子系统(<code>Subsystem</code>) — 用来展示系统的一部分功能，这部分功能联系紧密</p><p> <img src="/2019/05/18/系统分析与设计-作业4/7.png" alt="7"></p></li></ul></li><li><p>用例图的画法与步骤</p><ul><li>绘制系统边界</li><li>确定参与者信息，包括<ul><li>主要参与者（<code>primary actor</code>）：通过使用服务实现用户目标</li><li>协作参与者（<code>supporting actor</code>）：提供服务</li><li>幕后参与者（<code>offstage actor</code>）：对用例的行为感兴趣</li></ul></li><li>确定参与者之间的关系</li><li>根据需求识别和编制用例<ul><li>确认用例间关系，如 <code>include</code> 与 <code>extend</code></li><li>确认用例与参与者的关系</li><li>确定外部接口，在用例的事件流中发现其他系统支持，并将其标注出来放在系统框的右边</li></ul></li></ul></li><li><p>用例图给利益相关人与开发者的价值有哪些？</p><ul><li>对于利益相关人而言<ul><li>更直观地了解系统的功能与用户交互情况，以确保其需求得到满足</li><li>用例能够根据需要对复杂程度和形式化程度进行增减调节，通过修改或者增加图形间的关系，使得整个系统的实现过程变得更灵活。</li></ul></li><li>对于开发者而言<ul><li>明确系统的业务范围、服务对象（角色）、外部系统与设备</li><li>帮助识别技术风险，提前实施关键技术原型公关与学习</li><li>易于评估项目工作量，合理规划迭代周期，规划人力需要</li></ul></li></ul></li></ul><h1 id="建模练习题（用例模型）"><a href="#建模练习题（用例模型）" class="headerlink" title="建模练习题（用例模型）"></a>建模练习题（用例模型）</h1><ul><li><p>选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：</p><blockquote><ul><li>请使用用户的视角，描述用户目标或系统提供的服务</li><li>粒度达到子用例级别，并用 include 和 exclude 关联它们</li><li>请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例</li><li>尽可能识别外部系统和服务</li></ul></blockquote><ul><li><p>饿了么<br><img src="/2019/05/18/系统分析与设计-作业4/eleme.png" alt="eleme"></p></li><li><p>扇贝单词<br><img src="/2019/05/18/系统分析与设计-作业4/shanbei.png" alt="shanbei"></p></li></ul></li><li><p>然后，回答下列问题：</p><ol><li><p>为什么相似系统的用例图是相似的？</p><p>相似的系统的需求大致是相同的，主要的业务逻辑类似，其系统的用例图因此也是类似的</p></li><li><p>如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术</p><p>所选择的产品没有涉及到旅馆业务，但是个人认为对于旅馆的推荐上依据用户的历史预定以及一些检索记录来为客户进行更加个性化的推荐</p></li><li><p>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用</p><p>在用例图中对创新用例使用某种颜色进行高亮标记，这样可以快速定位到新的创新思路，同时可以依据创新用例在整个系统中的位置，判断其重要性。</p></li><li><p>请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表</p><p>|  ID  |   Name   | Imp  | Est  |                         How to demo                          |                             Note                             |<br>| :—: | :———: | :—: | :—: | :—————————————————————————————: | :—————————————————————————————: |<br>|  1   |   注册   |  20  |  3   | 输入手机号，收到注册的验证码，输入验证码以及一些个人信息后，注册成功 |           注册成功后跳转到主页，并且保持登陆的状态           |<br>|  2   |   登陆   |  10  |  2   |          手机验证码登陆、微信登陆等一些三方登陆测试          |                                                              |<br>|  3   | 搜索酒店 |  50  |  10  |          根据输入信息能够匹配到正确的合适的酒店结果          |             可以根据价格、好评等方面进行排序展示             |<br>|  4   | 预定酒店 | 100  |  15  |          用户选择好酒店的房间以及居住天数后进行预定          | 需要考虑相应酒店在指定日期内是否有相应的空闲房间，并且预定时候会锁定房间，此时别的用户不能再预定该房间 |<br>|  5   | 支付订单 |  60  |  8   |           对预定的酒店进行支付，确保支付的金额正确           |           支持多种支付方式，如支付宝支付、微信支付           |<br>|  6   | 查询订单 |  40  |  5   |                      查询自己的订单情况                      |                包含已完成的订单和未完成的订单                |</p></li></ol></li></ul><pre><code>5. 根据任务4，参考[使用用例点估算软件成本](https://www.ibm.com/developerworks/cn/rational/edge/09/mar09/collaris_dekker/index.html)，给出项目用例点的估算   |   用例   | 事务 | 计算 | UC权重 |   | :------: | :--: | :--: | :----: |   |   注册   |  1   |  1   |  简单  |   |   登陆   |  3   |  1   |  简单  |   | 搜索酒店 |  8   |  4   |  复杂  |   | 预定酒店 |  5   |  3   |  平均  |   | 支付订单 |  4   |  2   |  平均  |   | 查询订单 |  3   |  2   |  平均  |</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用例的概念&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;use case is a collection of rel
      
    
    </summary>
    
      <category term="系统分析与设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统分析与设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Go-kit微服务| JWT身份认证</title>
    <link href="http://yoursite.com/2019/05/12/Go-kit%E5%BE%AE%E6%9C%8D%E5%8A%A1-JWT%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    <id>http://yoursite.com/2019/05/12/Go-kit微服务-JWT身份认证/</id>
    <published>2019-05-12T08:27:18.000Z</published>
    <updated>2019-06-10T11:31:34.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://hacpai.com/article/1540349739379" target="_blank" rel="noopener">golang JWT 包生成 Token, 验证 Token</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h1&gt;&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Go-Kit" scheme="http://yoursite.com/tags/Go-Kit/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云| Nginx安装与配置HTTPS</title>
    <link href="http://yoursite.com/2019/05/11/%E8%85%BE%E8%AE%AF%E4%BA%91-Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>http://yoursite.com/2019/05/11/腾讯云-Nginx安装与配置HTTPS/</id>
    <published>2019-05-11T09:03:39.000Z</published>
    <updated>2019-05-23T05:37:15.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在写项目的时候，在将后台服务器部署到腾讯云后，因为前端是小程序，微信小程序开发对于正常使用必须基于<code>HTTPS</code>请求，因此需要配置<code>HTTPS</code>。<br>本来是使用比较简单<code>openssl</code>进行配置使用，使用第三方免费的<code>SSL证书</code>，但是由于自己配置的证书不稳定，不能被校验通过，服务功能不能正常使用。因此选择申请腾讯云服务器的<code>SSL证书</code>使用，后台的服务器框架为<code>Flask</code>，但是腾讯云里面免费的<code>SSL证书</code>只有<code>Apache</code>、<code>IIS</code>、<code>Nginx</code>、<code>Tomcat</code>四种，相应的证书对应专属的服务器，因此选择使用配置<code>Nginx</code>服务器，再将相关请求代理到后端服务器处理</p></blockquote><h2 id="环境系统"><a href="#环境系统" class="headerlink" title="环境系统"></a><code>环境系统</code></h2><ul><li><strong>Centos 7</strong></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>安装之后，可以查看<code>nginx</code>的默认安装目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法 1</span></span><br><span class="line">nginx -t </span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法 2</span></span><br><span class="line">whereis nginx</span><br></pre></td></tr></table></figure></p><p><img src="/2019/05/11/腾讯云-Nginx安装与配置HTTPS/1.png" alt="1"></p><h2 id="设置启动"><a href="#设置启动" class="headerlink" title="设置启动"></a>设置启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置自动启动</span></span><br><span class="line">systemctl enable nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx</span></span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><h2 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h2><ul><li><code>腾讯云</code> -&gt; <code>SSL证书管理</code> -&gt; <code>申请</code></li><li>下载证书，将对应的<code>nginx</code>服务器证书上传到腾讯云上<ul><li>在配置<code>nginx</code>需要用到，本文将证书放到<code>/etc/nginx/SSL</code>文件夹</li></ul></li></ul><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><ul><li><code>cd /etc/nginx</code></li><li><code>vi nginx.conf</code>，修改相应部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  xxx.xxx.cn;                    # 对应的域名或者host</span><br><span class="line">    rewrite ^(.*)$ https://$host$1 permanent;   # 默认强制使用https对http进行跳转</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># HTTPS server</span><br><span class="line">#</span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  qcloud.captainp.cn;</span><br><span class="line"></span><br><span class="line">    ssl_certificate      /etc/nginx/SSL/1_qcloud.captainp.cn_bundle.crt;    # 指定对应的证书</span><br><span class="line">    ssl_certificate_key  /etc/nginx/SSL/2_qcloud.captainp.cn.key;           # 指定对应的私钥</span><br><span class="line"></span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">#       root   html;</span><br><span class="line">#       index  index.html index.html;</span><br><span class="line">        proxy_pass http://xxx.xxx.cn:5000/; # 将请求都代理到本机5000，Flask服务器监听的端口进行处理，可以根据需要修改该部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="重启Nginx"><a href="#重启Nginx" class="headerlink" title="重启Nginx"></a>重启Nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><h2 id="问题补充与解决"><a href="#问题补充与解决" class="headerlink" title="问题补充与解决"></a>问题补充与解决</h2><blockquote><p>在之前的成功配置后，某天在使用在服务器后，突然发现访问异常了，服务被拒绝，简单的重启服务器后，再次请求，发现服务器日志没有相关请求信息，猜想nginx的服务出现了问题</p></blockquote><ul><li>首先检查nginx的配置是否正确：<br>  <code>nginx -t -c /etc/nginx/nginx.conf</code></li><li>发现有以下报错：<br>  <code>nginx: [emerg] open() &quot;/var/run/nginx/nginx.pid&quot; failed (2: No such file or directory)</code></li><li><p>查阅相关博客：<br>  不要在/var/run目下创建新目录。</p><p>  centos7，创建<code>了/var/run/nginx/</code>目录存放<code>nginx.pid</code>，<strong>每次重启后，/var/run目录下都会清空！</strong></p><p>  <strong>解决方法</strong>：</p><ul><li><code>$vi /etc/nginx/nginx.conf</code></li><li>修改相应部分  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pid       /var/run/nginx/nginx.pid;</span><br><span class="line">pid        /home/nginx/pid/nginx.pid;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在写项目的时候，在将后台服务器部署到腾讯云后，因为前端是小程序，微信小程序开发对于正常使用必须基于&lt;code&gt;HTTPS&lt;/code&gt;请求，因此需要配置&lt;code&gt;HTTPS&lt;/code&gt;。&lt;br&gt;本来是使用比较简单&lt;code&gt;openssl&lt;
      
    
    </summary>
    
      <category term="centos" scheme="http://yoursite.com/categories/centos/"/>
    
    
      <category term="安装配置" scheme="http://yoursite.com/tags/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Flask服务器部署的踩坑记录</title>
    <link href="http://yoursite.com/2019/05/02/Flask%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/05/02/Flask服务器部署的踩坑记录/</id>
    <published>2019-05-02T08:34:25.000Z</published>
    <updated>2019-05-02T08:49:52.364Z</updated>
    
    <content type="html"><![CDATA[<p>今天在腾讯云进行flask后台进行配置的时候，按照官方的方法无论如何都无法访问到服务器</p><h2 id="官方关于外部可访问的服务器配置"><a href="#官方关于外部可访问的服务器配置" class="headerlink" title="官方关于外部可访问的服务器配置"></a>官方关于外部可访问的服务器配置</h2><blockquote><p><a href="http://docs.jinkan.org/docs/flask/quickstart.html" target="_blank" rel="noopener">快速入门 — Flask 0.10.1 文档</a></p><p>如果你运行了这个服务器，你会发现它只能从你自己的计算机上访问，网络中其它任何的地方都不能访问。在调试模式下，用户可以在你的计算机上执行任意 Python 代码。因此，这个行为是默认的。</p><p>如果你禁用了 debug 或信任你所在网络的用户，你可以简单修改调用 <a href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.run" target="_blank" rel="noopener"><code>run()</code></a> 的方法使你的服务器公开可用，如下:</p><p><code>app.run(host=&#39;0.0.0.0&#39;)</code></p><p>这会让操作系统监听所有公网 IP。</p></blockquote><p>然而并不行，接着看了网上各种相关问题，主要有几种方面的问题</p><ul><li><p>防火墙是否开放</p><p>这个是与自己的云服务配置相关，需要配置相应的安全组，或者内部直接开启相应的防火墙端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加 --permanent永久生效，没有此参数重启后失效</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent   </span><br><span class="line"><span class="meta">#</span> 重新载入</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>当然也可以暴力点把防火墙直接关掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta">#</span> 关闭</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li><li><p>是否修改了默认的IP为<code>0.0.0.0</code></p></li></ul><p>然而尽管这些都弄好了，问题还是没有解决。接下来将介绍<strong>Window 10</strong>以及<strong>Centos 7</strong>下我的解决方法</p><h2 id="Window-10"><a href="#Window-10" class="headerlink" title="Window 10"></a>Window 10</h2><blockquote><p>Pycharm</p></blockquote><p>需要修改项目的一些配置，流程如下图</p><p><img src="/2019/05/02/Flask服务器部署的踩坑记录/1.png" alt="1"></p><p><img src="/2019/05/02/Flask服务器部署的踩坑记录/2.png" alt="2"></p><p><img src="/2019/05/02/Flask服务器部署的踩坑记录/3.png" alt="3"></p><p>最后发现运行的命令变成了<code>python.exe -m flask run --host=0.0.0.0</code>，并且相应的IP地址也变成了<code>0.0.0.0</code>，此时测试发现服务器能够被外部正常访问了。发现Flask的服务修改默认的IP和端口需要显示指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python.exe -m flask run --host=0.0.0.0 -- port=8080</span><br></pre></td></tr></table></figure></p><h2 id="Centos-7"><a href="#Centos-7" class="headerlink" title="Centos 7"></a>Centos 7</h2><p>其原理其实和<code>Window 10</code>环境一样，不过不需要重新配置项目，只需要直接修改运行命令即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run -h 0.0.0.0 -p 5000</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在腾讯云进行flask后台进行配置的时候，按照官方的方法无论如何都无法访问到服务器&lt;/p&gt;
&lt;h2 id=&quot;官方关于外部可访问的服务器配置&quot;&gt;&lt;a href=&quot;#官方关于外部可访问的服务器配置&quot; class=&quot;headerlink&quot; title=&quot;官方关于外部可访问的服
      
    
    </summary>
    
      <category term="Flask" scheme="http://yoursite.com/categories/Flask/"/>
    
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现简单的API网关</title>
    <link href="http://yoursite.com/2019/04/25/Golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84API%E7%BD%91%E5%85%B3/"/>
    <id>http://yoursite.com/2019/04/25/Golang实现简单的API网关/</id>
    <published>2019-04-25T14:08:48.000Z</published>
    <updated>2019-04-25T15:52:18.496Z</updated>
    
    <content type="html"><![CDATA[<p>在最近的一个项目中，采用了微服务架构-<code>go-kit</code>进行后端的开发。在微服务架构风格中，一个大应用被拆分成为了多个小的服务系统提供出来，这些小的系统他们可以自成体系，也就是说这些小系统可以拥有自己的数据库，框架甚至语言等，因此我们需要设计一个<strong>API 网关(API Gataway)</strong>，其实网上已经有较多现成的实现框架，但是本项目的需求是比较简单的，因此将使用<code>Golang</code>自行实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。</p></blockquote><p>用于实现API网关的技术有很多，大致分为这么几类：</p><ul><li>通用反向代理：<code>Nginx</code>、<code>Haproxy</code>、……</li><li>网络编程框架：<code>Netty</code>、<code>Servlet</code>、……</li><li>API网关框架：<code>Spring Cloud Gateway</code>、<code>Zuul</code>、<code>Zuul2</code>、……</li></ul><p>API网关最基本的功能就是反向代理。其实现方式有很多，本文将基于标准库<code>net/http/httputil</code>包中的<code>ReverseProxy</code>类型来实现实现一个简单的反向代理。反向代理的实现主要涉及到<code>func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy</code>和<code>type ReverseProxy</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleHostReverseProxy</span><span class="params">(target *url.URL)</span> *<span class="title">ReverseProxy</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSingleHostReverseProxy returns a new ReverseProxy that routes</span></span><br><span class="line"><span class="comment">// URLs to the scheme, host, and base path provided in target. If the</span></span><br><span class="line"><span class="comment">// target's path is "/base" and the incoming request was for "/dir",</span></span><br><span class="line"><span class="comment">// the target request will be for /base/dir.</span></span><br><span class="line"><span class="comment">// NewSingleHostReverseProxy does not rewrite the Host header.</span></span><br><span class="line"><span class="comment">// To rewrite Host headers, use ReverseProxy directly with a custom</span></span><br><span class="line"><span class="comment">// Director policy.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSingleHostReverseProxy</span><span class="params">(target *url.URL)</span> *<span class="title">ReverseProxy</span></span> &#123;</span><br><span class="line">targetQuery := target.RawQuery</span><br><span class="line">director := <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request)</span></span> &#123;</span><br><span class="line">req.URL.Scheme = target.Scheme</span><br><span class="line">req.URL.Host = target.Host</span><br><span class="line">req.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)</span><br><span class="line"><span class="keyword">if</span> targetQuery == <span class="string">""</span> || req.URL.RawQuery == <span class="string">""</span> &#123;</span><br><span class="line">req.URL.RawQuery = targetQuery + req.URL.RawQuery</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">req.URL.RawQuery = targetQuery + <span class="string">"&amp;"</span> + req.URL.RawQuery</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := req.Header[<span class="string">"User-Agent"</span>]; !ok &#123;</span><br><span class="line"><span class="comment">// explicitly disable User-Agent so it's not set to default value</span></span><br><span class="line">req.Header.Set(<span class="string">"User-Agent"</span>, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;ReverseProxy&#123;Director: director&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewSingleHostReverseProxy</code>返回一个新的<code>ReverseProxy</code>，将<code>URLs</code>请求路由到<code>targe</code>的指定的<code>scheme</code>, <code>host</code>, <code>base path</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReverseProxy is an HTTP Handler that takes an incoming request and</span></span><br><span class="line"><span class="comment">// sends it to another server, proxying the response back to the</span></span><br><span class="line"><span class="comment">// client.</span></span><br><span class="line"><span class="keyword">type</span> ReverseProxy <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Director must be a function which modifies</span></span><br><span class="line"><span class="comment">// the request into a new request to be sent</span></span><br><span class="line"><span class="comment">// using Transport. Its response is then copied</span></span><br><span class="line"><span class="comment">// back to the original client unmodified.</span></span><br><span class="line"><span class="comment">// Director must not access the provided Request</span></span><br><span class="line"><span class="comment">// after returning.</span></span><br><span class="line">Director <span class="function"><span class="keyword">func</span><span class="params">(*http.Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Transport</span> <span class="title">http</span>.<span class="title">RoundTripper</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">FlushInterval</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ErrorLog</span> *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">BufferPool</span> <span class="title">BufferPool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ModifyResponse</span> <span class="title">is</span> <span class="title">an</span> <span class="title">optional</span> <span class="title">function</span> <span class="title">that</span> <span class="title">modifies</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">// <span class="title">Response</span> <span class="title">from</span> <span class="title">the</span> <span class="title">backend</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">called</span> <span class="title">if</span> <span class="title">the</span> <span class="title">backend</span></span></span><br><span class="line"><span class="function">// <span class="title">returns</span> <span class="title">a</span> <span class="title">response</span> <span class="title">at</span> <span class="title">all</span>, <span class="title">with</span> <span class="title">any</span> <span class="title">HTTP</span> <span class="title">status</span> <span class="title">code</span>.</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">the</span> <span class="title">backend</span> <span class="title">is</span> <span class="title">unreachable</span>, <span class="title">the</span> <span class="title">optional</span> <span class="title">ErrorHandler</span> <span class="title">is</span></span></span><br><span class="line"><span class="function">// <span class="title">called</span> <span class="title">without</span> <span class="title">any</span> <span class="title">call</span> <span class="title">to</span> <span class="title">ModifyResponse</span>.</span></span><br><span class="line"><span class="function">//</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">ModifyResponse</span> <span class="title">returns</span> <span class="title">an</span> <span class="title">error</span>, <span class="title">ErrorHandler</span> <span class="title">is</span> <span class="title">called</span></span></span><br><span class="line"><span class="function">// <span class="title">with</span> <span class="title">its</span> <span class="title">error</span> <span class="title">value</span>. <span class="title">If</span> <span class="title">ErrorHandler</span> <span class="title">is</span> <span class="title">nil</span>, <span class="title">its</span> <span class="title">default</span></span></span><br><span class="line"><span class="function">// <span class="title">implementation</span> <span class="title">is</span> <span class="title">used</span>.</span></span><br><span class="line"><span class="function"><span class="title">ModifyResponse</span> <span class="title">func</span><span class="params">(*http.Response)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ErrorHandler</span> <span class="title">func</span><span class="params">(http.ResponseWriter, *http.Request, error)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><code>ReverseProxy</code>类型有两个重要的属性，分别是<code>Director</code>和<code>ModifyResponse</code>，这两个属性都是函数类型，在接收到客户端请求时，<code>ServeHTTP</code>函数首先调用<code>Director</code>函数对接受到的请求体进行修改，例如修改请求的目标地址、请求头等；然后使用修改后的请求体发起新的请求，接收到响应后，调用<code>ModifyResponse</code>函数对响应进行修改，最后将修改后的响应体拷贝并响应给客户端，这样就实现了反向代理的整个流程。</p><p>在<code>NewSingleHostReverseProxy</code>中源码已经对传入的<code>URLs</code>进行解析并且完成了<code>Director</code>的修改，我们只需要调用<code>NewSingleHostReverseProxy</code>函数并且传入目标服务器的URL即可，一个简单的反向代理就完成了啦。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote><p>实例代码只涉及微服务中 <code>user</code> 与 <code>auth</code>模块，可以根据实际需求自行修改部分</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handle <span class="keyword">struct</span> &#123;</span><br><span class="line">host <span class="keyword">string</span></span><br><span class="line">port <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">auth *handle</span><br><span class="line">user *handle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Service)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> remote *url.URL</span><br><span class="line"><span class="keyword">if</span> strings.Contains(r.RequestURI, <span class="string">"api/auth"</span>) &#123;</span><br><span class="line">remote, _ = url.Parse(<span class="string">"http://"</span> + this.auth.host + <span class="string">":"</span> + this.auth.port)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.Contains(r.RequestURI, <span class="string">"api/user"</span>) &#123;</span><br><span class="line">remote, _ = url.Parse(<span class="string">"http://"</span> + this.user.host + <span class="string">":"</span> + this.user.port)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"404 Not Found"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">proxy := httputil.NewSingleHostReverseProxy(remote)</span><br><span class="line">proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 注册被代理的服务器 (host， port)</span></span><br><span class="line">service := &amp;Service&#123;</span><br><span class="line">auth: &amp;handle&#123;host: <span class="string">"127.0.0.1"</span>, port: <span class="string">"8081"</span>&#125;,</span><br><span class="line">user: &amp;handle&#123;host: <span class="string">"127.0.0.1"</span>, port: <span class="string">"8082"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8888"</span>, service)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">startServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://www.shawpo.me/post/ezapi-reverse/" target="_blank" rel="noopener">Golang实现简单的微服务网关——反向代理</a></li><li><a href="https://cloud.tencent.com/developer/article/1415041" target="_blank" rel="noopener">各大API网关性能比较</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在最近的一个项目中，采用了微服务架构-&lt;code&gt;go-kit&lt;/code&gt;进行后端的开发。在微服务架构风格中，一个大应用被拆分成为了多个小的服务系统提供出来，这些小的系统他们可以自成体系，也就是说这些小系统可以拥有自己的数据库，框架甚至语言等，因此我们需要设计一个&lt;str
      
    
    </summary>
    
      <category term="Go | 微服务" scheme="http://yoursite.com/categories/Go-%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计-作业3</title>
    <link href="http://yoursite.com/2019/04/13/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A3/"/>
    <id>http://yoursite.com/2019/04/13/系统分析与设计-作业3/</id>
    <published>2019-04-13T11:38:47.000Z</published>
    <updated>2019-04-14T12:42:47.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><ul><li><p><strong>简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点</strong></p><blockquote><p>从项目特点、风险特征、人力资源利用角度思考</p></blockquote><ul><li><strong>瀑布模型</strong><br>瀑布模型是将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品。<ul><li><code>优点</code>：定义了软件开发基本流程与活动，降低软件开发的复杂程度，提高软件开发过程的透明性，提高开发过程的可管理性。</li><li><code>缺点</code>：强调过程活动的线性顺序，缺乏灵活性，尤其无法解决软件需求不明确的问题，对于风险的控制能力较弱。瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量，同时管理人员如果仅仅以文档的完成情况来评估项目完成进度，往往会产生错误的结论。</li></ul></li><li><strong>增量模型</strong><br>增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件，同时每个中间版本都要执行必需的过程、活动和任务。<ul><li><code>优点</code>：以组件为单位进行开发降低了软件开发的风险，一个开发周期内的错误不会影响到整个软件系统，降低系统失败风险以及提高系统的可靠性、稳定性喝可维护性。开发顺序灵活，开发人员可以对组件的实现顺序进行优先级排序，先完成需求稳定的核心组件，当组件的优先级发生变化时，还能及时地对实现顺序进行调，对于人力资源的调度更加灵活。</li><li><code>缺点</code>：建立初始模型时，作为增量基础的基本业务服务的确定有一定难度，同时对于增量粒度难以选择。</li></ul></li><li><strong>螺旋模型（含原型方法）</strong><br>螺旋模型采用一种周期性的方法来进行系统开发，其是风险驱动的迭代过程，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。<ul><li><code>优点</code>：适用于需求功能复杂、开发周期长的大项目。引入了明确的风险管理机制。设计上的灵活性,可以在项目的各个阶段进行变更。客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。以小的分段来构建大型系统,使成本计算变得简单容易。</li><li><code>缺点</code>：螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并做出相关反应并不容易，因此螺旋模型往往比较适合内部的大规模软件开发。风险分析需要耗费相当的成本，同时失误的风险分析可能带来更大的风险。 </li></ul></li></ul></li><li><p><strong>简述统一过程三大特点，与面向对象的方法有什么关系？</strong></p><ul><li><p><strong>统一过程的三大特点</strong></p><ul><li><p>统一过程是迭代和增量的过程<br>  RUP强调采用迭代和增量方式来开发软件，把整个项目开发分为多个迭代过程。在每一次迭代中，只考虑系统的一部分需求，进行分析、设计、实现、测试、部署等过程，每次迭代是在已完成部分的基础上进行的，每次增加一些新的功能实现，以此进行下去，直至最后项目的完成。</p></li><li><p>统一过程是用例驱动的<br>  Use Case模型表达了系统的需求。开发过程是沿着一系列从用例得到的工作流前进的：用例被确定、用例被设计、最后用例又称为测试人员构造测试用例的基础。</p></li><li><p>统一过程是以构架为中心的<br>  软件构架的作用与建筑构架所起的作用类似，软件系统的构架是从不同的角度描述即将构造的系统，构架刻画了系统的整体设计，去掉了细节部分，突出了系统的重要特性。</p></li></ul></li><li><p><strong>与面向对象的联系</strong> 统一软件过程是一个面向对象且基于网络的程序开发方法论，其可以为所有方面和层次的程序开发提供指导方针，模版以及事例支持。</p></li></ul></li><li><p><strong>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</strong></p><p>  RUP中的软件生命周期在<strong>时间维度</strong>上被分解为四个顺序的阶段： <strong>初始阶段(Inception)</strong>、<strong>精化阶段(Elaboration)</strong>、<strong>构建阶段 (Construction)</strong>和<strong>产品交付阶段(Transition)</strong>。每个阶段结束于一个主要的里程碑(Major Milestone)，并在阶段结尾执行一次评估以确定这个阶段的目标是否已经满足。如果评估结果令人满意的话，可以允许项目进入下一个阶段</p><p>  <strong>里程碑</strong></p><ul><li><strong>初始阶段</strong>里程碑：生命周期目标(Lifecycle Objective)里程碑，包括一些重要的文档，如：项目构想(Vision)、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务案例等。通过对文档的评审确定用例需求理解正确、项目风险评估合理、阶段计划可行等</li><li><strong>精华阶段</strong>里程碑：生命周期体系结构(Lifecycle Architecture)里程碑，包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软 件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。</li><li><strong>构建阶段</strong>里程碑：初始运行能力(Initial Operational Capability) 里程碑， 包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。</li><li><strong>产品化阶段/移交阶段</strong>里程碑：产品发布(Product Release) 里程碑，确定最终目标 是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段相重合。</li></ul></li><li><p><strong>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</strong><br>  利用软件产品范围的弹性，合理规划范围（20%业务决定80%满意度），使得软件生产按固定节奏运行，固定迭代周期、固定开发周期、固定升级周期。</p><p>  固定节奏生产明确了不同阶段迭代的里程碑与目标，使得开发团队更加明确当前的开发目标，更加容易确定当前进度，同时更加利于人力等各种资源的分配，利于管理，利于提高整体的开发效率。同时固定周期发布软件产品，能提高客户的信任度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单题&quot;&gt;&lt;a href=&quot;#简单题&quot; class=&quot;headerlink&quot; title=&quot;简单题&quot;&gt;&lt;/a&gt;简单题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="系统分析与设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统分析与设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 作业2</title>
    <link href="http://yoursite.com/2019/03/29/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A2/"/>
    <id>http://yoursite.com/2019/03/29/系统分析与设计-作业2/</id>
    <published>2019-03-29T02:18:48.000Z</published>
    <updated>2019-03-30T08:57:25.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><hr><h2 id="用简短的语言给出对分析、设计的理解"><a href="#用简短的语言给出对分析、设计的理解" class="headerlink" title="用简短的语言给出对分析、设计的理解"></a>用简短的语言给出对分析、设计的理解</h2><ul><li><strong>分析</strong>的主要任务基于客户的大致需求，对其进行研究和提取更加具体详细的核心内容，其强调的是对问题的调查和需求的研究，而不是解决方案。</li><li><strong>设计</strong>的主要任务是基于分析的成果，构建出合理的满足要求的模型或者解决方案，其强调满足要求的概念解决方案（在软件和硬件中），而不是其实现</li></ul><h2 id="用一句话描述面向对象的分析与设计的优势"><a href="#用一句话描述面向对象的分析与设计的优势" class="headerlink" title="用一句话描述面向对象的分析与设计的优势"></a>用一句话描述面向对象的分析与设计的优势</h2><p>分析人员不必是“语言专家”，他们不需要掌握其他领域的专业技能。在开发过程中，问题领域的专家和实施级别的专家可以使用通用表示法进行通信</p><h2 id="简述-UML（统一建模语言）的作用。考试考哪些图？"><a href="#简述-UML（统一建模语言）的作用。考试考哪些图？" class="headerlink" title="简述 UML（统一建模语言）的作用。考试考哪些图？"></a>简述 UML（统一建模语言）的作用。考试考哪些图？</h2><ul><li>UML的作用<ul><li><code>UML作为草图</code> - 非正式和不完整的图表（通常在白板上手绘），<strong>用于探索问题或解决方案空间的难点，利用可视语言的力量</strong></li><li><code>UML作为蓝图</code> - <strong>使用相对详细的设计图表，在逆向工程中让工程师更容易理解项目的设计，在正向工程中利于设计的实现</strong></li><li><code>UML作为编程语言</code> -  <strong>用UML完成软件系统的可执行规范。可执行代码将自动生成。</strong></li></ul></li><li>考察内容<ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系     </li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布状况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul></li></ul><h2 id="从软件本质的角度，解释软件范围（需求）控制的可行性"><a href="#从软件本质的角度，解释软件范围（需求）控制的可行性" class="headerlink" title="从软件本质的角度，解释软件范围（需求）控制的可行性"></a>从软件本质的角度，解释软件范围（需求）控制的可行性</h2><p>在实际软件项目中，即使在有明确的软件开发合同条件下，仍然无法确定出完善的软件需求规格说明书，因为软件生产是易变、不可见、独特的智力生产，其不同于其余具有标准可度量的生产模式。同时由于软件本身的复杂性、不可见性、不一致性、可变性，并且在软件开发的过程中对于软件需求的控制并不是不可商量的，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程，因此需要对软件范围进行一定的控制，我们需要从用户的不明确需求中提取出基本需求，砍去一些不合理或者是不明确的部分，在满足其基本需求的基础下，不断进行迭代，不断进行完善</p><p><hr></p><hr><h1 id="项目管理实践"><a href="#项目管理实践" class="headerlink" title="项目管理实践"></a>项目管理实践</h1><hr><h2 id="看板使用练习"><a href="#看板使用练习" class="headerlink" title="看板使用练习"></a>看板使用练习</h2><ul><li>使用截图工具（png格式输出），展现你团队的任务 Kanban</li><li>每个人的任务是明确的。必须一周后可以看到具体结果</li><li>每个人的任务是1-2项</li><li>至少包含一个团队活动任务</li></ul><p><img src="/2019/03/29/系统分析与设计-作业2/kanban.png" alt="kanban"></p><h2 id="UML绘图工具练习"><a href="#UML绘图工具练习" class="headerlink" title="UML绘图工具练习"></a>UML绘图工具练习</h2><ul><li>请在 参考书2 或 教材 中选择一个类图（给出参考书页码图号）</li></ul><blockquote><p><code>UML和模式应用（原书第3版） P6 1-3 骰子游戏的局部领域模型</code></p></blockquote><p><img src="/2019/03/29/系统分析与设计-作业2/UML.png" alt="UML"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;用简短的语言给出对分析、设计的理解&quot;&gt;&lt;a href=&quot;#用简短的语言给出对分析、设计的理解&quot; class=&quot;h
      
    
    </summary>
    
      <category term="系统分析与设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统分析与设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>系统分析与设计 作业1</title>
    <link href="http://yoursite.com/2019/03/09/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A1/"/>
    <id>http://yoursite.com/2019/03/09/系统分析与设计-作业1/</id>
    <published>2019-03-09T05:22:43.000Z</published>
    <updated>2019-03-09T12:12:44.729Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h3><p>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科</p><h3 id="解释导致-software-crisis-本质原因、表现，述说克服软件危机的方法"><a href="#解释导致-software-crisis-本质原因、表现，述说克服软件危机的方法" class="headerlink" title="解释导致 software crisis 本质原因、表现，述说克服软件危机的方法"></a>解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</h3><ul><li>软件危机(<code>software crisis</code>)<strong>本质原因</strong>主要是用户需求不明确、软件开发过程缺乏正确的理论指导、软件开发的规模越来越大且软件开发的复杂度越来越高，其根源为软件的大量需求与软件生产力效率之间的矛盾和软件系统的复杂性与软件开发方法之间的矛盾 </li><li><strong>表现</strong><ul><li>项目运行超出预算</li><li>项目运行超出时间</li><li>软件质量低落</li><li>软件通常不匹配需求</li><li>项目无法管理，且代码难以维护</li></ul></li><li><strong>克服软件危机的方法</strong><ul><li>正确认识计算机软件的内涵</li><li>采用工程项目管理方法实施软件开发的管理（软件开发应该是一种组织良好、管理严密、协同配合的工程活动）</li><li>采用成熟的软件开发技术和方法，开发和使用适当的软件工具</li></ul></li></ul><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><p>计算机软件有一个孕育、诞生、成长、成熟、衰亡的生存过程，这样的过程称为软件的生命周期(也称软件开发生命周期SDLC)。软件生命周期将软件开发过程划分为若干阶段，每个阶段有明确的任务 目标和运行机制，从而使复杂的软件开发过程能够得到适当的控制 和管理。 软件生命周期一般包括可行性分析与计划、需求分析、设计(概要 设计和详细设计)、编码实现、测试、运行与维护等活动。这些活动应当以适当的方式分配到不同的阶段去完成。</p><p>软件生命周期的6个阶段：</p><ul><li>可行性分析与计划阶段</li><li>需求分析阶段</li><li>设计阶段</li><li>实现阶段</li><li>测试阶段</li><li>运行与维护阶段 </li></ul><h3 id="SWEBoK-的-15-个知识域（An-Overview-of-the-SWEBOK-Guide-）"><a href="#SWEBoK-的-15-个知识域（An-Overview-of-the-SWEBOK-Guide-）" class="headerlink" title="SWEBoK 的 15 个知识域（An Overview of the SWEBOK Guide ）"></a>SWEBoK 的 15 个知识域（<a href="https://www.sebokwiki.org/wiki/An_Overview_of_the_SWEBOK_Guide" target="_blank" rel="noopener">An Overview of the SWEBOK Guide</a> ）</h3><ul><li><p><strong>软件要求 <code>Software Requirements</code></strong></p><p>关注软件需求的启发，协商，分析，规范和验证。软件需求表达对软件产品的需求和限制，这些需求和约束有助于解决一些现实问题。</p></li><li><p><strong>软件设计 <code>Software Design</code></strong></p><p>软件设计涵盖了设计过程和最终产品，软件设计的过程是软件工程生命周期活动，其中分析软件需求以产生软件内部结构及其行为的描述，其将作为其构造的基础。软件设计（结果）必须描述软件体系结构 - 即软件如何分解和组织成组件以及这些组件之间的接口。它还必须描述能够构建它们的详细程度的组件。</p></li><li><p><strong>软件构建 <code>Software Construction</code></strong></p><p>软件构建是指通过结合详细设计，编码，单元测试，继承测试，调试和验证来详细创建工作软件。软件构建包括与满足其要求和设计约束的软件程序开发相关的主题，涵盖了软件构建基础、管理软件建设、建筑技术、实际考虑和软件构建工具。</p></li><li><p><strong>软件测试 <code>Software Testing</code></strong></p><p>软件测试旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。软件测试包括软件测试的基础知识、测试技术、人机界面测试与评估、与测试有关的措施和实际考虑。</p></li><li><p><strong>软件维护 <code>Software Maintenance</code></strong></p><p>软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。软件维护包括软件维护的基础知识（维护的性质和需求，维护类别，维护成本）、软件维护中的关键问题（技术问题，管理问题，维护成本估算，软件维护测量）、 维护过程、软件维护技术（程序理解，重新设计，逆向工程，重构，软件退役）、灾难恢复技术和软件维护工具。</p></li><li><p><strong>软件配置管理 <code>Software Configuration Management</code></strong></p><p>软件配置管理是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。软件配置管理涵盖SCM过程的管理、软件配置识别，控制，状态核算，审计、软件发布管理和交付;</p></li><li><p><strong>软件工程管理 <code>Software Engineering Management</code></strong></p><p>软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。软件工程管理涵盖了启动和范围定义（确定和协商要求，可行性分析以及要求的审查和修订）、软件项目计划（过程计划，工作量估算，成本和进度，资源分配，风险分析，质量计划）、软件项目制定（计量，报告和控制;收购和供应商合同管理）、产品验收、审查和分析项目绩效、项目结束和软件管理工具。</p></li><li><p><strong>软件工程过程 <code>Software Engineering Process</code></strong></p><p>软件工程过程关注软件生命周期过程的定义，实施，评估，测量，管理和改进，其涵盖的主题包括流程实施和变更（流程基础架构，流程实施和变更模型以及软件流程管理）、流程定义（软件生命周期模型和流程，流程定义，流程适应和流程自动化的符号）、过程评估模型和方法、测量（过程测量，产品测量，测量技术和测量结果的质量）和软件处理工具</p></li><li><p><strong>软件工程模型和方法 <code>Software Engineering Models and Methods</code></strong></p><p>涵盖的主题包括建模、 模型类型、分析、和软件开发方法。</p></li><li><p><strong>软件质量 <code>Software Quality</code></strong></p><p>软件质量包括软件质量的基础知识（软件工程文化，软件质量特性，软件质量的价值和成本以及软件质量改进）、软件质量管理流程（软件质量保证，验证和确认，审核和审核和实际考虑（缺陷表征，软件质量测量和软件质量工具）</p></li><li><p><strong>软件工程专业实践 <code>Software Engineering Professional Practice</code></strong></p><p>关注软件工程师必须具备的专业，负责和道德的软件工程知识，技能和态度，涵盖专业性、道德准则、小组动态和够通技巧</p></li><li><p><strong>软件工程经济学 <code>Software Engineering Economics</code></strong></p><p>关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。涵盖的主题包括软件工程经济学的基本原理（提案，现金流量，货币时间价值，计划视野，通货膨胀，折旧，替代和退休决策）；非营利性决策（成本效益分析，优化分析）; 估计，经济风险和不确定性（估算技术，风险决策和不确定性）; 和多属性决策（价值和衡量尺度，补偿和非补偿技术）。</p></li><li><p><strong>计算基础 <code>Computing Foundations</code></strong></p><p>提供软件工程实践所需的计算背景的基础主题。涵盖的主题包括问题解决技术，抽象，算法和复杂性，编程基础，并行和分布式计算的基础知识，计算机组织，操作系统和网络通信。</p></li><li><p><strong>数学基础 <code>Mathematical Foundations</code></strong></p><p>提供软件工程实践所必需的数学背景的基础主题。涵盖的主题包括集合，关系和功能; 基本命题和谓词逻辑; 证明技术; 图形和树木; 离散概率; 语法和有限状态机; 和数论。</p></li><li><p><strong>工程基础 <code>Engineering Foundations</code></strong></p><p>提供软件工程实践所必需的工程背景的基础主题。涵盖的主题包括经验方法和实验技术; 统计分析; 测量和指标; 工程设计; 仿真与建模; 和根本原因分析。</p></li></ul><h3 id="简单解释-CMMI-的五个级别。"><a href="#简单解释-CMMI-的五个级别。" class="headerlink" title="简单解释 CMMI 的五个级别。"></a>简单解释 CMMI 的五个级别。</h3><ul><li><p>Level 1 - Initial</p><p><code>初始级</code>。无序，自发生产模式。管理是反应式的。</p></li><li><p>Level 2 - Managed</p><p><code>可管理级</code>。建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。</p></li><li><p>Level 3 - Defined</p><p><code>已定义级</code>。已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。</p></li><li><p>Level 4 - Quantitatively Managed</p><p><code>量化管理级</code>。分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。</p></li><li><p>Level 5 - Optimizing</p><p><code>优化管理级</code>。过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。</p></li></ul><h3 id="用自己语言简述-SWEBok-或-CMMI"><a href="#用自己语言简述-SWEBok-或-CMMI" class="headerlink" title="用自己语言简述 SWEBok 或 CMMI"></a>用自己语言简述 SWEBok 或 CMMI</h3><p>CMMI全称Capability Maturity Model Integration，是能力成熟度集成模型，是由美国国防部与卡内基-梅隆大学和美国国防工业协会共同开发和研制的，其整合传统上独立的组织功能，设定流程改进目标和优先级，为质量流程提供指导，并为评估当前流程提供参考。该架构能够用来度量你的有效性和实用性；能够找出这样的一些机会，继续改进的机会，包括在商业目标、策略还有降低项目的风险等方面。CMMI为改进一个组织的各种过程提供了一个单一的集成化框架，对于IT产业而言，其帮助IT企业对软件在工作的时候进行管理和不断的改进的，大大的帮助了企业的开发，也帮助企业增强了改进能力，从而可以帮助企业壮大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;软件工程的定义&quot;&gt;&lt;a href=&quot;#软件工程的定义&quot; class=&quot;headerlink&quot; title=&quot;软件工程的定义&quot;&gt;&lt;/a&gt;软件工程的定义&lt;/h3&gt;&lt;p&gt;应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发
      
    
    </summary>
    
      <category term="系统分析与设计" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统分析与设计" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>区块链发展与现状</title>
    <link href="http://yoursite.com/2019/01/08/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8F%91%E5%B1%95%E4%B8%8E%E7%8E%B0%E7%8A%B6/"/>
    <id>http://yoursite.com/2019/01/08/区块链发展与现状/</id>
    <published>2019-01-08T10:46:04.000Z</published>
    <updated>2019-01-08T10:46:17.932Z</updated>
    
    <content type="html"><![CDATA[<p>​本次主要阅读了三篇论文，所探讨的主题与当前区块链的安全性以及区块链市场相关。论文<sup><a href="#fn_1" id="reffn_1">1</a></sup>主要以Mt.Gox交易所的交易网络作为样本分析加密货币市场中的市场操纵以及操纵模式，其将交易历史通过一系列的分析以及构造成需要的图，将所有账号分成三类：高账户（EHA）、低账户（ELA）、一般账户（NMA），数据分析发现不正常的账户交易和比特币的价格有关联，此外异常账户存在许多奇怪的事务模式（如自循环、双向、三角形等），这些模式证明了交易市场中存在大量的市场操纵行为。论文<sup><a href="#fn_2" id="reffn_2">2</a></sup>主要通过数据处理和机器学习方法来检测庞氏骗局，其主要基于分析用户交易信息得到用户特征以及反解智能合约的字节码得到操作码，该方法对于检测不提供源代码的智能合约（用户无法之间了解真正的合约内容）是否为庞氏骗局有较大的意义。论文<sup><a href="#fn_3" id="reffn_3">3</a></sup>主要利用图分析技术对区块链中的用户特征进行分类，并用交叉图技术研究以太坊安全问题。</p><p>​区块链可以说是当今最热门的研究方向之一，很多区块链项目也已经落地。但是目前区块链市场方面还是比较混乱的，区块链因为其匿名性以及去中心化吸引大量关注，但是也因为其特性而导致其更加的难以管控与更多安全性问题。目前区块链市场情况比较复杂，很多人只是利用区块链项目圈钱，割完“韭菜”就跑路，也有部分人通过ICO(首次代币发行)进行非法集资，同时存在许多欺诈行为，受害者被骗以后也难以追究到具体的责任（匿名性），更别说挽回损失，更多的只能在各大论坛上发自己被骗了发发牢骚。同时，对于Mt.Gox交易所泄露的交易信息分析中也发现了大量操纵行为，侧面说明区块链市场操纵盛行。操纵市场行为，原本是指个人或机构背离市场自由竞争和供求关系原则，人为地操纵证券价格，以引诱他人参与证券交易，为自己牟取私利的行为，在区块链市场里面主要是部分人通过某些操纵手段（例如：不正常的事务）来引起加密数字货币的价格浮动，从而从中谋取私利。目前证券市场方面由于国家的严加管控已经难以发生市场操纵的行为，而对于区块链这个去中心化的领域而言，如果不能合理的解决市场操纵的问题，则将会称为少部分人的游戏，将造成巨大的不良影响，也将限制区块链的发展与应用。</p><p>​对于区块链领域，目前国家也出台了相关的文件，对一些违法行为进行了监管与约束，例如严禁通过ICO来进行非法融资，同时也发布相应的科普文章《区块链能做什么、不能做什么？》来避免群众过于盲目而被诈骗，当然国家也大力支持区块链技术的发展。但是区块链方面还是有许多的安全性问题尚未解决，区块链因为其匿名性以及去中心化的特性，让用户更加的自由，但是这也带来一系列的问题。如何保留着区块链的特性的前提下让其亦能够健康的发展是一个难题，不过相信随着研究的更加深入，对于区块链骗局与欺诈将会有更多有效的方法来检测与约束，同时对于市场操纵现象也会有相应合理的管控，使得区块链技术得以更加健康的发展。</p><p>参考文献：<br><sup><a href="#fn_1" id="reffn_1">1</a></sup>: Market Manipulation of Bitcoin: Evidence from Mining the Mt. Gox Transaction Network<br><sup><a href="#fn_2" id="reffn_2">2</a></sup>: Detecting Ponzi Schemes on Ethereum: Towards Healthier BlockchainTechnology<br><sup><a href="#fn_3" id="reffn_3">3</a></sup>: Understanding Ethereum via Graph Analysis</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​本次主要阅读了三篇论文，所探讨的主题与当前区块链的安全性以及区块链市场相关。论文&lt;sup&gt;&lt;a href=&quot;#fn_1&quot; id=&quot;reffn_1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;主要以Mt.Gox交易所的交易网络作为样本分析加密货币市场中的市场操纵以及操纵模式，其将交易历史通过一
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>高性能区块链拓展方法</title>
    <link href="http://yoursite.com/2019/01/07/%E9%AB%98%E6%80%A7%E8%83%BD%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/01/07/高性能区块链拓展方法/</id>
    <published>2019-01-07T06:59:26.000Z</published>
    <updated>2019-01-07T07:03:57.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结当前区块链研究中用于提高区块链系统性能和可扩展性的方法。并详细说明侧链技术，以及通过以太坊构建侧链的方法</p></blockquote><p>如今，性能过低是当前区块链技术面临的主要挑战之一。区块链的性能指标主要包括交易吞吐量和延时。比特币理论上每秒最多只能处理七笔交易，每十分钟出一个区块，相当于交易吞吐量为7，交易延时为10分钟，实际上，等待最终确认需要6个左右的区块，也就是说实际交易延时是1个小时。以太坊稍有提高，但也远远不能满足应用需求。从区块链技术来看，目前影响区块链性能因素主要包括广播通信、信息加解密、共识机制、交易验证机制等几个环节。目前提高区块链性能与扩展性已经提出几种方法，主要包括<strong>分片（Sharding）、离链计算（Off-chain computing）及侧链（Slidechain）、有向无环结构（DAG）</strong>等等，这些方式主要是通过将部分链上任务转到链下或其他链进行处理，或者将整个交易分为几个部分并分别处理，另一种思路是<strong>调整共识机制</strong>，采用新的可扩展的共识协议，从PoW到PoS再到DPoS和各种BFT类算法，共识机制不断创新，区块链平台性能也得到大幅提升，或者<strong>系统优化</strong>，通过优化系统 架构、代码结构、 数据存储效率、 网络发送效率等， 提高区块链性能。</p><ul><li><p>分片（Sharding）。分片技术是一种基于数据库分片传统概念的扩容技术，它将数据库分割成多个碎片并将这些碎片放置在不同的服务器上。在公共区块链的情境中，网络上的交易将被分成不同的碎片，其由网络上的不同节点组成。因此，每个节点只需处理一小部分传入的交易，并且通过与网络上的其他节点并行处理就能完成大量的验证工作。将网络分割为碎片会使得更多的交易同时被处理和验证。因此，随着网络的增长，区块链处理越来越多的交易将成为可能。这种属性也称为水平扩容。</p></li><li><p>有向无环结构（DAG）。DAG区块链技术没有区块概念，不是把所有数据打包成区块，再用区块链接区块，而是每个用户都可以提交一个数据单元，这个数据单元里可以有很多东西，比如交易、消息等等。数据单元间通过引用关系链接起来，从而形成具有半序关系的DAG（有向无环图）。DAG的特点是把数据单元的写入操作异步化，大量的钱包客户端可以自主异步地把交易数据写入DAG，从而可以支持极大的并发量和极高的速度。</p></li><li><p><strong>离链计算/侧链</strong>。在主链之下进行交易，中间交 易不进入主链确认，待最后一 笔交易完成后回归到主链。</p><ul><li><p><strong>什么是侧链？</strong></p><p>侧链本质上是一种<strong>跨区块链解决方案</strong>。通过这种解决方案，可以实现数字资产从第一个区块链到第二个区块链的转移，又可以在稍后的时间点从第二个区块链安全返回到第一个区块链。其中第一个区块链通常被称为主区块链或者主链，每二个区块链则被称为侧链。最初，主链通常指的是比特币区块链，而现在主链可以是任何区块链。侧链协议被设想为一种允许数字资产在主链与侧链之间进行转移的方式，其实现的技术基础是<strong>双向锚定（Two-way Peg）</strong>，通过双向锚定技术，可以实现暂时的将数字资产在主链中锁定，同时将等价的数字资产在侧链中释放，同样当等价的数字资产在侧链中被锁定的时候，主链的数字资产也可以被释放。双向锚定实现的最大难点是协议改造需兼容现有主链，也就是不能对现有主链的工作造成影响，其具体实现方式可以分为以下几类：单一托管模式、联盟模式、SPV模式、驱动链模式、混合模式。</p></li></ul></li></ul><h2 id="以太坊构建侧链的方法"><a href="#以太坊构建侧链的方法" class="headerlink" title="以太坊构建侧链的方法"></a>以太坊构建侧链的方法</h2><p>在以太坊上构建侧链，我们可以使用到Plasma。Plasma是一种处理链下交易的技术，需要依赖以太坊底层技术去对其安全性进行保障，它可以允许在以太坊主链上创建“子链”，同时这些“子链”也可以创建它们自己的“子链”。</p><p>任何人都可以在以太坊主链上创建个人化的 Plasma 智能合约，Plasma智能合约运行在根链（以太坊主网）之上，形成一个可靠的侧链链接网络连接到一个分层和树状结构的根链，强制执行区块链历史和 MapReducible 计算进入一系列的 merkle 证明。同时Plasma 链的一个关键属性是所谓的退出机制，它允许用户放弃子链，一旦出现任何问题时可以将资金提取到根链。所有在 Plasma 链上的交易完成都是依靠加密签章，不需要经过主链的共识，经过一段时间后才批次性的广播并写入主链中。因此大量在 Plasma 上的所有交易最后只会浓缩成少数比交易打包进主链中，大幅度降低区块链膨胀问题。</p><p>更加通俗的说明一下Plasma运作：</p><ul><li>首先，我们需要在以太坊主链创建一套智能合约，作为服务于我们Plasma子链的Root。Plasma Root包含了子链的基本状态交易规则，记录了子链状态的哈希值，并且让用户在以太坊主链和子链之间转移资产。</li><li>然后，在将子链根植于主链上之后，子链就被创造出来了。这个子链拥有自己的共识算法，且独立于以太坊主链。然后，我们就可以依据自己的需求来使用了。</li></ul><p>当然现在也有更加好的平台和工具，例如Loom Network，其被称为以太坊上的EOS，其核心产品是一款SDK - Loom SDK。Loom SDK会生成一个称为DApp链的产物（DApp链使用基于Plasma的中继来与以太坊之间来回转移资产），它是一个用以太坊作为基础层的第二层区块链，同时SDK允许开发者选择他们自己的共识算法和规则集。</p><p>参考文献</p><ul><li><a href="https://plasma.io/plasma.pdf" target="_blank" rel="noopener">Plasma: Scalable Autonomous Smart Contracts</a></li><li><a href="https://medium.com/@argongroup/ethereum-plasma-explained-608720d3c60e" target="_blank" rel="noopener">Explained: Ethereum Plasma</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;总结当前区块链研究中用于提高区块链系统性能和可扩展性的方法。并详细说明侧链技术，以及通过以太坊构建侧链的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如今，性能过低是当前区块链技术面临的主要挑战之一。区块链的性能指标主要包括交易吞吐量和延时。比特
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>DApp开发遇到问题以及解决</title>
    <link href="http://yoursite.com/2018/12/24/DApp%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/12/24/DApp开发遇到问题以及解决/</id>
    <published>2018-12-24T11:19:30.000Z</published>
    <updated>2018-12-26T04:40:19.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次博客简单记录下开发DApp过程中遇到的一些问题，以及相应的解决方案，因此写的也是很随意，仅供参考</p><blockquote><p><a href="https://github.com/Liu-YT/public-comment" target="_blank" rel="noopener">项目地址</a></p></blockquote><h1 id="Vue如何使用Web3"><a href="#Vue如何使用Web3" class="headerlink" title="Vue如何使用Web3"></a>Vue如何使用Web3</h1><ul><li><p>安装<code>Web3</code>的依赖</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3@^0.20.0 --save</span><br></pre></td></tr></table></figure></li><li><p>项目里创建全局<code>web3</code>对象</p><ul><li><p>写一个插件，例如命名为<code>Web3.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Web3 <span class="keyword">from</span> <span class="string">"web3"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    install: <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> web3 = <span class="built_in">window</span>.web3</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            web3 = <span class="keyword">new</span> Web3(web3.currentProvider)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:8545'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        Vue.prototype.$web3 = web3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>main.js</code>里启用该插件，以后就可以这样使用<code>this.$web3</code>这个全局对象了</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Web3)</span><br></pre></td></tr></table></figure></li><li><p>例子</p><ul><li>获得第一个区块的信息  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得第一个区块的信息</span></span><br><span class="line"><span class="keyword">this</span>.$web3.eth.getBlock(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在控制台输出相应信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$web3.eth.getBlock(<span class="number">0</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>参考链接 - <a href="https://segmentfault.com/a/1190000014497742" target="_blank" rel="noopener">基于Vue、web3的以太坊项目开发及交易内幕初探</a></p></li></ul><h1 id="创建账号失败问题"><a href="#创建账号失败问题" class="headerlink" title="创建账号失败问题"></a>创建账号失败问题</h1><blockquote><p>此处Web3.js 1.0与0.2的API混用了，没有搞清楚不同版本的区别</p></blockquote><ul><li><p>创建用户写法</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">this</span>.$web3.eth.personal.newAccount(<span class="string">'sysu'</span>,(err, accounts) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(accounts, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>报错</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &apos;newAccount&apos; of undefined at &lt;anonymous&gt;:1:19</span><br></pre></td></tr></table></figure><p>  控制台再次尝试同样结果，内心崩溃<br>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccountError1.png" alt="newAccount"></p></li><li><p>搜寻许久，发现<code>web3</code>下面使用创建用户的模式应该为</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$web3.personal.newAccount(<span class="string">'sysu'</span>, (err, addr) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  即<code>personal</code>不是在<code>eth</code>命名空间下，与在<code>geth</code>中的控制台使用有所区别</p></li><li><p>问题仍然没有解决，还是报错了</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The method personal_newAccount does not exist/is not available] undefine</span><br></pre></td></tr></table></figure><p>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccountError2.png" alt="newAccount"></p></li><li><p>继续查找解决方案</p><blockquote><p>Are you running with code from the Geth console or from an external JavaScript environment? If you connect an external environment to Geth via the HTTP-RPC interface, by default the personal namespace is not available due to security considerations.</p></blockquote><p>发现问题所在，默认情况下，<code>personal</code>由于安全考虑，命名空间不可用</p></li><li><p>解决方案</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Run your node with --rpc and --rpcapi personal,web3 flags.</span><br><span class="line">i.e. geth --dev --rpcapi personal,web3,eth --rpc</span><br><span class="line">You may need to add --rpccorsdomain &quot;&lt;your-domain&gt;&quot;, in case you are using web3 in the web.</span><br><span class="line">geth --dev --rpcapi personal,web3,eth --rpccorsdomain &quot;your-domain&quot;</span><br></pre></td></tr></table></figure><p>  参照dalao的提示，使用<code>geth</code>启动私有链的时候需要加入<code>--rpcapi personal,web3,eth</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr YOUR_IP -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure><p>  然后再次测试<br>  <img src="/2018/12/24/DApp开发遇到问题以及解决/newAccount.png" alt="newAccount"></p></li><li>参考链接 - <a href="https://github.com/ethereum/go-ethereum/issues/2723#event-698940135" target="_blank" rel="noopener">personal_newAccount does not exist/is not available</a></li></ul><h1 id="Web3-js-0-2XX版本-与-Web3-js-1-0版本"><a href="#Web3-js-0-2XX版本-与-Web3-js-1-0版本" class="headerlink" title="Web3.js 0.2XX版本 与 Web3.js 1.0版本"></a>Web3.js 0.2XX版本 与 Web3.js 1.0版本</h1><ul><li><a href="https://web3.learnblockchain.cn/0.2x.x/" target="_blank" rel="noopener">Web3.js 0.2x.x API 中文版手册</a></li><li><a href="http://cw.hubwiz.com/card/c/web3.js-1.0/1/1/1/" target="_blank" rel="noopener">Web3.js 1.0 中文手册</a> </li><li>二者关于<code>API</code>的使用有较多的区别，不能混用。个人后面发现<code>Web3.js 1.0</code>更加好用，然后就果断上车了</li></ul><h1 id="Remix连接私有链出现的问题"><a href="#Remix连接私有链出现的问题" class="headerlink" title="Remix连接私有链出现的问题"></a>Remix连接私有链出现的问题</h1><h2 id="问题1-Not-possible-to-connect-to-the-Web3-provider"><a href="#问题1-Not-possible-to-connect-to-the-Web3-provider" class="headerlink" title="问题1: Not possible to connect to the Web3 provider"></a>问题1: Not possible to connect to the Web3 provider</h2><p>Not possible to connect to the Web3 provider. Make sure the provider is running and a connection is open (via IPC or RPC).<br>    <img src="/2018/12/24/DApp开发遇到问题以及解决/remixE0.png" alt="remix"><br>错误原因： 在使用<code>geth</code>启动私有链结点的时候没有<code>--rpc</code><br>解决:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth,net --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr 127.0.0.1 -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure></p><pre><code>加入以后可以正常连接了</code></pre><h2 id="问题2-成功连接后显示can-39-t-detect-network"><a href="#问题2-成功连接后显示can-39-t-detect-network" class="headerlink" title="问题2: 成功连接后显示can&#39;t detect network"></a>问题2: 成功连接后显示<code>can&#39;t detect network</code></h2><p><img src="/2018/12/24/DApp开发遇到问题以及解决/remixE1.png" alt="remix"><br>错误原因： 在使用<code>geth</code>启动私有链结点的时候没有zding开启<code>net</code><br>解决:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth -datadir myData/00 -networkid 2018 -rpc -rpcapi personal,web3,eth,net --rpcport &quot;8545&quot; --port &quot;30303&quot; -rpcaddr 127.0.0.1 -rpccorsdomain &quot;*&quot; console</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本次博客简单记录下开发DApp过程中遇到的一些问题，以及相应的解决方案，因此写的也是很随意，仅供参考&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Capacitated Facility Location Problem</title>
    <link href="http://yoursite.com/2018/12/22/Capacitated-Facility-Location-Problem/"/>
    <id>http://yoursite.com/2018/12/22/Capacitated-Facility-Location-Problem/</id>
    <published>2018-12-22T13:24:46.000Z</published>
    <updated>2018-12-22T17:53:49.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/Liu-YT/CFL-Problem" target="_blank" rel="noopener">项目地址</a></p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Suppose there are n facilities and m customers. We wish to choose: </p><ul><li>which of the n facilities to open </li><li>the assignment of customers to facilities </li></ul><p>The objective is to minimize the sum of the opening cost and the assignment cost. </p><p><strong>The total demand assigned to a facility must not exceed its capacity.</strong> </p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>该问题阐述的比较明确，目前有<code>n</code>个设备，每个设备开启需要一个固定的费用，然后又有<code>m</code>个顾客，每个顾客有一定的需求，但是每个设备能够提供的资源是有限的，并且每个顾客使用相应的设备的时候还需要提供一笔附加的费用，此处还有一个前提条件是一个顾客所有需求只能被一个设备处理。目前的问题是，如何给顾客分配设备，使得最后总费用最小。</p><p>这是一个<code>NP-hard</code>的问题，给出一种分配方式，我们可以比较容易的确定其是否可行，但是如果想要找到一个最理想的分配方案，则是非常的难的，我们只能尽可能的找到一个比较理想的解。最近在用<code>模拟退火(SA)</code>与<code>遗传算法(GA)</code>解决另一个比较经典的问题-<code>TSP</code>问题，所以本次也就优先想到使用这两种算法来搜索得到一个比较理想的解，但是这些<strong>最终解都是当前解里面最优的，为相应算法中的最优解，并非全局最优</strong> 。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><blockquote><p>关于<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/355508?fr=aladdin" target="_blank" rel="noopener">模拟退火算法</a>以及<a href="https://baike.baidu.com/item/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/838140?fr=aladdin" target="_blank" rel="noopener">遗传算法</a>的具体流程就不再详细，都是比较经典的算法，接下来主要讲讲与问题相关联的核心部分思路与实现</p></blockquote><h2 id="模拟退火-SA"><a href="#模拟退火-SA" class="headerlink" title="模拟退火 (SA)"></a>模拟退火 (SA)</h2><blockquote><p>模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。</p></blockquote><p>在本次算法设计中，比较关键的点在于搜索中<strong>领域操作</strong>的设计上，领域操作影响着最终结果的好坏，通过邻域动作。产生初始解的邻居解，然后根据某种策略选择邻居解。一直重复以上过程，直到达到终止条件。对于本次场景而言，对于产生的解，只要是新解所需要的费用小于目前的费用，则直接选择该接。而对于一些比当前的解要差的解，以一定的概率接受，采纳的概率为:</p><script type="math/tex; mode=display">P_k = e^{(-\Delta E_k) / T}</script><p>本次模拟退火算法设计中，所设计的领域操作位<strong>在用户序列中随机选择两个位置，对于在此之间的用户为其重新随机选择一次所选择的设备，如果随机到的设备所能提供的容量不满足，则再次随机选择设备，直到选择到合适的为止</strong>，该领域操作尽可能的涉及到了各种可能的分配方案，尽可能的扰动当前结果以及概率接受差解，使其可能跳出局部最优解，已得到比较理想的解。</p><p><a href="https://github.com/Liu-YT/CFL-Problem/blob/master/src/SA.hpp" target="_blank" rel="noopener">模拟退火算法主要核心代码</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟退火</span></span><br><span class="line"><span class="keyword">while</span>(T &gt; <span class="number">0.01</span>) &#123;</span><br><span class="line">    <span class="comment">/* 扰动获得寻找较优解，并且可能接收差解 */</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; SEARCHTIMES) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = rand() % (p-&gt;numOfCus);</span><br><span class="line">        <span class="keyword">int</span> second = rand() % (p-&gt;numOfCus - first) + first;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newCusToFac = cusToFac;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newFreeCapacity = freeCapacity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = first; j &lt;= second; ++j)</span><br><span class="line">            newFreeCapacity[newCusToFac[j]] += p-&gt;cusDemand[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机分配一个新的工厂</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = first; j &lt;= second; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;cusDemand[j] &gt; newFreeCapacity[newFac])</span><br><span class="line">                newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            newCusToFac[j] = newFac;</span><br><span class="line">            newFreeCapacity[newFac] -= p-&gt;cusDemand[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cost = calCost(p, newCusToFac, newFreeCapacity);</span><br><span class="line">        <span class="keyword">double</span> probability = (rand() % <span class="number">100</span>) * <span class="number">1.0</span> / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前解，一定概率接受</span></span><br><span class="line">        <span class="keyword">if</span> (cost &lt;= totalCost || probability &lt; <span class="built_in">exp</span>(-<span class="built_in">abs</span>(cost-totalCost) / T)) &#123;</span><br><span class="line">            cusToFac = newCusToFac;</span><br><span class="line">            freeCapacity = newFreeCapacity;</span><br><span class="line">            totalCost = cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 降温</span></span><br><span class="line">    T *= alpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>SEARCHTIMES</code>，局部搜索的次数设置也比较关键，搜索次数也影响着结果的好坏，如果次数太少则可能造成遗漏比较多，而次数设置的比较大的话，对于数据量比较小的情况将造成算力浪费。因此考虑到可能出现的随机情况$C^2_n$，因此对于不同问题，动态设置局部搜索的次数为<code>SEARCHTIMES = n * (n-1) / 2</code>，但是其实还是很耗时，但是效果还可以。</p><h2 id="遗传算法-GA"><a href="#遗传算法-GA" class="headerlink" title="遗传算法 (GA)"></a>遗传算法 (GA)</h2><blockquote><p>关于遗传算法解决，其实个人认为普通的遗传算法效率并不高，并且如果没有针对问题有一定的设计的话，很难达到比较好的状态。</p></blockquote><p>首先需要大概的了解遗传算法的主要流程<br><img src="/2018/12/22/Capacitated-Facility-Location-Problem/GA.png" alt="GA"></p><p><code>Code</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化种群</span></span><br><span class="line">initPopulation(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟遗传</span></span><br><span class="line"><span class="keyword">int</span> curGen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(curGen &lt; MAXGEN) &#123;</span><br><span class="line">    <span class="comment">// 选择</span></span><br><span class="line">    select(p);</span><br><span class="line">    <span class="comment">// 交叉</span></span><br><span class="line">    crosscover(p);</span><br><span class="line">    <span class="comment">// 变异</span></span><br><span class="line">    mutate(p);</span><br><span class="line">    ++curGen; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>适应度评估</strong>，其适应度等于该方案费用<code>cost</code>的倒数，即<code>1 / cost</code></p><hr><p>关于<strong>选择</strong>，使用比较通用的<a href="https://www.cnblogs.com/legend1130/archive/2016/03/29/5333087.html" target="_blank" rel="noopener">轮盘赌</a>，同时选择其他的选择策略的效果也是不错的</p><hr><p>关于<strong>种群初始化</strong>，其实默认是比较容易的，即随机生成种群即可，但是实验起来发现随机生成初始种群，其收敛效果很差并且效率很低。因此<strong>在初始化种群的时候加入部分贪心生成的个体</strong>，加快种群成熟速度，也保证了种群中个体的多样性。关于贪心生成个体的思路也比较简单，打乱顾客挑选设备的顺序，每次未顾客挑选当前所需要费用最小的设备。但是关于贪心生成的较优个体的占额也需要注意，如果占的比列比较大，可能会导致过早收敛，出现早熟现象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化种群</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPopulation</span><span class="params">(problem* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为提高效率，初始时候通过贪心加入一部分较优个体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        individual* ind = <span class="keyword">new</span> individual(p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> fac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;cusDemand[j] &gt; ind-&gt;freeCapacity[fac])</span><br><span class="line">                fac = rand() % (p-&gt;numOfFac);</span><br><span class="line">            ind-&gt;freeCapacity[fac] -= p-&gt;cusDemand[j];</span><br><span class="line">            ind-&gt;cusToFac[j] = fac;</span><br><span class="line">        &#125; </span><br><span class="line">        evalute(p, ind);</span><br><span class="line">        population.push_back(ind);      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贪心生成解</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p-&gt;numOfCus; ++i) temp.push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        individual *ind = <span class="keyword">new</span> individual(p);</span><br><span class="line">        random_shuffle(temp.begin(), temp.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mixCost = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p-&gt;numOfFac; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;cusDemand[temp[j]] &lt;= ind-&gt;freeCapacity[k] &amp;&amp; mixCost &gt;= p-&gt;useCost[temp[j]][k]) &#123;</span><br><span class="line">                    mixCost = p-&gt;useCost[temp[j]][k];</span><br><span class="line">                    ind-&gt;freeCapacity[k] -= p-&gt;cusDemand[temp[j]];</span><br><span class="line">                    ind-&gt;cusToFac[temp[j]] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        evalute(p, ind);</span><br><span class="line">        population.push_back(ind);</span><br><span class="line">    &#125;</span><br><span class="line">    random_shuffle(population.begin(), population.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>交叉操作</strong>，第<code>n</code>条染色体与第<code>n+1</code>条染色体有一定的概率进行交叉<code>(n = 0, 2, 4, ..., 2n)</code>。这部分使用<strong>两点交叉</strong></p><blockquote><p>两点交叉（Two-point Crossover）：在个体编码串中随机设置了两个交叉点，然后再进行部分基因交换</p></blockquote><p>但是交叉后的结果可能是不可行的方案，我们需要判断一下交叉后的解是否可行，然后再进行一定的策略操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crosscover</span><span class="params">(problem* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两点交叉 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;individual*&gt; subPopulation;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POSIZE / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rand() % <span class="number">100</span>) * <span class="number">1.0</span> / <span class="number">100</span> &lt;= PXOVER) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count++ &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                individual *a = <span class="keyword">new</span> individual(population[i*<span class="number">2</span>]);</span><br><span class="line">                individual *b = <span class="keyword">new</span> individual(population[i*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> geneFirst = rand() % (p-&gt;numOfCus);</span><br><span class="line">                <span class="keyword">int</span> geneSecond = rand() % (p-&gt;numOfCus - geneFirst) + geneFirst;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = geneFirst; k &lt;= geneSecond; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a-&gt;cusToFac[k];</span><br><span class="line">                    a-&gt;cusToFac[k] = b-&gt;cusToFac[k];</span><br><span class="line">                    b-&gt;cusToFac[k] = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (validCover(p, a) &amp;&amp; validCover(p, b)) &#123;</span><br><span class="line">                    evalute(p, a);</span><br><span class="line">                    evalute(p, b);</span><br><span class="line">                    subPopulation.push_back(a);</span><br><span class="line">                    subPopulation.push_back(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(subPopulation.begin(), subPopulation.end(), [&amp;](<span class="keyword">const</span> individual* a, <span class="keyword">const</span> individual* b) -&gt; <span class="keyword">bool</span>&#123; <span class="keyword">return</span> a-&gt;cost &lt; b-&gt;cost;&#125;);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subPopulation.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; POSIZE; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(population[j]-&gt;cost &gt; subPopulation[i]-&gt;cost) &#123;</span><br><span class="line">                individual* temp = population[j];</span><br><span class="line">                population[j] = subPopulation[i];</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num; i &lt; subPopulation.size(); ++i)</span><br><span class="line">        <span class="keyword">delete</span> subPopulation[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>关于<strong>变异</strong>，使用最基本的基因变异的原理，种群中每个个体的每个顾客看作一个基因，基因突变则看成为该顾客重新选择一个对应的可用的设备<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 变异</span><br><span class="line">void mutate(problem* p) &#123;</span><br><span class="line">    for(int i = 0; i &lt; POSIZE; ++i) &#123;</span><br><span class="line">        double pro = (rand() % 100) * 1.0 / 100;</span><br><span class="line">        if(pro &lt;= PMUTATION) &#123;</span><br><span class="line">            for(int j = 0; j &lt; p-&gt;numOfCus; ++j) &#123;</span><br><span class="line">                int newFac = rand() % p-&gt;numOfFac;</span><br><span class="line">                population[i]-&gt;freeCapacity[population[i]-&gt;cusToFac[j]] += p-&gt;cusDemand[j];</span><br><span class="line">                while (p-&gt;cusDemand[j] &gt; population[i]-&gt;freeCapacity[newFac])</span><br><span class="line">                    newFac = rand() % (p-&gt;numOfFac);</span><br><span class="line">                population[i]-&gt;freeCapacity[newFac] -= p-&gt;cusDemand[j];</span><br><span class="line">                population[i]-&gt;cusToFac[j] = newFac;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><blockquote><p><a href="https://github.com/Liu-YT/CFL-Problem/tree/master/result/csv" target="_blank" rel="noopener">完整结果</a></p></blockquote><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><div class="table-container"><table><thead><tr><th>Problem</th><th>Result</th><th>Time(s)</th></tr></thead><tbody><tr><td>p1</td><td>9075</td><td>0.729</td></tr><tr><td>p2</td><td>8315</td><td>0.685</td></tr><tr><td>p3</td><td>10076</td><td>0.684</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>p68</td><td>26452</td><td>51.886</td></tr><tr><td>p69</td><td>35383</td><td>54.413</td></tr><tr><td>p70</td><td>50826</td><td>51.292</td></tr><tr><td>p71</td><td>39417</td><td>51.519</td></tr></tbody></table></div><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><div class="table-container"><table><thead><tr><th>Problem</th><th>Result</th><th>Time(s)</th></tr></thead><tbody><tr><td>p1</td><td>10220</td><td>10.727</td></tr><tr><td>p2</td><td>9493</td><td>11.888</td></tr><tr><td>p3</td><td>11653</td><td>10.831</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>p68</td><td>33324</td><td>43.275</td></tr><tr><td>p69</td><td>38309</td><td>44.419</td></tr><tr><td>p70</td><td>59304</td><td>38.904</td></tr><tr><td>p71</td><td>46541</td><td>37.729</td></tr></tbody></table></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从结果的运行时间可用比较直观的看出两个算法对于数据量比较大的时候都比较费时，可以控制时间但是会导致解的变差，增大运算此时解可能会更加好，但是时间太长，难以接受</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Liu-YT/CFL-Problem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="NP-hard" scheme="http://yoursite.com/tags/NP-hard/"/>
    
  </entry>
  
  <entry>
    <title>服务计算 - 6 BoltDB学习与简单剖析</title>
    <link href="http://yoursite.com/2018/12/14/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97-6-BoltDB%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/14/服务计算-6-BoltDB学习与简单剖析/</id>
    <published>2018-12-14T07:29:51.000Z</published>
    <updated>2018-12-14T13:08:54.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BoltDB-介绍"><a href="#BoltDB-介绍" class="headerlink" title="BoltDB 介绍"></a>BoltDB 介绍</h1><blockquote><p>Bolt is a pure Go key/value store inspired by Howard Chu’s LMDB project. The goal of the project is to provide a simple, fast, and reliable database for projects that don’t require a full database server such as Postgres or MySQL.<br>Since Bolt is meant to be used as such a low-level piece of functionality, simplicity is key. The API will be small and only focus on getting values and setting values. That’s it.</p></blockquote><p><code>BoltDB</code>是一个嵌入式<code>key/value</code>的数据库，即只需要将其链接到你的应用程序代码中即可使用<code>BoltDB</code>提供的<code>API</code>来高效的存取数据。而且<code>BoltDB</code>支持完全可序列化的<code>ACID事务</code>，让应用程序可以更简单的处理复杂操作</p><h1 id="BoltDB-使用"><a href="#BoltDB-使用" class="headerlink" title="BoltDB 使用"></a>BoltDB 使用</h1><p><strong><code>BoltDB</code>使用<code>Golang</code>开发</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/boltdb/bolt</span></span><br></pre></td></tr></table></figure><h2 id="创建和启动数据库"><a href="#创建和启动数据库" class="headerlink" title="创建和启动数据库"></a>创建和启动数据库</h2><p>使用<code>bolt.Open()</code>函数进行创建或者打开数据库<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := bolt.Open(<span class="string">"data.db"</span>, <span class="number">0600</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p>该命令将打开当前目录下<code>data.db</code>文件，<strong>如果该文件不存在，则将被创建</strong>。</p><p><code>Open</code>方法三个参数</p><ul><li>第一个参数为路径，指定需要打开的数据库，不存在将会被创建</li><li>第二个参数为文件操作权限</li><li>第三个参数为可选参数，内部可以配置只读和超时等</li></ul><p><code>BoltDB</code>是文件操作类型的数据库，打开数据库后将有一个文件锁，不允许多个进程同时打开同一个数据库。如果多个同时操作的话后者会被挂起直到前者关闭操作为止，为了避免无限等待，在打开数据库的时候可以配置超时时间<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db, err := bolt.Open(<span class="string">"my.db"</span>, <span class="number">0600</span>, &amp;bolt.Options&#123;Timeout: <span class="number">1</span> * time.Second&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="读写事务"><a href="#读写事务" class="headerlink" title="读写事务"></a>读写事务</h2><p>对于读写事务，可以使用<code>DB.Update</code>来完成<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>DB.Update</code>方法可以对数据库进行读写操作。在闭包内部，可以获得数据库的一致视图。 在结尾返回<code>nil</code>来提交事务，也可以通过返回错误随时回滚事务。 读写事务中允许所有数据库操作，始终检查返回错误，因为它将报告可能导致您的事务无法完成的任何磁盘故障。 如果您在关闭中返回错误，它将被传递。</p><ul><li><p><strong>Example</strong><br>  需要注意在读写事务以及只读事务中，如果没有相应的<code>Bucket</code>，是不能直接对其进行操作的，必须先创建</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create bucket</span></span><br><span class="line">db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := tx.CreateBucketIfNotExists([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    CheckErr(err)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  往<code>peopleBucket</code>桶中插入一个<code>People</code>，其<code>key</code>值为其ID，<code>value</code>为People的序列化后的字符串</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it = model.People&#123;&#125;</span><br><span class="line">it.ID = <span class="string">"1"</span></span><br><span class="line">db.Update(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    b := tx.Bucket([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    jsons, errs := json.Marshal(it)</span><br><span class="line">    CheckErr(errs)</span><br><span class="line">    err := b.Put([]<span class="keyword">byte</span>(it.ID), jsons)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h2><p>对于只读事务，使用<code>DB.View</code>来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.View(func(tx *bolt.Tx) error &#123;</span><br><span class="line">    ...</span><br><span class="line">    return nil</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在此闭包中获得数据库的一致视图，但是，只读事务中不允许进行变更操作。 只能在只读事务中检索存储桶，检索值和复制数据库。需要注意的是读写事务和只读事务不应该在同一个<code>goroutine</code>里同时打开，这是由于读写事务需要周期性重新映射数据文件，与只读事务发生冲突，可能造成死锁。<code>BoltDB</code>一次只允许一个读写事务，单一次允许多个只读事务，保持数据一致性。</p><ul><li><strong>Example</strong><br>  获取<code>peopleBucket</code>桶中<code>key</code>值为<code>&quot;1&quot;</code>的<code>value</code>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.View(<span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    b := tx.Bucket([]<span class="keyword">byte</span>(peopleBucket))</span><br><span class="line">    v := b.Get([]<span class="keyword">byte</span>(<span class="string">"1"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, v)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="批量更新事务"><a href="#批量更新事务" class="headerlink" title="批量更新事务"></a>批量更新事务</h2><p>每个<code>DB.Update()</code>等待磁盘提交写入。 通过将多个更新与<code>DB.Batch()</code>函数组合，可以最大限度地减少此开销<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.Batch(func(tx *bolt.Tx) error &#123;</span><br><span class="line">    ...</span><br><span class="line">    return nil</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在整个批处理的过程中，如果某个事务失败了，批处理将会多次调用给定的函数。函数只有在<code>DB.Batch</code>返回成功才表示成功完成。如果批处理中途失败了，整个事务将会回滚。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更多详细的用法请参考 <a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">boltdb/bolt</a></p><h1 id="BoltDB-源码简单剖析"><a href="#BoltDB-源码简单剖析" class="headerlink" title="BoltDB 源码简单剖析"></a>BoltDB 源码简单剖析</h1><p>关于源码部分，纯属一些个人的理解以及网上相关一些讲解，对于某些部分可能理解不是很到位，还望多多指正，源码部分设计到比较底层具体文件存储部分感觉还是很难理解的，此部分只是简单的摸索一下其中的机制与一些方法的执行过程</p><p>首先先探索一下一开始启动数据库中其是设置文件锁<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock file so that other processes using Bolt in read-write mode cannot</span></span><br><span class="line"><span class="comment">// use the database  at the same time. This would cause corruption since</span></span><br><span class="line"><span class="comment">// the two processes would write meta pages and free pages separately.</span></span><br><span class="line"><span class="comment">// The database file is locked exclusively (only one process can grab the lock)</span></span><br><span class="line"><span class="comment">// if !options.ReadOnly.</span></span><br><span class="line"><span class="comment">// The database file is locked using the shared lock (more than one process may</span></span><br><span class="line"><span class="comment">// hold a lock at the same time) otherwise (options.ReadOnly is set).</span></span><br><span class="line"><span class="keyword">if</span> err := flock(db, mode, !db.readOnly, options.Timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    _ = db.<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>呃其实这部分注释已经解释的很明确了，但是还是看看这个<code>flock</code>函数吧<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flock acquires an advisory lock on a file descriptor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flock</span><span class="params">(db *DB, mode os.FileMode, exclusive <span class="keyword">bool</span>, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t time.Time</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// If we're beyond our timeout then return an error.</span></span><br><span class="line"><span class="comment">// This can only occur after we've attempted a flock once.</span></span><br><span class="line"><span class="keyword">if</span> t.IsZero() &#123;</span><br><span class="line">t = time.Now()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> timeout &gt; <span class="number">0</span> &amp;&amp; time.Since(t) &gt; timeout &#123;</span><br><span class="line"><span class="keyword">return</span> ErrTimeout</span><br><span class="line">&#125;</span><br><span class="line">flag := syscall.LOCK_SH</span><br><span class="line"><span class="keyword">if</span> exclusive &#123;</span><br><span class="line">flag = syscall.LOCK_EX</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Otherwise attempt to obtain an exclusive lock.</span></span><br><span class="line">err := syscall.Flock(<span class="keyword">int</span>(db.file.Fd()), flag|syscall.LOCK_NB)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != syscall.EWOULDBLOCK &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for a bit and try again.</span></span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来其一开始先定义一个变量，用一个死循环在运行这段代码，如果在设置的<code>timeout</code>时间段内仍然得不到这个文件的锁，则将返回一个超时错误，如果没有设置<code>timeout</code>，则其将一直等待，直到获得该文件的锁，即获得该文件的使用权，其实这与操作系统中的进程同步异步使用一个互斥锁的机制是相似的。接着再来看看其对于未创建过的数据库是如何创建的以及如何对其初始化<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the database if it doesn't exist.</span></span><br><span class="line"><span class="keyword">if</span> info, err := db.file.Stat(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> info.Size() == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize new files with meta pages.</span></span><br><span class="line">    <span class="keyword">if</span> err := db.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Read the first meta page to determine the page size.</span></span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">0x1000</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">if</span> _, err := db.file.ReadAt(buf[:], <span class="number">0</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        m := db.pageInBuffer(buf[:], <span class="number">0</span>).meta()</span><br><span class="line">        <span class="keyword">if</span> err := m.validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// If we can't read the page size, we can assume it's the same</span></span><br><span class="line">            <span class="comment">// as the OS -- since that's how the page size was chosen in the</span></span><br><span class="line">            <span class="comment">// first place.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// If the first page is invalid and this OS uses a different</span></span><br><span class="line">            <span class="comment">// page size than what the database was created with then we</span></span><br><span class="line">            <span class="comment">// are out of luck and cannot access the database.</span></span><br><span class="line">            db.pageSize = os.Getpagesize()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            db.pageSize = <span class="keyword">int</span>(m.pageSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其首先先对文件是否存在以及文件的类型进行判断，调用<code>db.file.Stat</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stat returns the FileInfo structure describing file.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span> <span class="title">Stat</span><span class="params">()</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> file == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalid</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> file.isdir() &#123;</span><br><span class="line">        <span class="comment">// I don't know any better way to do that for directory</span></span><br><span class="line">        <span class="keyword">return</span> Stat(file.dirinfo.path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isNulName(file.name) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;devNullStat, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ft, err := file.pfd.GetFileType()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">"GetFileType"</span>, file.name, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> ft &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.FILE_TYPE_PIPE, syscall.FILE_TYPE_CHAR:</span><br><span class="line">        <span class="keyword">return</span> &amp;fileStat&#123;name: basename(file.name), filetype: ft&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs, err := newFileStatFromGetFileInformationByHandle(file.name, file.pfd.Sysfd)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    fs.filetype = ft</span><br><span class="line">    <span class="keyword">return</span> fs, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断其实也是比较简单的吧，还是接着看其是如何初始化一个新的数据库<code>db.init()</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init creates a new database file and initializes its meta pages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">init</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Set the page size to the OS page size.</span></span><br><span class="line">db.pageSize = os.Getpagesize()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create two meta pages on a buffer.</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, db.pageSize*<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">p := db.pageInBuffer(buf[:], pgid(i))</span><br><span class="line">p.id = pgid(i)</span><br><span class="line">p.flags = metaPageFlag</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the meta page.</span></span><br><span class="line">m := p.meta()</span><br><span class="line">m.magic = magic</span><br><span class="line">m.version = version</span><br><span class="line">m.pageSize = <span class="keyword">uint32</span>(db.pageSize)</span><br><span class="line">m.freelist = <span class="number">2</span></span><br><span class="line">m.root = bucket&#123;root: <span class="number">3</span>&#125;</span><br><span class="line">m.pgid = <span class="number">4</span></span><br><span class="line">m.txid = txid(i)</span><br><span class="line">m.checksum = m.sum64()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write an empty freelist at page 3.</span></span><br><span class="line">p := db.pageInBuffer(buf[:], pgid(<span class="number">2</span>))</span><br><span class="line">p.id = pgid(<span class="number">2</span>)</span><br><span class="line">p.flags = freelistPageFlag</span><br><span class="line">p.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write an empty leaf page at page 4.</span></span><br><span class="line">p = db.pageInBuffer(buf[:], pgid(<span class="number">3</span>))</span><br><span class="line">p.id = pgid(<span class="number">3</span>)</span><br><span class="line">p.flags = leafPageFlag</span><br><span class="line">p.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the buffer to our data file.</span></span><br><span class="line"><span class="keyword">if</span> _, err := db.ops.writeAt(buf, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fdatasync(db); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这感觉还是能明白在干嘛的，其采用单个文件来将数据存储在磁盘上，该文件的前4个<code>page</code>是固定的，分别是 <code>meta page</code>、<code>meta page</code>、<code>freelist</code>、<code>leaf page</code>，但是对于这4个<code>page</code>，到底是什么就让人很头大了。先看<code>meta page</code>的定义<code>p.meta()</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// meta returns a pointer to the metadata section of the page.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *page)</span> <span class="title">meta</span><span class="params">()</span> *<span class="title">meta</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (*meta)(unsafe.Pointer(&amp;p.ptr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还是先看看其基础的<code>page</code>的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> page <span class="keyword">struct</span> &#123;</span><br><span class="line">    id       pgid</span><br><span class="line">    flags    <span class="keyword">uint16</span></span><br><span class="line">    count    <span class="keyword">uint16</span></span><br><span class="line">    overflow <span class="keyword">uint32</span></span><br><span class="line">    ptr      <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>page</code>是<code>boltdb</code>持久化时，与磁盘相关的数据结构。<code>page</code>的大小采用操作系统内存页的大小，即<code>getpagesize</code>系统调用的返回值。<code>id</code>为<code>page</code>的序号，<code>flags</code>表示<code>page</code>的类型，有<code>branchPageFlag/leafPageFlag/metaPageFlag/freelistPageFlag</code>几种，<code>count</code>当<code>page</code>是<code>freelistPageFlag</code>类型时，存储的是<code>freelist</code>中<code>pgid</code>数组中元素的个数;当<code>page</code>时其他类型时，存储的是<code>inode</code>的个数，<code>overflow</code>记录<code>page</code>中数据量超过一个<code>page</code>所能存储的大小时候需要额外的<code>page</code>的数目<br>每个page对应对应一个磁盘上的数据块。这个数据块的layout为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| page struct data | page element items | k-v pairs |</span><br></pre></td></tr></table></figure></p><p>其分为3个部分：</p><ul><li>第一部分<code>page struct data</code>是该<code>page</code>的<code>header</code>，存储的就是<code>pagestruct</code>的数据。</li><li>第二部分<code>page element items</code>其实就是<code>node</code>的里<code>inode</code>的持久化部分数据。</li><li>第三部分<code>k-v pairs</code>存储的是<code>inode</code>里具体的<code>key-value</code>数据。</li></ul></blockquote><p>接着就可以探索一下<code>meta page</code>是什么玩意了<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> meta <span class="keyword">struct</span> &#123;</span><br><span class="line">    magic    <span class="keyword">uint32</span>  <span class="comment">// 存储魔数0xED0CDAED</span></span><br><span class="line">    version  <span class="keyword">uint32</span>  <span class="comment">// 标明存储格式的版本，现在是2</span></span><br><span class="line">    pageSize <span class="keyword">uint32</span>  <span class="comment">// 标明每个page的大小</span></span><br><span class="line">    flags    <span class="keyword">uint32</span>  <span class="comment">// 当前已无用</span></span><br><span class="line">    root     bucket  <span class="comment">// 根Bucket</span></span><br><span class="line">    freelist pgid    <span class="comment">// 标明当前freelist数据存在哪个page中</span></span><br><span class="line">    pgid     pgid    <span class="comment">//</span></span><br><span class="line">    txid     txid    <span class="comment">//</span></span><br><span class="line">    checksum <span class="keyword">uint64</span>  <span class="comment">// 以上数据的校验和，校验数据是否损坏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着再看看<code>freelist</code>是什么，关于<code>freelist</code>的定义需要一层层不断找，比较繁琐<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// freelist represents a list of all pages that are available for allocation.</span></span><br><span class="line"><span class="comment">// It also tracks pages that have been freed but are still in use by open transactions.</span></span><br><span class="line"><span class="keyword">type</span> freelist <span class="keyword">struct</span> &#123;</span><br><span class="line">ids     []pgid          <span class="comment">// all free and available free page ids.</span></span><br><span class="line">pending <span class="keyword">map</span>[txid][]pgid <span class="comment">// mapping of soon-to-be free page ids by tx.</span></span><br><span class="line">cache   <span class="keyword">map</span>[pgid]<span class="keyword">bool</span>   <span class="comment">// fast lookup of all free and pending page ids.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>依赖注释我们已经可以大概猜测出<code>freelist</code>的作用，其是<code>BoltDb</code>实现磁盘空间的重复利用机制中需要用到的文件<code>page</code>缓存</p><blockquote><p><code>ids</code>记录了当前缓存着的空闲<code>page</code>的<code>pgid</code>，<code>cache</code>中记录的也是这些<code>pgid</code>，采用<code>map</code>记录 方便快速查找。</p><p>当用户需要<code>page</code>时，调用<code>freelist.allocate(n int) pgid</code>，其中n为需要的<code>page</code>数量，其会遍历<code>ids</code>，从中 挑选出连续n个空闲的<code>page</code>，然后将其从缓存中剔除，然后将其实的<code>page-id</code>返回给调用者。当不存在满足需求的 page时，返回0，因为文件的起始2个page固定为meta page，因此有效的page-id不可能为0。</p><p>当某个写事务产生无用page时，将调用<code>freelist.free(txid txid, p *page)</code>将指定page p放入pending池和 cache中。当下一个写事务开启时，会将没有Tx引用的pending中的page搬移到ids缓存中。之所以这样做， 是为了支持事务的回滚和并发读事务，从而实现<code>MVCC</code>。</p><p>当发起一个读事务时，<code>Tx</code>单独复制一份<code>meta</code>信息，从这份独有的<code>meta</code>作为入口，可以读出该<code>meta</code>指向的数据， 此时即使有一个写事务修改了相关key的数据，新修改的数据只会被写入新的page，读事务持有的page会进入pending 池，因此该读事务相关的数据并不会被修改。只有该page相关的读事务都结束时，才会从pending池进入到cache池 中，从而被复用修改。</p><p>当写事务更新数据时，并不直接覆盖老数据，而且分配一个新的page将更新后的数据写入，然后将老数据占用的page 放入pending池，建立新的索引。当事务需要回滚时，只需要将pending池中的page释放，将索引回滚即完成数据的 回滚。这样加速了事务的回滚。减少了事务缓存的内存使用，同时避免了对正在读的事务的干扰。</p></blockquote><p>到这里我们也大概了解到<code>BoltDb</code>中部分的机制，说实话关于一些涉及底层方面的有点难以理解，主要关于数据库存储以及操作系统方面的知识面太浅了，之前没有好好学习，还是得先去好好看看数据库和文件系统相关以及存储相关的知识再继续尝试学习源码了吧</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://github.com/boltdb/bolt" target="_blank" rel="noopener">boltdb/bolt</a></li><li><a href="https://zhuanlan.zhihu.com/p/27444660" target="_blank" rel="noopener">聊聊BoltDB：简单使用</a></li><li><a href="https://studygolang.com/articles/9939" target="_blank" rel="noopener">boltdb持久化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BoltDB-介绍&quot;&gt;&lt;a href=&quot;#BoltDB-介绍&quot; class=&quot;headerlink&quot; title=&quot;BoltDB 介绍&quot;&gt;&lt;/a&gt;BoltDB 介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Bolt is a pure Go key/value s
      
    
    </summary>
    
      <category term="服务计算" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="服务计算" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>132. Palindrome Partitioning II</title>
    <link href="http://yoursite.com/2018/12/06/132-Palindrome-Partitioning-II/"/>
    <id>http://yoursite.com/2018/12/06/132-Palindrome-Partitioning-II/</id>
    <published>2018-12-06T06:18:55.000Z</published>
    <updated>2018-12-06T08:03:24.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p><p><strong>Example:</strong></p><pre><strong>Input:</strong>&nbsp;"aab"<strong>Output:</strong> 1<strong>Explanation:</strong> The palindrome partitioning ["aa","b"] could be produced using 1 cut.</pre></div></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题给出一个字符串，求出将该字符串最少分割多少次可以实现其分割后的子串都是回文串</li><li>本题求解比较复杂，主要思路是先求字符串某个区间内的子串是否是回文串然后，如果是说明可以被分割，否则不能被进行分割(因为分割以后也不是回文串，需要继续被分割)</li><li>本题使用<code>isPal[i,j]</code>记录字符串在<code>[i,j]</code>是否是一个回文串，使用<code>cut[i]</code>记录字符串在区间<code>[i, size]</code>被分割后所有子串都为回文串需要被分割多少次，因此我们需要分类进行讨论，假设当前的区间为<code>[i,j]</code>    <ul><li>首先需要对区间<code>[i,j]</code>是否是一个回文串进行判断<ul><li><code>i &lt; j</code><ul><li>不满足区间的基本要求</li></ul></li><li><code>i == j</code><ul><li>显然是一个回文串，<code>isPal[i,j] = true</code></li></ul></li><li><code>j == i+1</code> <ul><li>如果<code>s[i] == s[j]</code>，则这也是回文串，即<code>isPal[i,j] = true</code>，否则不是一个回文串</li></ul></li><li><code>i+1 &lt; j</code><ul><li>这部分判断比较麻烦，我们利用动态规划的思想，如果在区间<code>[i+1,j-1]</code>的子串是一个回文串，那么如果<code>s[i] == s[j]</code>的话，则该子串也是一个回文串，即<code>isPal[i,j] = true</code>，否则的话不是</li></ul></li></ul></li><li>判断完该区间的子串是否是回文串后，我们需要对<code>cut[i]</code>进行更新。如果<code>[i,j]</code>是一个回文串(<code>isPal[i,j] == true</code>)的话，说明我们对于区间<code>[i, size)</code>有了一个新的分割方法，即在原基础上变成<code>[i, j] + [j+1, size)</code>，因此我们可以更新<code>cut[i]</code><ul><li><code>cut[i] = min(cut[i], cut[j+1] + 1)</code></li><li>此处将原区间<code>[i, j]</code>分割成<code>[i, j] + [j+1, size)</code>两部分，需要在<code>c[j+1]</code>次的基础上再加一次分割操作，即分割次数为<code>c[j+1]+1</code>，但是我们需要注意的一点是对于第一次分割即<code>[size-1, size)</code>区间操作，其实分割次数是<code>0</code>，不需要对其进行分割，但是为了写法统一还是加1，后面的操作也不断使用到本次分割，因此对于每次的<code>cut[i]</code>都比实际多了1。因此最后返回字符串最小分割次数时候，即分割区间<code>[0, size)</code>的分割次数为<code>cut[0]-1</code></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断区间[i, j]的字符是否是回文串</span></span><br><span class="line">        <span class="keyword">bool</span> isPal[s.size()][s.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录区间[i, size]需要切割的次数</span></span><br><span class="line">        <span class="keyword">int</span> cut[s.size()+<span class="number">1</span>];</span><br><span class="line">        cut[s.size()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cut[i] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.size(); ++j) &#123;</span><br><span class="line">                isPal[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == j || i+<span class="number">1</span> == j &amp;&amp; s[i] == s[j] || i+<span class="number">1</span> &lt; j &amp;&amp; isPal[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                    isPal[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    cut[i] = min(cut[i], cut[j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cut[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given a string &lt;em&gt;s&lt;/em&gt;, partition &lt;
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>57. Insert Interval</title>
    <link href="http://yoursite.com/2018/12/06/57-Insert-Interval/"/>
    <id>http://yoursite.com/2018/12/06/57-Insert-Interval/</id>
    <published>2018-12-06T06:15:54.000Z</published>
    <updated>2018-12-06T06:52:38.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]<strong>Output:</strong> [[1,5],[6,9]]</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code><strong>Output:</strong> [[1,2],[3,10],[12,16]]<strong>Explanation:</strong> Because the new interval <code>[4,8]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</pre></div></div><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这道题目给出一个有序的区间集合，再给出一个新的区间，将其合并进去区间集合中，然后输出合并后的区间集合</li><li>这道题需要进行分类讨论，主要针对新的区间以及原区间集合的边界问题进行讨论。此处假设新的区间<code>newInterval</code>表现形式为<code>[newStart, newEnd]</code>，当前遍历到区间集合内的区间为<code>[start, end]</code>，此处需要注意的一点是区间集合内的区间都是已经排好序的，即当前区间<code>end</code>小于下一个区间的<code>start</code>。此处讨论主要分区间重叠的情况与不重叠两个方向进行讨论<ul><li>区间不重叠 <ul><li>区间不重叠，说明新的区间无法与当前区间进行合并，因此我们只需要考虑是否将新的区间加入集合以及将当前区间加入的问题即可</li><li><code>newEnd &lt; start</code><ul><li>此时说明新区间在当前区间的前面，但是我们需要判断新的区间是否已经加入区间集合中，如果已经加入，对新的区间无需任何操作，只需要加入当前区间即可，如果未加入，我们需要先加入新的区间（为了保证集合内区间也是排好序的），然后再加入当前区间</li></ul></li><li><code>newStart &gt; end</code><ul><li>无需考虑加入新区间问题，只需要把当前区间加入集合中即可</li></ul></li></ul></li><li>区间重叠<ul><li>当前的区间与新的区间出现重叠的情况，区间可以进行合并。我们不需要考虑是否将区间加入到集合中，因为可能与后面区间仍然可能重叠而需要合并的情况，因此只需要更新一下新的区间，等到不重叠的情况时候再考虑加入，<ul><li><code>newInterval.start = min(newInterval.start, intervals[i].start)</code></li><li><code>newInterval.end = max(newInterval.end, intervals[i].end)</code></li></ul></li></ul></li></ul></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; insert(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            v.push_back(newInterval);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isAdd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); ++i) &#123; </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(intervals[i].start &gt; newInterval.end) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isAdd) v.push_back(newInterval);</span><br><span class="line">                v.push_back(intervals[i]);</span><br><span class="line">                isAdd = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i].end &lt; newInterval.start) &#123;</span><br><span class="line">                v.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newInterval.start = min(newInterval.start, intervals[i].start);</span><br><span class="line">                newInterval.end = max(newInterval.end, intervals[i].end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isAdd) v.push_back(newInterval);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Given a set of &lt;em&gt;non-overlapping&lt;/em
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>123. Best Time to Buy and Sell Stock III</title>
    <link href="http://yoursite.com/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/"/>
    <id>http://yoursite.com/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/</id>
    <published>2018-12-02T07:29:13.000Z</published>
    <updated>2018-12-02T08:42:07.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div class="content__eAC7"><div><p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:&nbsp;</strong>You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> [3,3,5,0,0,3,1,4]<strong>Output:</strong> 6<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.&nbsp;            Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> [1,2,3,4,5]<strong>Output:</strong> 4<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.&nbsp;            Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are&nbsp;            engaging multiple transactions at the same time. You must sell before buying again.</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> [7,6,4,3,1]<strong>Output:</strong> 0<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.</pre></div></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>本题题目意思比较简单，给出连续n天交易日的股票价格，问在其中什么时候买入什么时候卖出获得最大的收入，求出最大的收入值是多少。本题还有一点是比较关键的，<strong>最多允许两次交易</strong>，并且交易日期中买入股票和卖出股票不能在同一天。</li></ul><h4 id="解法-1-超时"><a href="#解法-1-超时" class="headerlink" title="解法 1 - 超时"></a>解法 1 - <code>超时</code></h4><ul><li><p>以某个交易日为分界线将总时间分成两个时间段，计算该天前包括当天的交易获利以及该天以后时间段的交易获利，最后计算总和获得交易两次的最大获利</p><ul><li>时间复杂度 - $O(n^2)$</li><li>空间复杂度 - $O(n)$</li></ul></li><li><p>实现代码</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre[prices.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> post[prices.size()] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求某天前(包括当天)成交的最大利润</span></span><br><span class="line">        <span class="keyword">int</span> prebase = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> preMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">            preMaxProfit = max(preMaxProfit, prices[i] - prebase);</span><br><span class="line">            pre[i] = preMaxProfit;</span><br><span class="line">            prebase = min(prebase, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求某天后成交的最大利润</span></span><br><span class="line">        <span class="keyword">int</span> postBase = prices[prices.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> postMaxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            postMaxProfit = max(postMaxProfit, postBase - prices[i]);</span><br><span class="line">            post[i<span class="number">-1</span>] = postMaxProfit;</span><br><span class="line">            postBase = max(postBase, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prices.size(); ++j)</span><br><span class="line">                maxProfit = max(maxProfit, pre[i] + post[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>结果 - <code>超时</code><br><img src="/2018/12/02/123-Best-Time-to-Buy-and-Sell-Stock-III/1.png" alt="preview"></p></li></ul><h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法 2"></a>解法 2</h4><ul><li><p>该解法其实是总结了一下<code>解法 1</code>以及参考了一下评论里面的解法，其实现起来也比较简单，但是理解起来稍微费解一点，其维护四个变量，<code>buy1</code>表示第一次买股票的花费，<code>sell1</code>表示第一次交易股票后获得的利润，<code>buy2</code>表示第二次买股票后剩余的钱（第一次交易利润-购买的股票价格），<code>sell2</code>表示第二次交易后剩余的钱，即两次交易下来最后的盈利。当然也不一定需要两次交易，加入交易以后亏钱的话是不会进行交易的。</p><ul><li>时间复杂度 - $O(n)$</li><li>空间复杂度 - $O(1)$</li></ul></li><li><p>实现代码</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> buy1 = INT_MIN, buy2 = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>, sell2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices)&#123;</span><br><span class="line">            buy1 = max(buy1, -price);</span><br><span class="line">            sell1 = max(sell1, buy1 + price);</span><br><span class="line">            buy2 = max(buy2, sell1 - price);</span><br><span class="line">            sell2 = max(sell2, buy2 + price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解法-3"><a href="#解法-3" class="headerlink" title="解法 3"></a>解法 3</h4><ul><li>这个解法与解法 2的思路类似，但是做了一定的拓展，其不仅仅适用于只交易2次，也可以拓展适用于交易<code>k</code>次的情况。对于<code>profit[i][j]</code>即交易日<code>i</code>到交易日<code>j</code>这个时间段买入的收入，其应该是大于等于<code>profit[i][j-1]</code>，即大于前一个时间都的利润，同时其也可以在第<code>j</code>个交易日卖出自己的股票，此时收益为<code>余额 + 卖出价格</code>，此时当前时间段最大利润值为<code>余额 + 卖出价格</code>与<code>profit[i][j-1]</code>的最大值</li><li>实现代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交易两次，得到的利润</span></span><br><span class="line">        <span class="keyword">int</span> profit[<span class="number">3</span>][prices.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prices.size(); ++j)</span><br><span class="line">                profit[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> balance = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; prices.size(); j++) &#123;</span><br><span class="line">                profit[i][j] = max(profit[i][j - <span class="number">1</span>], balance + prices[j]);</span><br><span class="line">                balance = max(balance, profit[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit[<span class="number">2</span>][prices.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;div class=&quot;content__eAC7&quot;&gt;&lt;div&gt;&lt;p&gt;Say you have an array for which the &lt;e
      
    
    </summary>
    
      <category term="算法 | leetcode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95-leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
